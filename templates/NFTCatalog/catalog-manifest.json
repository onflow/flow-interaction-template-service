{
  "ac864a47c36182a1ef29fda5680a45ef5c750543409abc4310b1ef962e1cf128": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ac864a47c36182a1ef29fda5680a45ef5c750543409abc4310b1ef962e1cf128",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Withdraw Unstaked Tokens"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Withdraws unstaked tokens from a stake held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Request to withdraw unstaked tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault if it is there\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.withdrawUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74561496
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34028006
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node ID"
              }
            }
          },
          "balance": ""
        },
        "delegatorID": {
          "index": 1,
          "type": "UInt32?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The delegator ID"
              }
            }
          },
          "balance": ""
        },
        "amount": {
          "index": 2,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount of unstaked tokens to withdraw"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "6b2739fc0b8114047180badbee699fe6a5d4fb3b74753c35c4f170c30572db1b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6b2739fc0b8114047180badbee699fe6a5d4fb3b74753c35c4f170c30572db1b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Withdraw Rewarded Tokens"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Withdraws rewarded tokens from a stake held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Request to withdraw rewarded tokens for the specified node or delegator in the staking collection\n/// The tokens are automatically deposited to the unlocked account vault first,\n/// And then any locked tokens are deposited into the locked account vault\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.withdrawRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74561368
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34027928
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node ID"
              }
            }
          },
          "balance": ""
        },
        "delegatorID": {
          "index": 1,
          "type": "UInt32?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The delegator ID"
              }
            }
          },
          "balance": ""
        },
        "amount": {
          "index": 2,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount of rewarded tokens to withdraw"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "9f5ee4feb3ffe7a6a20a72d8d2e7878d4d548216c947c95e7ce067fe471217f0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9f5ee4feb3ffe7a6a20a72d8d2e7878d4d548216c947c95e7ce067fe471217f0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Withdraw FLOW from Machine Account"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Withdraws FLOW from a machine account"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Request to withdraw tokens from the machine account\n/// The tokens are automatically deposited to the unlocked account vault\ntransaction(nodeID: String, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.withdrawFromMachineAccount(nodeID: nodeID, amount: amount)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74763650
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34158165
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Node ID"
              }
            }
          },
          "balance": ""
        },
        "amount": {
          "index": 1,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount to withdraw"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "544acba77bdc712251cd81befa5cb97414928c7ace95eb6a5aeb4fac133b861f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "544acba77bdc712251cd81befa5cb97414928c7ace95eb6a5aeb4fac133b861f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Update Networking Address"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Updates the networking address for a node held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Changes the networking address for the specified node\ntransaction(nodeID: String, newAddress: String) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.updateNetworkingAddress(nodeID: nodeID, newAddress: newAddress)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74763522
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34158081
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Node ID"
              }
            }
          },
          "balance": ""
        },
        "newAddress": {
          "index": 1,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The new Networking Address for this node"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "00d2d230282e78ef38c85eb6ca5423158d6ab5905bf5bd541825588caf9dcd32": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "00d2d230282e78ef38c85eb6ca5423158d6ab5905bf5bd541825588caf9dcd32",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Request Unstaking"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Requests unstaking for a stake held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Requests to unstake ALL tokens for the specified node or delegator in the staking collection\ntransaction(nodeID: String) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.unstakeAll(nodeID: nodeID)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74763406
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34158006
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Node ID"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "b8299dbdf3c38ea0a99063c4b2bbe4ea950c488f7e66795d032b312a3a9c4dcc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b8299dbdf3c38ea0a99063c4b2bbe4ea950c488f7e66795d032b312a3a9c4dcc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Transfer Node"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Transfers a Node from one Staking Collection to another"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n// Transfers a NodeStaker object from an authorizers accoount\n// and adds the NodeStaker to another accounts Staking Collection\n// identified by the to Address.\ntransaction(nodeID: String, to: Address) {\n    let fromStakingCollectionRef: &FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: &FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}\n    prepare(account: AuthAccount) {\n        // The account to transfer the NodeStaker object to must have a valid Staking Collection in order to receive the NodeStaker.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(\"Destination account must have a Staking Collection set up.\")\n        }\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        // Get the PublicAccount of the account to transfer the NodeStaker to. \n        let toAccount = getAccount(to)\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.getCapability<&FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}>(FlowStakingCollection.StakingCollectionPublicPath).borrow()\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        let machineAccountInfo = self.fromStakingCollectionRef.getMachineAccounts()[nodeID]\n            ?? panic(\"Could not get machine account info for the specified node ID\")\n        // Remove the NodeStaker from the authorizers StakingCollection.\n        let nodeStaker <- self.fromStakingCollectionRef.removeNode(nodeID: nodeID)\n        // Deposit the NodeStaker to the receivers StakingCollection.\n        self.toStakingCollectionCap.addNodeObject(<- nodeStaker!, machineAccountInfo: machineAccountInfo)\n    }\n}",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74762847
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34157658
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Node ID"
              }
            }
          },
          "balance": ""
        },
        "to": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The account to transfer to"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "753a69b813b6bc62ba5e83d929e402f97ad75e925133a993354a6708c134eea5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "753a69b813b6bc62ba5e83d929e402f97ad75e925133a993354a6708c134eea5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Transfer Delegation"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Transfers a delegation from one Staking Collection to another"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n// Transfers a NodeDelegator object from an authorizers accoount\n// and adds the NodeDelegator to another accounts Staking Collection\n// identified by the to Address.\ntransaction(nodeID: String, delegatorID: UInt32, to: Address) {\n    let fromStakingCollectionRef: &FlowStakingCollection.StakingCollection\n    let toStakingCollectionCap: &FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}\n    prepare(account: AuthAccount) {\n        // The account to transfer the NodeDelegator object to must have a valid Staking Collection in order to receive the NodeDelegator.\n        if (!FlowStakingCollection.doesAccountHaveStakingCollection(address: to)) {\n            panic(\"Destination account must have a Staking Collection set up.\")\n        }\n        // Get a reference to the authorizers StakingCollection\n        self.fromStakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        // Get the PublicAccount of the account to transfer the NodeDelegator to. \n        let toAccount = getAccount(to)\n        // Borrow a capability to the public methods available on the receivers StakingCollection.\n        self.toStakingCollectionCap = toAccount.getCapability<&FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}>(FlowStakingCollection.StakingCollectionPublicPath).borrow()\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        // Remove the NodeDelegator from the authorizers StakingCollection.\n        let nodeDelegator <- self.fromStakingCollectionRef.removeDelegator(nodeID: nodeID, delegatorID: delegatorID)\n        // Deposit the NodeDelegator to the receivers StakingCollection.\n        self.toStakingCollectionCap.addDelegatorObject(<- nodeDelegator!)\n    }\n}",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74763025
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34157768
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Node ID"
              }
            }
          },
          "balance": ""
        },
        "delegatorID": {
          "index": 1,
          "type": "UInt32",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Delegator ID"
              }
            }
          },
          "balance": ""
        },
        "to": {
          "index": 2,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The account to transfer to"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "7bc3056ba5d39d130f45411c2c05bb549db8ce727c11a1cb821136a621be27fb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7bc3056ba5d39d130f45411c2c05bb549db8ce727c11a1cb821136a621be27fb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Stake Unstaked Tokens"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Stakes unstaked tokens for a stake held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Commits unstaked tokens to stake for the specified node or delegator in the staking collection\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.stakeUnstakedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74561240
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34027842
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node ID"
              }
            }
          },
          "balance": ""
        },
        "delegatorID": {
          "index": 1,
          "type": "UInt32?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The delegator ID"
              }
            }
          },
          "balance": ""
        },
        "amount": {
          "index": 2,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount of unstaked tokens to restake"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "b9f4fe796cb86959c549e7b2412c51607622d7d9ba891425ed6c4640e730178a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b9f4fe796cb86959c549e7b2412c51607622d7d9ba891425ed6c4640e730178a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Stake Rewarded Tokens"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Stakes rewarded tokens for a stake held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Commits rewarded tokens to stake for the specified node or delegator in the staking collection\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.stakeRewardedTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74561128
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34027770
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node ID"
              }
            }
          },
          "balance": ""
        },
        "delegatorID": {
          "index": 1,
          "type": "UInt32?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The delegator ID"
              }
            }
          },
          "balance": ""
        },
        "amount": {
          "index": 2,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount of rewarded tokens to restake"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "7b581646d265ec6ed4a0d29c809ae6f0adafe56794d6a9eb162513187c43befc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7b581646d265ec6ed4a0d29c809ae6f0adafe56794d6a9eb162513187c43befc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Stake New Tokens"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Stakes new tokens for a stake held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Commits new tokens to stake for the specified node or delegator in the staking collection\n/// The tokens from the locked vault are used first, if it exists\n/// followed by the tokens from the unlocked vault\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.stakeNewTokens(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74561022
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34027702
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node ID"
              }
            }
          },
          "balance": ""
        },
        "delegatorID": {
          "index": 1,
          "type": "UInt32?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The delegator ID"
              }
            }
          },
          "balance": ""
        },
        "amount": {
          "index": 2,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount of FLOW tokens to stake"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "dfb30fb76518ae901dc18993d8a00a8329a5d4b36dfd4bd357245457aa47eea8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "dfb30fb76518ae901dc18993d8a00a8329a5d4b36dfd4bd357245457aa47eea8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Setup Staking Collection"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Sets up a Staking Collection for an account"
          }
        }
      },
      "cadence": "import FungibleToken from 0xFUNGIBLETOKENADDRESS\nimport FlowToken from 0xFLOWTOKENADDRESS\nimport FlowIDTableStaking from 0xIDENTITYTABLEADDRESS\nimport LockedTokens from 0xLOCKEDTOKENADDRESS\nimport FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// This transaction sets up an account to use a staking collection\n/// It will work regardless of whether they have a regular account, a two-account locked tokens setup,\n/// or staking objects stored in the unlocked account\ntransaction {\n    prepare(signer: AuthAccount) {\n        // If there isn't already a staking collection\n        if signer.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath) == nil {\n            // Create private capabilities for the token holder and unlocked vault\n            let lockedHolder = signer.link<&LockedTokens.TokenHolder>(/private/flowTokenHolder, target: LockedTokens.TokenHolderStoragePath)!\n            let flowToken = signer.link<&FlowToken.Vault>(/private/flowTokenVault, target: /storage/flowTokenVault)!\n            \n            // Create a new Staking Collection and put it in storage\n            if lockedHolder.check() {\n                signer.save(<-FlowStakingCollection.createStakingCollection(unlockedVault: flowToken, tokenHolder: lockedHolder), to: FlowStakingCollection.StakingCollectionStoragePath)\n            } else {\n                signer.save(<-FlowStakingCollection.createStakingCollection(unlockedVault: flowToken, tokenHolder: nil), to: FlowStakingCollection.StakingCollectionStoragePath)\n            }\n            // Create a public link to the staking collection\n            signer.link<&FlowStakingCollection.StakingCollection{FlowStakingCollection.StakingCollectionPublic}>(\n                FlowStakingCollection.StakingCollectionPublicPath,\n                target: FlowStakingCollection.StakingCollectionStoragePath\n            )\n        }\n        // borrow a reference to the staking collection\n        let collectionRef = signer.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow staking collection reference\")\n        // If there is a node staker object in the account, put it in the staking collection\n        if signer.borrow<&FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath) != nil {\n            let node <- signer.load<@FlowIDTableStaking.NodeStaker>(from: FlowIDTableStaking.NodeStakerStoragePath)!\n            collectionRef.addNodeObject(<-node, machineAccountInfo: nil)\n        }\n        // If there is a delegator object in the account, put it in the staking collection\n        if signer.borrow<&FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath) != nil {\n            let delegator <- signer.load<@FlowIDTableStaking.NodeDelegator>(from: FlowIDTableStaking.DelegatorStoragePath)!\n            collectionRef.addDelegatorObject(<-delegator)\n        }\n    }\n}\n",
      "dependencies": {
        "0xFUNGIBLETOKENADDRESS": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "contract": "FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 34157509
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "contract": "FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 74762620
            }
          }
        },
        "0xFLOWTOKENADDRESS": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "contract": "FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 34157509
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "contract": "FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 74762620
            }
          }
        },
        "0xIDENTITYTABLEADDRESS": {
          "FlowIDTableStaking": {
            "testnet": {
              "address": "0x9eca2b38b18b5dfe",
              "fq_address": "A.0x9eca2b38b18b5dfe.FlowIDTableStaking",
              "contract": "FlowIDTableStaking",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 74762620
            },
            "mainnet": {
              "address": "0x8624b52f9ddcd04a",
              "fq_address": "A.0x8624b52f9ddcd04a.FlowIDTableStaking",
              "contract": "FlowIDTableStaking",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 34157509
            }
          }
        },
        "0xLOCKEDTOKENADDRESS": {
          "LockedTokens": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.LockedTokens",
              "contract": "LockedTokens",
              "pin": "7c7ff03a10696b7639f235e42b57becdfbdbcee1bb6f99d01f922d4554fe51f0",
              "pin_block_height": 74762620
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.LockedTokens",
              "contract": "LockedTokens",
              "pin": "7c7ff03a10696b7639f235e42b57becdfbdbcee1bb6f99d01f922d4554fe51f0",
              "pin_block_height": 34157509
            }
          }
        },
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74762620
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34157509
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "7ccd27aff8b42d4d61586f79eb5e11d55d01afdef384c9a7246bb1e1d385beb0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7ccd27aff8b42d4d61586f79eb5e11d55d01afdef384c9a7246bb1e1d385beb0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Request Unstaking"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Requests unstaking for a stake held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Requests unstaking for the specified node or delegator in the staking collection\ntransaction(nodeID: String, delegatorID: UInt32?, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.requestUnstaking(nodeID: nodeID, delegatorID: delegatorID, amount: amount)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74560125
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34027115
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node ID"
              }
            }
          },
          "balance": ""
        },
        "delegatorID": {
          "index": 1,
          "type": "UInt32?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The delegator ID"
              }
            }
          },
          "balance": ""
        },
        "UFix64": {
          "index": 2,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount to request to be unstaked"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "6d1ea6bf8bda73132afd038e0c9aabca8abeb84ac11259cbefa36b9337f2d19e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6d1ea6bf8bda73132afd038e0c9aabca8abeb84ac11259cbefa36b9337f2d19e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Register Node"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Register a node held in a Staking Collection"
          }
        }
      },
      "cadence": "import Crypto\nimport FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Registers a delegator in the staking collection resource\n/// for the specified node information and the amount of tokens to commit\ntransaction(id: String,\n            role: UInt8,\n            networkingAddress: String,\n            networkingKey: String,\n            stakingKey: String,\n            amount: UFix64,\n            publicKeys: [Crypto.KeyListEntry]?) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        if let machineAccount = self.stakingCollectionRef.registerNode(\n            id: id,\n            role: role,\n            networkingAddress: networkingAddress,\n            networkingKey: networkingKey,\n            stakingKey: stakingKey,\n            amount: amount,\n            payer: account) \n        {\n            if publicKeys == nil || publicKeys!.length == 0 {\n                panic(\"Cannot provide zero keys for the machine account\")\n            }\n            for key in publicKeys! {\n                machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)\n            }\n        }\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74559839
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34026928
            }
          }
        }
      },
      "arguments": {
        "id": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node ID"
              }
            }
          },
          "balance": ""
        },
        "role": {
          "index": 1,
          "type": "UInt8",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node role to register"
              }
            }
          },
          "balance": ""
        },
        "networkingAddress": {
          "index": 2,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The networking address"
              }
            }
          },
          "balance": ""
        },
        "networkingKey": {
          "index": 3,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The networking key"
              }
            }
          },
          "balance": ""
        },
        "stakingKey": {
          "index": 4,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The staking key"
              }
            }
          },
          "balance": ""
        },
        "amount": {
          "index": 5,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount of FLOW tokens to stake"
              }
            }
          },
          "balance": ""
        },
        "publicKeys": {
          "index": 6,
          "type": "[Crypto.KeyListEntry]?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Public Keys for the Machine Account (comma separated). Only required when registering Consensus or Collection nodes"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "b8a3ed26c222ed67016a28021d8fee5603b948533cbc992b3c90f71a61b2b312": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b8a3ed26c222ed67016a28021d8fee5603b948533cbc992b3c90f71a61b2b312",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Register Delegator"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Register a delegator held in a Staking Collection"
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Registers a delegator in the staking collection resource\n/// for the specified nodeID and the amount of tokens to commit\ntransaction(id: String, amount: UFix64) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.registerDelegator(nodeID: id, amount: amount)      \n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74559520
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 34026728
            }
          }
        }
      },
      "arguments": {
        "id": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The node ID to delegate to"
              }
            }
          },
          "balance": ""
        },
        "amount": {
          "index": 1,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The amount of FLOW tokens to delegate"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "83d205597ed6a447c8687a4b4144872c65f0b53fb31b65d51a3c1c904a6ff417": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "83d205597ed6a447c8687a4b4144872c65f0b53fb31b65d51a3c1c904a6ff417",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Create Machine Account"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Creates a Machine Account for node held in Staking Collection"
          }
        }
      },
      "cadence": "import Crypto\nimport FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n/// Creates a machine account for a node that is already in the staking collection\n/// and adds public keys to the new account\ntransaction(nodeID: String, publicKeys: [Crypto.KeyListEntry]) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n        if let machineAccount = self.stakingCollectionRef.createMachineAccountForExistingNode(nodeID: nodeID, payer: account) {\n            if publicKeys == nil || publicKeys!.length == 0 {\n                panic(\"Cannot provide zero keys for the machine account\")\n            }\n            for key in publicKeys {\n                machineAccount.keys.add(publicKey: key.publicKey, hashAlgorithm: key.hashAlgorithm, weight: key.weight)\n            }\n        } else {\n            panic(\"Could not create a machine account for the node\")\n        }\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74308589
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 33862897
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Node ID"
              }
            }
          },
          "balance": ""
        },
        "publicKeys": {
          "index": 1,
          "type": "[Crypto.KeyListEntry]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Public Keys for the Machine Account (comma separated)"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "38d0cca4b74c4e88213df636b4cfc2eb6e86fd8b2b84579d3b9bffab3e0b1fcb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "38d0cca4b74c4e88213df636b4cfc2eb6e86fd8b2b84579d3b9bffab3e0b1fcb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Close Stake"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Closes a stake held in a Staking Collection."
          }
        }
      },
      "cadence": "import FlowStakingCollection from 0xSTAKINGCOLLECTIONADDRESS\n// Closes out a staking object in the staking collection\n// This does not remove the record from the identity table,\n// but it does mean that the account that closes it cannot ever access it again\ntransaction(nodeID: String, delegatorID: UInt32?) {\n    \n    let stakingCollectionRef: &FlowStakingCollection.StakingCollection\n    prepare(account: AuthAccount) {\n        self.stakingCollectionRef = account.borrow<&FlowStakingCollection.StakingCollection>(from: FlowStakingCollection.StakingCollectionStoragePath)\n            ?? panic(\"Could not borrow ref to StakingCollection\")\n    }\n    execute {\n        self.stakingCollectionRef.closeStake(nodeID: nodeID, delegatorID: delegatorID)\n    }\n}\n",
      "dependencies": {
        "0xSTAKINGCOLLECTIONADDRESS": {
          "FlowStakingCollection": {
            "testnet": {
              "address": "0x95e019a17d0e23d7",
              "fq_address": "A.0x95e019a17d0e23d7.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 74308355
            },
            "mainnet": {
              "address": "0x8d0e87b65159ae63",
              "fq_address": "A.0x8d0e87b65159ae63.FlowStakingCollection",
              "contract": "FlowStakingCollection",
              "pin": "335e428a95ad99ec21eeb8899b40a4c351884191a32596207a79a2b22548442d",
              "pin_block_height": 33862742
            }
          }
        }
      },
      "arguments": {
        "nodeID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Node ID"
              }
            }
          },
          "balance": ""
        },
        "delegatorID": {
          "index": 1,
          "type": "UInt32?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The Delegator ID"
              }
            }
          },
          "balance": ""
        }
      }
    }
  },
  "c8cb7cc7a1c2a329de65d83455016bc3a9b53f9668c74ef555032804bac0b25b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c8cb7cc7a1c2a329de65d83455016bc3a9b53f9668c74ef555032804bac0b25b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Create Lilico EmeraldID"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Create a Lilico EmeraldID by mapping your Discord ID to your Lilico wallet address"
          }
        }
      },
      "cadence": "import EmeraldIdentityLilico from 0xEMERALDIDENTITYLILICO\n\ntransaction(discordID: String) {\n    prepare(admin: AuthAccount, user: AuthAccount) {\n        let administrator = admin.borrow<&EmeraldIdentityLilico.Administrator>(from: EmeraldIdentityLilico.AdministratorStoragePath)\n                                    ?? panic(\"Could not borrow the administrator\")\n        administrator.createEmeraldID(account: user.address, discordID: discordID)\n    }\n\n    execute {\n        log(\"Created EmeraldID\")\n    }\n}",
      "dependencies": {
        "0xEMERALDIDENTITYLILICO": {
          "EmeraldIdentityLilico": {
            "mainnet": {
              "address": "0x39e42c67cc851cfb",
              "contract": "EmeraldIdentityLilico",
              "fq_address": "A.0x39e42c67cc851cfb.EmeraldIdentityLilico",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 42017084
            }
          }
        }
      },
      "arguments": {
        "discordID": {
          "index": 0,
          "type": "String",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Your Discord ID"
              }
            }
          }
        }
      }
    }
  },
  "bd10ab0bf472e6b58ecc0398e9b3d1bd58a4205f14a7099c52c0640d9589295f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "bd10ab0bf472e6b58ecc0398e9b3d1bd58a4205f14a7099c52c0640d9589295f",
    "data": {
      "type": "script",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Multiply Two Integers"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Multiplies two integer arguments together and returns the result."
          }
        }
      },
      "cadence": "pub fun main(x: Int, y: Int): Int { return x * y }",
      "dependencies": {},
      "arguments": {
        "x": {
          "index": 0,
          "type": "Int",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Int 1"
              }
            }
          }
        },
        "y": {
          "index": 1,
          "type": "Int",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Int 2"
              }
            }
          }
        }
      }
    }
  },
  "4431a123049f8046a69c779672fcdd342b870371601040d4eb572158f5e6ee97": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4431a123049f8046a69c779672fcdd342b870371601040d4eb572158f5e6ee97",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "Transfer Flow Tokens"
          }
        },
        "description": {
          "i18n": {
            "en-US": "Transfer Flow tokens from your account to another account on the Flow blockchain"
          }
        }
      },
      "cadence": "import FungibleToken from 0xFUNGIBLETOKENADDRESS\n\ntransaction(amount: UFix64, to: Address) {\n\n    let vault: @{FungibleToken.Vault}\n\n    prepare(signer: auth(BorrowValue) &Account) {\n        self.vault <- signer.storage.borrow<auth(FungibleToken.Withdraw) &{FungibleToken.Provider}>(from: /storage/flowTokenVault)!\n            .withdraw(amount: amount)\n    }\n\n    execute {\n        getAccount(to).capabilities.borrow<&{FungibleToken.Receiver}>(/public/flowTokenReceiver)!\n            .deposit(from: <-self.vault)\n    }\n}",
      "dependencies": {
        "0xFUNGIBLETOKENADDRESS": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "contract": "FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 34166296
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "contract": "FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 74776482
            },
            "emulator": {
              "address": "0xee82856bf20e2aa6",
              "fq_address": "A.0xee82856bf20e2aa6.FungibleToken",
              "contract": "FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 0
            }
          }
        }
      },
      "arguments": {
        "amount": {
          "index": 0,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount to Transfer"
              }
            },
            "description": {
              "i18n": {
                "en-US": "The amount of Flow tokens to transfer (in Flow, not UFix64 units)"
              }
            }
          }
        },
        "to": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Recipient Address"
              }
            },
            "description": {
              "i18n": {
                "en-US": "The Flow account address that will receive the tokens"
              }
            }
          }
        }
      }
    }
  },
  "0f032797eb6013411eef9b24d6047f3b2a435f53073bcb11f9fb561a5807b9b5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0f032797eb6013411eef9b24d6047f3b2a435f53073bcb11f9fb561a5807b9b5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a xG NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: xG\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509038
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808260
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "09d096d098eb596fd225ec2fd17c1d3c188e7ab8d26d7fd97c4e966b93663379": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "09d096d098eb596fd225ec2fd17c1d3c188e7ab8d26d7fd97c4e966b93663379",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a xG NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import XGStudio from 0xXGStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: xG\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&XGStudio.Collection>(from: /storage/XGStudioCollection) == nil {\n            let collection <- XGStudio.createEmptyCollection()\n            acct.save(<-collection, to: /storage/XGStudioCollection)\n        }\n        if (acct.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection).borrow() == nil) {\n            acct.unlink(/public/XGStudioCollection)\n            acct.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection, target: /storage/XGStudioCollection)\n        }\n\n        if (acct.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XGStudioCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/XGStudioCollectionProvider)\n            acct.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XGStudioCollectionProvider, target: /storage/XGStudioCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/XGStudioCollectionProvider)!\n        let collectionRef = acct\n            .getCapability(/public/XGStudioCollection)\n            .borrow<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@XGStudio.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xXGStudio": {
          "XGStudio": {
            "mainnet": {
              "address": "0xc357c8d061353f5f",
              "contract": "XGStudio",
              "fq_address": "A.0xc357c8d061353f5f.XGStudio",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47508952
            },
            "testnet": {
              "address": "0xd9575c84a88eada0",
              "contract": "XGStudio",
              "fq_address": "A.0xd9575c84a88eada0.XGStudio",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95808164
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508967
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808171
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508973
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808180
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508978
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95808182
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508979
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808184
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508985
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808193
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "be2e4d39898879ed5dd72ef7b4fb8f458714eab046fb7a88cc6ae77e04f3a18a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "be2e4d39898879ed5dd72ef7b4fb8f458714eab046fb7a88cc6ae77e04f3a18a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed xG NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import XGStudio from 0xXGStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: xG\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&XGStudio.Collection>(from: /storage/XGStudioCollection) == nil {\n            let collection <- XGStudio.createEmptyCollection()\n            acct.save(<-collection, to: /storage/XGStudioCollection)\n            }\n        if (acct.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection).borrow() == nil) {\n            acct.unlink(/public/XGStudioCollection)\n            acct.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection, target: /storage/XGStudioCollection)\n        }\n\n        if (acct.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XGStudioCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/XGStudioCollectionProvider)\n            acct.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XGStudioCollectionProvider, target: /storage/XGStudioCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/XGStudioCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xXGStudio": {
          "XGStudio": {
            "mainnet": {
              "address": "0xc357c8d061353f5f",
              "contract": "XGStudio",
              "fq_address": "A.0xc357c8d061353f5f.XGStudio",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47508999
            },
            "testnet": {
              "address": "0xd9575c84a88eada0",
              "contract": "XGStudio",
              "fq_address": "A.0xd9575c84a88eada0.XGStudio",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95808220
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509012
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808228
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509020
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808238
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509023
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95808240
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509024
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808241
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509028
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808250
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "7f6011babb67ee198ba4aac53e180a5cadfa1c8371fa7edd8e6bfff54fd61891": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7f6011babb67ee198ba4aac53e180a5cadfa1c8371fa7edd8e6bfff54fd61891",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support xG NFTs"
          }
        }
      },
      "cadence": "import XGStudio from 0xXGStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: xG\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&XGStudio.Collection>(from: /storage/XGStudioCollection) == nil {\n      let collection <- XGStudio.createEmptyCollection()\n      signer.save(<-collection, to: /storage/XGStudioCollection)\n    }\n    if (signer.getCapability<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection).borrow() == nil) {\n      signer.unlink(/public/XGStudioCollection)\n      signer.link<&XGStudio.Collection{XGStudio.XGStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XGStudioCollection, target: /storage/XGStudioCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xXGStudio": {
          "XGStudio": {
            "mainnet": {
              "address": "0xc357c8d061353f5f",
              "contract": "XGStudio",
              "fq_address": "A.0xc357c8d061353f5f.XGStudio",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47508914
            },
            "testnet": {
              "address": "0xd9575c84a88eada0",
              "contract": "XGStudio",
              "fq_address": "A.0xd9575c84a88eada0.XGStudio",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95808120
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508927
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808127
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508935
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808136
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "0e2dd12abe3dd8af15f551cfb536d42a78ee02d431abd529f525dcb6705c7d70": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0e2dd12abe3dd8af15f551cfb536d42a78ee02d431abd529f525dcb6705c7d70",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a schmoes_prelaunch_token NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: schmoes_prelaunch_token\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506892
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6e4ec7822dcc52f0a956457d6f6c24f0a70c3dad1412feef3a73c164a2b9a841": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6e4ec7822dcc52f0a956457d6f6c24f0a70c3dad1412feef3a73c164a2b9a841",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a schmoes_prelaunch_token NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: schmoes_prelaunch_token\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n            let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n        }\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/public/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/private/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SchmoesPreLaunchTokenCollection)!\n        let collectionRef = acct\n            .getCapability(/public/SchmoesPreLaunchTokenCollection)\n            .borrow<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SchmoesPreLaunchToken.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSchmoesPreLaunchToken": {
          "SchmoesPreLaunchToken": {
            "mainnet": {
              "address": "0x6c4fe48768523577",
              "contract": "SchmoesPreLaunchToken",
              "fq_address": "A.0x6c4fe48768523577.SchmoesPreLaunchToken",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506854
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506857
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506861
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506861
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506863
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506866
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "91fe6600d5e89faae5d89490420f713b9c214a91caa2e9c5acf0fa975f2f9f5d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "91fe6600d5e89faae5d89490420f713b9c214a91caa2e9c5acf0fa975f2f9f5d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed schmoes_prelaunch_token NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: schmoes_prelaunch_token\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n            let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n            }\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/public/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/private/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SchmoesPreLaunchTokenCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSchmoesPreLaunchToken": {
          "SchmoesPreLaunchToken": {
            "mainnet": {
              "address": "0x6c4fe48768523577",
              "contract": "SchmoesPreLaunchToken",
              "fq_address": "A.0x6c4fe48768523577.SchmoesPreLaunchToken",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506874
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506877
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506881
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506883
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506883
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506888
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "85d00513698b95775e0e9895512e5813f3e6952faf74b6c48c0d6a394fbe8771": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "85d00513698b95775e0e9895512e5813f3e6952faf74b6c48c0d6a394fbe8771",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support schmoes_prelaunch_token NFTs"
          }
        }
      },
      "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: schmoes_prelaunch_token\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n      let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n    }\n    if (signer.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n      signer.unlink(/public/SchmoesPreLaunchTokenCollection)\n      signer.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSchmoesPreLaunchToken": {
          "SchmoesPreLaunchToken": {
            "mainnet": {
              "address": "0x6c4fe48768523577",
              "contract": "SchmoesPreLaunchToken",
              "fq_address": "A.0x6c4fe48768523577.SchmoesPreLaunchToken",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506837
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506841
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506845
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "6bb37ad8bf3aaca017a241f2929951960fdfe17dac5fca5a0c8bf701cf9469af": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6bb37ad8bf3aaca017a241f2929951960fdfe17dac5fca5a0c8bf701cf9469af",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a schmoes_pre_launch_token NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: schmoes_pre_launch_token\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95814007
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "65b8c4d3073b5ed3a248b7b2ca09da29a4d245170e4096679972c0ad4ce0a0d3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "65b8c4d3073b5ed3a248b7b2ca09da29a4d245170e4096679972c0ad4ce0a0d3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a schmoes_pre_launch_token NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: schmoes_pre_launch_token\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n            let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n        }\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/public/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/private/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SchmoesPreLaunchTokenCollection)!\n        let collectionRef = acct\n            .getCapability(/public/SchmoesPreLaunchTokenCollection)\n            .borrow<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SchmoesPreLaunchToken.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSchmoesPreLaunchToken": {
          "SchmoesPreLaunchToken": {
            "testnet": {
              "address": "0x44510157a80ad550",
              "contract": "SchmoesPreLaunchToken",
              "fq_address": "A.0x44510157a80ad550.SchmoesPreLaunchToken",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813962
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813966
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813971
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813972
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813973
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813977
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "36812f011aaab31a1d01a6cbc5c8e143f5dec87afcb56569524bbbba7aba2913": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "36812f011aaab31a1d01a6cbc5c8e143f5dec87afcb56569524bbbba7aba2913",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed schmoes_pre_launch_token NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: schmoes_pre_launch_token\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n            let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n            }\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/public/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n\n        if (acct.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n            acct.unlink(/private/SchmoesPreLaunchTokenCollection)\n            acct.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SchmoesPreLaunchTokenCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSchmoesPreLaunchToken": {
          "SchmoesPreLaunchToken": {
            "testnet": {
              "address": "0x44510157a80ad550",
              "contract": "SchmoesPreLaunchToken",
              "fq_address": "A.0x44510157a80ad550.SchmoesPreLaunchToken",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813987
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813991
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813995
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813997
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813997
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95814002
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "5a2aff3baad77f36f6d24463a5fefecd073f08184d3fe050ca36cbf45484881e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5a2aff3baad77f36f6d24463a5fefecd073f08184d3fe050ca36cbf45484881e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support schmoes_pre_launch_token NFTs"
          }
        }
      },
      "cadence": "import SchmoesPreLaunchToken from 0xSchmoesPreLaunchToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: schmoes_pre_launch_token\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SchmoesPreLaunchToken.Collection>(from: /storage/SchmoesPreLaunchTokenCollection) == nil {\n      let collection <- SchmoesPreLaunchToken.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SchmoesPreLaunchTokenCollection)\n    }\n    if (signer.getCapability<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection).borrow() == nil) {\n      signer.unlink(/public/SchmoesPreLaunchTokenCollection)\n      signer.link<&SchmoesPreLaunchToken.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SchmoesPreLaunchTokenCollection, target: /storage/SchmoesPreLaunchTokenCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSchmoesPreLaunchToken": {
          "SchmoesPreLaunchToken": {
            "testnet": {
              "address": "0x44510157a80ad550",
              "contract": "SchmoesPreLaunchToken",
              "fq_address": "A.0x44510157a80ad550.SchmoesPreLaunchToken",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813946
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813949
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813954
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "62c8ce5092a04b025bda42bdba57d9c1543bd272318bfbf024cb1bcc02df96f5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "62c8ce5092a04b025bda42bdba57d9c1543bd272318bfbf024cb1bcc02df96f5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a digiYo NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: digiYo\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488924
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "c94867353825472989864a5bbae71bd73951b0f76f3cf734b6aba4db2d74b733": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c94867353825472989864a5bbae71bd73951b0f76f3cf734b6aba4db2d74b733",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a digiYo NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Digiyo from 0xDigiyo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: digiYo\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Digiyo.Collection>(from: /storage/DigiyoNFTCollection) == nil {\n            let collection <- Digiyo.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DigiyoNFTCollection)\n        }\n        if (acct.getCapability<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DigiyoNFTCollection).borrow() == nil) {\n            acct.unlink(/public/DigiyoNFTCollection)\n            acct.link<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DigiyoNFTCollection, target: /storage/DigiyoNFTCollection)\n        }\n\n        if (acct.getCapability<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DigiyoCollection).borrow() == nil) {\n            acct.unlink(/private/DigiyoCollection)\n            acct.link<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DigiyoCollection, target: /storage/DigiyoNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DigiyoCollection)!\n        let collectionRef = acct\n            .getCapability(/public/DigiyoNFTCollection)\n            .borrow<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Digiyo.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDigiyo": {
          "Digiyo": {
            "mainnet": {
              "address": "0xae3baa0d314e546b",
              "contract": "Digiyo",
              "fq_address": "A.0xae3baa0d314e546b.Digiyo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488884
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488887
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488890
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488892
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488892
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488897
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "f96da1206ccf455c9346bb9155bf50e7bc652ad9cece7a281f9eb563256c7140": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f96da1206ccf455c9346bb9155bf50e7bc652ad9cece7a281f9eb563256c7140",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed digiYo NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Digiyo from 0xDigiyo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: digiYo\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Digiyo.Collection>(from: /storage/DigiyoNFTCollection) == nil {\n            let collection <- Digiyo.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DigiyoNFTCollection)\n            }\n        if (acct.getCapability<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DigiyoNFTCollection).borrow() == nil) {\n            acct.unlink(/public/DigiyoNFTCollection)\n            acct.link<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DigiyoNFTCollection, target: /storage/DigiyoNFTCollection)\n        }\n\n        if (acct.getCapability<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DigiyoCollection).borrow() == nil) {\n            acct.unlink(/private/DigiyoCollection)\n            acct.link<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DigiyoCollection, target: /storage/DigiyoNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DigiyoNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDigiyo": {
          "Digiyo": {
            "mainnet": {
              "address": "0xae3baa0d314e546b",
              "contract": "Digiyo",
              "fq_address": "A.0xae3baa0d314e546b.Digiyo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488906
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488909
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488914
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488915
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488915
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488919
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "cfa8ec752eb5dc49536dcffe63508dce7e1740f886cd9b4d29f48b674682f3a4": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cfa8ec752eb5dc49536dcffe63508dce7e1740f886cd9b4d29f48b674682f3a4",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support digiYo NFTs"
          }
        }
      },
      "cadence": "import Digiyo from 0xDigiyo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: digiYo\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Digiyo.Collection>(from: /storage/DigiyoNFTCollection) == nil {\n      let collection <- Digiyo.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DigiyoNFTCollection)\n    }\n    if (signer.getCapability<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DigiyoNFTCollection).borrow() == nil) {\n      signer.unlink(/public/DigiyoNFTCollection)\n      signer.link<&Digiyo.Collection{Digiyo.DigiyoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DigiyoNFTCollection, target: /storage/DigiyoNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDigiyo": {
          "Digiyo": {
            "mainnet": {
              "address": "0xae3baa0d314e546b",
              "contract": "Digiyo",
              "fq_address": "A.0xae3baa0d314e546b.Digiyo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488869
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488872
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488875
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "de28d67a300935e013e7375bc20cbb6a8fe2f67cb0774bd78eaead775bb2aef0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "de28d67a300935e013e7375bc20cbb6a8fe2f67cb0774bd78eaead775bb2aef0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a bl0x NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: bl0x\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508010
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807041
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6f43415e5c9fdac093f6f1b6a115921f2e97430572651d060aa1454877d16c5f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6f43415e5c9fdac093f6f1b6a115921f2e97430572651d060aa1454877d16c5f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a bl0x NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Bl0x from 0xBl0x\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: bl0x\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Bl0x.Collection>(from: /storage/bl0xNFTs) == nil {\n            let collection <- Bl0x.createEmptyCollection()\n            acct.save(<-collection, to: /storage/bl0xNFTs)\n        }\n        if (acct.getCapability<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs).borrow() == nil) {\n            acct.unlink(/public/bl0xNFTs)\n            acct.link<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs, target: /storage/bl0xNFTs)\n        }\n\n        if (acct.getCapability<&Bl0x.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/bl0xNFTs).borrow() == nil) {\n            acct.unlink(/private/bl0xNFTs)\n            acct.link<&Bl0x.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/bl0xNFTs, target: /storage/bl0xNFTs)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/bl0xNFTs)!\n        let collectionRef = acct\n            .getCapability(/public/bl0xNFTs)\n            .borrow<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Bl0x.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xBl0x": {
          "Bl0x": {
            "mainnet": {
              "address": "0x7620acf6d7f2468a",
              "contract": "Bl0x",
              "fq_address": "A.0x7620acf6d7f2468a.Bl0x",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507916
            },
            "testnet": {
              "address": "0xe8124d8428980aa6",
              "contract": "Bl0x",
              "fq_address": "A.0xe8124d8428980aa6.Bl0x",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95806940
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507934
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806947
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507942
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806957
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507947
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95806960
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507949
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806961
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507954
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806970
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b4e5fc73224e90600e64eb0eb186ce1565807460872651301f83dfadf0d14e69": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b4e5fc73224e90600e64eb0eb186ce1565807460872651301f83dfadf0d14e69",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed bl0x NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Bl0x from 0xBl0x\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: bl0x\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Bl0x.Collection>(from: /storage/bl0xNFTs) == nil {\n            let collection <- Bl0x.createEmptyCollection()\n            acct.save(<-collection, to: /storage/bl0xNFTs)\n            }\n        if (acct.getCapability<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs).borrow() == nil) {\n            acct.unlink(/public/bl0xNFTs)\n            acct.link<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs, target: /storage/bl0xNFTs)\n        }\n\n        if (acct.getCapability<&Bl0x.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/bl0xNFTs).borrow() == nil) {\n            acct.unlink(/private/bl0xNFTs)\n            acct.link<&Bl0x.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/bl0xNFTs, target: /storage/bl0xNFTs)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/bl0xNFTs\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xBl0x": {
          "Bl0x": {
            "mainnet": {
              "address": "0x7620acf6d7f2468a",
              "contract": "Bl0x",
              "fq_address": "A.0x7620acf6d7f2468a.Bl0x",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507964
            },
            "testnet": {
              "address": "0xe8124d8428980aa6",
              "contract": "Bl0x",
              "fq_address": "A.0xe8124d8428980aa6.Bl0x",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95806999
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507981
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807007
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507989
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807017
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507995
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95807019
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507996
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807020
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508000
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807030
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "0332a7f481f63eb039dc0fb7d3077b700c7aca741515dd97631574a5181a8645": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0332a7f481f63eb039dc0fb7d3077b700c7aca741515dd97631574a5181a8645",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support bl0x NFTs"
          }
        }
      },
      "cadence": "import Bl0x from 0xBl0x\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: bl0x\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Bl0x.Collection>(from: /storage/bl0xNFTs) == nil {\n      let collection <- Bl0x.createEmptyCollection()\n      signer.save(<-collection, to: /storage/bl0xNFTs)\n    }\n    if (signer.getCapability<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs).borrow() == nil) {\n      signer.unlink(/public/bl0xNFTs)\n      signer.link<&Bl0x.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bl0xNFTs, target: /storage/bl0xNFTs)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xBl0x": {
          "Bl0x": {
            "mainnet": {
              "address": "0x7620acf6d7f2468a",
              "contract": "Bl0x",
              "fq_address": "A.0x7620acf6d7f2468a.Bl0x",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507881
            },
            "testnet": {
              "address": "0xe8124d8428980aa6",
              "contract": "Bl0x",
              "fq_address": "A.0xe8124d8428980aa6.Bl0x",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95806895
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507897
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806903
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507905
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806913
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "1fcc956aadfa454a5ecef7960b3e8f355c4beec48564233147e67dea4255624f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1fcc956aadfa454a5ecef7960b3e8f355c4beec48564233147e67dea4255624f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a eFutureRewardsProgram NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: eFutureRewardsProgram\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499322
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ccfda8847aba1e04209be0db55141f6183d8988ba640c39fe4c3a0703e61e64f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ccfda8847aba1e04209be0db55141f6183d8988ba640c39fe4c3a0703e61e64f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a eFutureRewardsProgram NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import ethosFutureRewardsProgram from 0xethosFutureRewardsProgram\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: eFutureRewardsProgram\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ethosFutureRewardsProgram.Collection>(from: /storage/ethosFutureRewardsProgramCollection) == nil {\n            let collection <- ethosFutureRewardsProgram.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ethosFutureRewardsProgramCollection)\n        }\n        if (acct.getCapability<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ethosFutureRewardsProgramCollection).borrow() == nil) {\n            acct.unlink(/public/ethosFutureRewardsProgramCollection)\n            acct.link<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ethosFutureRewardsProgramCollection, target: /storage/ethosFutureRewardsProgramCollection)\n        }\n\n        if (acct.getCapability<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/ethosFutureRewardsProgramCollection).borrow() == nil) {\n            acct.unlink(/private/ethosFutureRewardsProgramCollection)\n            acct.link<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/ethosFutureRewardsProgramCollection, target: /storage/ethosFutureRewardsProgramCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/ethosFutureRewardsProgramCollection)!\n        let collectionRef = acct\n            .getCapability(/public/ethosFutureRewardsProgramCollection)\n            .borrow<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@ethosFutureRewardsProgram.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xethosFutureRewardsProgram": {
          "ethosFutureRewardsProgram": {
            "mainnet": {
              "address": "0xf92e92030f2701df",
              "contract": "ethosFutureRewardsProgram",
              "fq_address": "A.0xf92e92030f2701df.ethosFutureRewardsProgram",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47499283
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499286
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499290
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499290
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499291
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499296
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "0ad773b7cffdd650f70dd3db738f21b445b72769d0f40d5c0ba78f34de165dc6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0ad773b7cffdd650f70dd3db738f21b445b72769d0f40d5c0ba78f34de165dc6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed eFutureRewardsProgram NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import ethosFutureRewardsProgram from 0xethosFutureRewardsProgram\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: eFutureRewardsProgram\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ethosFutureRewardsProgram.Collection>(from: /storage/ethosFutureRewardsProgramCollection) == nil {\n            let collection <- ethosFutureRewardsProgram.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ethosFutureRewardsProgramCollection)\n            }\n        if (acct.getCapability<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ethosFutureRewardsProgramCollection).borrow() == nil) {\n            acct.unlink(/public/ethosFutureRewardsProgramCollection)\n            acct.link<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ethosFutureRewardsProgramCollection, target: /storage/ethosFutureRewardsProgramCollection)\n        }\n\n        if (acct.getCapability<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/ethosFutureRewardsProgramCollection).borrow() == nil) {\n            acct.unlink(/private/ethosFutureRewardsProgramCollection)\n            acct.link<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/ethosFutureRewardsProgramCollection, target: /storage/ethosFutureRewardsProgramCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/ethosFutureRewardsProgramCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xethosFutureRewardsProgram": {
          "ethosFutureRewardsProgram": {
            "mainnet": {
              "address": "0xf92e92030f2701df",
              "contract": "ethosFutureRewardsProgram",
              "fq_address": "A.0xf92e92030f2701df.ethosFutureRewardsProgram",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47499306
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499309
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499313
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499314
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499314
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499318
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "8af6797ba4a49c3de63f93f327217d95ac91d2b04303f20360b0ebf9976da163": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8af6797ba4a49c3de63f93f327217d95ac91d2b04303f20360b0ebf9976da163",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support eFutureRewardsProgram NFTs"
          }
        }
      },
      "cadence": "import ethosFutureRewardsProgram from 0xethosFutureRewardsProgram\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: eFutureRewardsProgram\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&ethosFutureRewardsProgram.Collection>(from: /storage/ethosFutureRewardsProgramCollection) == nil {\n      let collection <- ethosFutureRewardsProgram.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ethosFutureRewardsProgramCollection)\n    }\n    if (signer.getCapability<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ethosFutureRewardsProgramCollection).borrow() == nil) {\n      signer.unlink(/public/ethosFutureRewardsProgramCollection)\n      signer.link<&ethosFutureRewardsProgram.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ethosFutureRewardsProgramCollection, target: /storage/ethosFutureRewardsProgramCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xethosFutureRewardsProgram": {
          "ethosFutureRewardsProgram": {
            "mainnet": {
              "address": "0xf92e92030f2701df",
              "contract": "ethosFutureRewardsProgram",
              "fq_address": "A.0xf92e92030f2701df.ethosFutureRewardsProgram",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47499267
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499269
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499273
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "dd1796bbefb78160f629bcfe1e8de158de47e71894660674e74426decfa34e0b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "dd1796bbefb78160f629bcfe1e8de158de47e71894660674e74426decfa34e0b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a athlete_studio NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: athlete_studio\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500147
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "59bdcbb4fa670babbf743a6ef720be469aa5907053eb01f670e53ffeaa4018a9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "59bdcbb4fa670babbf743a6ef720be469aa5907053eb01f670e53ffeaa4018a9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a athlete_studio NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import AthleteStudio from 0xAthleteStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: athlete_studio\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AthleteStudio.Collection>(from: /storage/AthleteStudio_Collection) == nil {\n            let collection <- AthleteStudio.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AthleteStudio_Collection)\n        }\n        if (acct.getCapability<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AthleteStudio_Collection).borrow() == nil) {\n            acct.unlink(/public/AthleteStudio_Collection)\n            acct.link<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AthleteStudio_Collection, target: /storage/AthleteStudio_Collection)\n        }\n\n        if (acct.getCapability<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AthleteStudio_Collection).borrow() == nil) {\n            acct.unlink(/private/AthleteStudio_Collection)\n            acct.link<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AthleteStudio_Collection, target: /storage/AthleteStudio_Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/AthleteStudio_Collection)!\n        let collectionRef = acct\n            .getCapability(/public/AthleteStudio_Collection)\n            .borrow<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@AthleteStudio.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xAthleteStudio": {
          "AthleteStudio": {
            "mainnet": {
              "address": "0x27ece19eff91bab0",
              "contract": "AthleteStudio",
              "fq_address": "A.0x27ece19eff91bab0.AthleteStudio",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47500107
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500109
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500113
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47500114
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500114
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500119
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "f59ef123fb78d6ade268eaddd4a5dc8808e8cc573a89f215232c9d10e138624a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f59ef123fb78d6ade268eaddd4a5dc8808e8cc573a89f215232c9d10e138624a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed athlete_studio NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import AthleteStudio from 0xAthleteStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: athlete_studio\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AthleteStudio.Collection>(from: /storage/AthleteStudio_Collection) == nil {\n            let collection <- AthleteStudio.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AthleteStudio_Collection)\n            }\n        if (acct.getCapability<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AthleteStudio_Collection).borrow() == nil) {\n            acct.unlink(/public/AthleteStudio_Collection)\n            acct.link<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AthleteStudio_Collection, target: /storage/AthleteStudio_Collection)\n        }\n\n        if (acct.getCapability<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AthleteStudio_Collection).borrow() == nil) {\n            acct.unlink(/private/AthleteStudio_Collection)\n            acct.link<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AthleteStudio_Collection, target: /storage/AthleteStudio_Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/AthleteStudio_Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xAthleteStudio": {
          "AthleteStudio": {
            "mainnet": {
              "address": "0x27ece19eff91bab0",
              "contract": "AthleteStudio",
              "fq_address": "A.0x27ece19eff91bab0.AthleteStudio",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47500128
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500133
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500135
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47500136
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500137
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500141
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "88cf4bcdb005e1283964d8bd300163268c65056053e99b51d651de4afb77205b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "88cf4bcdb005e1283964d8bd300163268c65056053e99b51d651de4afb77205b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support athlete_studio NFTs"
          }
        }
      },
      "cadence": "import AthleteStudio from 0xAthleteStudio\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: athlete_studio\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&AthleteStudio.Collection>(from: /storage/AthleteStudio_Collection) == nil {\n      let collection <- AthleteStudio.createEmptyCollection()\n      signer.save(<-collection, to: /storage/AthleteStudio_Collection)\n    }\n    if (signer.getCapability<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AthleteStudio_Collection).borrow() == nil) {\n      signer.unlink(/public/AthleteStudio_Collection)\n      signer.link<&AthleteStudio.Collection{AthleteStudio.AthleteStudioCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AthleteStudio_Collection, target: /storage/AthleteStudio_Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xAthleteStudio": {
          "AthleteStudio": {
            "mainnet": {
              "address": "0x27ece19eff91bab0",
              "contract": "AthleteStudio",
              "fq_address": "A.0x27ece19eff91bab0.AthleteStudio",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47500088
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500093
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500097
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "9cd560c81d20b787982f8c4ae5777787aceaf5ca82b3c86f8cae32e5240dfe3a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9cd560c81d20b787982f8c4ae5777787aceaf5ca82b3c86f8cae32e5240dfe3a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Zeedz NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Zeedz\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488269
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783613
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ceee11a51c6f212de060d33f01a5daf2e602cb4467d411a61a5f2b54e956fc9b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ceee11a51c6f212de060d33f01a5daf2e602cb4467d411a61a5f2b54e956fc9b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Zeedz NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import ZeedzINO from 0xZeedzINO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Zeedz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ZeedzINO.Collection>(from: /storage/ZeedzINOCollection) == nil {\n            let collection <- ZeedzINO.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ZeedzINOCollection)\n        }\n        if (acct.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection).borrow() == nil) {\n            acct.unlink(/public/ZeedzINOCollection)\n            acct.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n        }\n\n        if (acct.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ZeedzINOCollection).borrow() == nil) {\n            acct.unlink(/private/ZeedzINOCollection)\n            acct.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/ZeedzINOCollection)!\n        let collectionRef = acct\n            .getCapability(/public/ZeedzINOCollection)\n            .borrow<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@ZeedzINO.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xZeedzINO": {
          "ZeedzINO": {
            "mainnet": {
              "address": "0x62b3063fbe672fc8",
              "contract": "ZeedzINO",
              "fq_address": "A.0x62b3063fbe672fc8.ZeedzINO",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488188
            },
            "testnet": {
              "address": "0x7dc7430a06f38af3",
              "contract": "ZeedzINO",
              "fq_address": "A.0x7dc7430a06f38af3.ZeedzINO",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95783520
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488199
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783527
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488205
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783537
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488212
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95783540
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488213
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783542
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488218
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783551
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "ceb2cf878357f959d431ff65ec865615c248a0234cc05ed8f8d0ddc8b02e5bf9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ceb2cf878357f959d431ff65ec865615c248a0234cc05ed8f8d0ddc8b02e5bf9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Zeedz NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import ZeedzINO from 0xZeedzINO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Zeedz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ZeedzINO.Collection>(from: /storage/ZeedzINOCollection) == nil {\n            let collection <- ZeedzINO.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ZeedzINOCollection)\n            }\n        if (acct.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection).borrow() == nil) {\n            acct.unlink(/public/ZeedzINOCollection)\n            acct.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n        }\n\n        if (acct.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ZeedzINOCollection).borrow() == nil) {\n            acct.unlink(/private/ZeedzINOCollection)\n            acct.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/ZeedzINOCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xZeedzINO": {
          "ZeedzINO": {
            "mainnet": {
              "address": "0x62b3063fbe672fc8",
              "contract": "ZeedzINO",
              "fq_address": "A.0x62b3063fbe672fc8.ZeedzINO",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488231
            },
            "testnet": {
              "address": "0x7dc7430a06f38af3",
              "contract": "ZeedzINO",
              "fq_address": "A.0x7dc7430a06f38af3.ZeedzINO",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95783571
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488241
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783579
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488248
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783589
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488253
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95783592
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488256
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783593
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488259
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783602
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "18af890564d0dcae2d5087da6a7f7fa454c5cc2990fdb2f7c610c6d52aca188c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "18af890564d0dcae2d5087da6a7f7fa454c5cc2990fdb2f7c610c6d52aca188c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Zeedz NFTs"
          }
        }
      },
      "cadence": "import ZeedzINO from 0xZeedzINO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Zeedz\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&ZeedzINO.Collection>(from: /storage/ZeedzINOCollection) == nil {\n      let collection <- ZeedzINO.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ZeedzINOCollection)\n    }\n    if (signer.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection).borrow() == nil) {\n      signer.unlink(/public/ZeedzINOCollection)\n      signer.link<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ZeedzINOCollection, target: /storage/ZeedzINOCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xZeedzINO": {
          "ZeedzINO": {
            "mainnet": {
              "address": "0x62b3063fbe672fc8",
              "contract": "ZeedzINO",
              "fq_address": "A.0x62b3063fbe672fc8.ZeedzINO",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488159
            },
            "testnet": {
              "address": "0x7dc7430a06f38af3",
              "contract": "ZeedzINO",
              "fq_address": "A.0x7dc7430a06f38af3.ZeedzINO",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95783483
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488170
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783490
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488177
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783501
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "6209744f966a5de9df72ad42b089894288d32e04648229f8bff603b8fddb6398": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6209744f966a5de9df72ad42b089894288d32e04648229f8bff603b8fddb6398",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a YahooPartners NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: YahooPartners\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513288
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "271c4a9a81b23c4775a28ae02467afb187ebc25eed2fb30822ac2c9392db1374": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "271c4a9a81b23c4775a28ae02467afb187ebc25eed2fb30822ac2c9392db1374",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a YahooPartners NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import YahooPartnersCollectible from 0xYahooPartnersCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: YahooPartners\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&YahooPartnersCollectible.Collection>(from: /storage/yahooPartnersCollectibleCollection) == nil {\n            let collection <- YahooPartnersCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/yahooPartnersCollectibleCollection)\n        }\n        if (acct.getCapability<&YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooPartnersCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/yahooPartnersCollectibleCollection)\n            acct.link<&YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooPartnersCollectibleCollection, target: /storage/yahooPartnersCollectibleCollection)\n        }\n\n        if (acct.getCapability<&YahooPartnersCollectible.Collection>(/private/yahooPartnersCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/yahooPartnersCollectibleCollection)\n            acct.link<&YahooPartnersCollectible.Collection>(/private/yahooPartnersCollectibleCollection, target: /storage/yahooPartnersCollectibleCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/yahooPartnersCollectibleCollection)!\n        let collectionRef = acct\n            .getCapability(/public/yahooPartnersCollectibleCollection)\n            .borrow<&YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@YahooPartnersCollectible.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xYahooPartnersCollectible": {
          "YahooPartnersCollectible": {
            "mainnet": {
              "address": "0x758252ab932a3416",
              "contract": "YahooPartnersCollectible",
              "fq_address": "A.0x758252ab932a3416.YahooPartnersCollectible",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47513249
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513252
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513255
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47513257
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513257
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513261
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "98700f9be7ac8fb6908126ab4911de4c5a185d1761fb5b7ad02b3b43533f93a3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "98700f9be7ac8fb6908126ab4911de4c5a185d1761fb5b7ad02b3b43533f93a3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed YahooPartners NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import YahooPartnersCollectible from 0xYahooPartnersCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: YahooPartners\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&YahooPartnersCollectible.Collection>(from: /storage/yahooPartnersCollectibleCollection) == nil {\n            let collection <- YahooPartnersCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/yahooPartnersCollectibleCollection)\n            }\n        if (acct.getCapability<&YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooPartnersCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/yahooPartnersCollectibleCollection)\n            acct.link<&YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooPartnersCollectibleCollection, target: /storage/yahooPartnersCollectibleCollection)\n        }\n\n        if (acct.getCapability<&YahooPartnersCollectible.Collection>(/private/yahooPartnersCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/yahooPartnersCollectibleCollection)\n            acct.link<&YahooPartnersCollectible.Collection>(/private/yahooPartnersCollectibleCollection, target: /storage/yahooPartnersCollectibleCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/yahooPartnersCollectibleCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xYahooPartnersCollectible": {
          "YahooPartnersCollectible": {
            "mainnet": {
              "address": "0x758252ab932a3416",
              "contract": "YahooPartnersCollectible",
              "fq_address": "A.0x758252ab932a3416.YahooPartnersCollectible",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47513270
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513272
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513276
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47513277
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513277
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513281
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "3045033d555764899da3efb4ec4a71c688bb07178e84357ba5dfc1326839dfa0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3045033d555764899da3efb4ec4a71c688bb07178e84357ba5dfc1326839dfa0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support YahooPartners NFTs"
          }
        }
      },
      "cadence": "import YahooPartnersCollectible from 0xYahooPartnersCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: YahooPartners\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&YahooPartnersCollectible.Collection>(from: /storage/yahooPartnersCollectibleCollection) == nil {\n      let collection <- YahooPartnersCollectible.createEmptyCollection()\n      signer.save(<-collection, to: /storage/yahooPartnersCollectibleCollection)\n    }\n    if (signer.getCapability<&YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooPartnersCollectibleCollection).borrow() == nil) {\n      signer.unlink(/public/yahooPartnersCollectibleCollection)\n      signer.link<&YahooPartnersCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooPartnersCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooPartnersCollectibleCollection, target: /storage/yahooPartnersCollectibleCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xYahooPartnersCollectible": {
          "YahooPartnersCollectible": {
            "mainnet": {
              "address": "0x758252ab932a3416",
              "contract": "YahooPartnersCollectible",
              "fq_address": "A.0x758252ab932a3416.YahooPartnersCollectible",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47513232
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513234
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513239
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "60a0d74887a03816991115c7d90be4415b7fe0864715a488d979ffb6f6ca1bb1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "60a0d74887a03816991115c7d90be4415b7fe0864715a488d979ffb6f6ca1bb1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a YBees NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: YBees\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501316
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799086
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "07e5987088265b06ede573ef122d82c8f5505df331b8690f8fc5c7f3f23fd5f0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "07e5987088265b06ede573ef122d82c8f5505df331b8690f8fc5c7f3f23fd5f0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Yahoo NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Yahoo\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47494659
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "5609c758577451fe2abfd002699a2dbf282ac938eb589fe38d897907c4c7cbff": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5609c758577451fe2abfd002699a2dbf282ac938eb589fe38d897907c4c7cbff",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Yahoo NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import YahooCollectible from 0xYahooCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Yahoo\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&YahooCollectible.Collection>(from: /storage/yahooCollectibleCollection) == nil {\n            let collection <- YahooCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/yahooCollectibleCollection)\n        }\n        if (acct.getCapability<&YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/yahooCollectibleCollection)\n            acct.link<&YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooCollectibleCollection, target: /storage/yahooCollectibleCollection)\n        }\n\n        if (acct.getCapability<&YahooCollectible.Collection>(/private/yahooCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/yahooCollectibleCollection)\n            acct.link<&YahooCollectible.Collection>(/private/yahooCollectibleCollection, target: /storage/yahooCollectibleCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/yahooCollectibleCollection)!\n        let collectionRef = acct\n            .getCapability(/public/yahooCollectibleCollection)\n            .borrow<&YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@YahooCollectible.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xYahooCollectible": {
          "YahooCollectible": {
            "mainnet": {
              "address": "0x758252ab932a3416",
              "contract": "YahooCollectible",
              "fq_address": "A.0x758252ab932a3416.YahooCollectible",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47494616
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47494620
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47494627
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47494627
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47494627
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47494631
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "a47b4039aeed80db07d092ca5fe315b6f4d7f9485e87afc5c5739b9c067113e9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a47b4039aeed80db07d092ca5fe315b6f4d7f9485e87afc5c5739b9c067113e9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Yahoo NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import YahooCollectible from 0xYahooCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Yahoo\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&YahooCollectible.Collection>(from: /storage/yahooCollectibleCollection) == nil {\n            let collection <- YahooCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/yahooCollectibleCollection)\n            }\n        if (acct.getCapability<&YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/yahooCollectibleCollection)\n            acct.link<&YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooCollectibleCollection, target: /storage/yahooCollectibleCollection)\n        }\n\n        if (acct.getCapability<&YahooCollectible.Collection>(/private/yahooCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/yahooCollectibleCollection)\n            acct.link<&YahooCollectible.Collection>(/private/yahooCollectibleCollection, target: /storage/yahooCollectibleCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/yahooCollectibleCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xYahooCollectible": {
          "YahooCollectible": {
            "mainnet": {
              "address": "0x758252ab932a3416",
              "contract": "YahooCollectible",
              "fq_address": "A.0x758252ab932a3416.YahooCollectible",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47494640
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47494643
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47494648
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47494648
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47494650
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47494655
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "2aba84fbdd1756c0d3dc6d7d9e774a85925e8c7062d61d38fe23c42f05000efe": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2aba84fbdd1756c0d3dc6d7d9e774a85925e8c7062d61d38fe23c42f05000efe",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Yahoo NFTs"
          }
        }
      },
      "cadence": "import YahooCollectible from 0xYahooCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Yahoo\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&YahooCollectible.Collection>(from: /storage/yahooCollectibleCollection) == nil {\n      let collection <- YahooCollectible.createEmptyCollection()\n      signer.save(<-collection, to: /storage/yahooCollectibleCollection)\n    }\n    if (signer.getCapability<&YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooCollectibleCollection).borrow() == nil) {\n      signer.unlink(/public/yahooCollectibleCollection)\n      signer.link<&YahooCollectible.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,YahooCollectible.CollectionPublic,MetadataViews.ResolverCollection}>(/public/yahooCollectibleCollection, target: /storage/yahooCollectibleCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xYahooCollectible": {
          "YahooCollectible": {
            "mainnet": {
              "address": "0x758252ab932a3416",
              "contract": "YahooCollectible",
              "fq_address": "A.0x758252ab932a3416.YahooCollectible",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47494593
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47494601
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47494604
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "63d475b19d2c3c3587cff972cbdad824597fa4eef928b01613b2c6fbec76ecd2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "63d475b19d2c3c3587cff972cbdad824597fa4eef928b01613b2c6fbec76ecd2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Wearables NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Wearables\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506704
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805497
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "86c6e89af5d5faf7d28a4bee9a574e3b0732130567e54ffc172652741f6ee142": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "86c6e89af5d5faf7d28a4bee9a574e3b0732130567e54ffc172652741f6ee142",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Wearables NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Wearables from 0xWearables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Wearables\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Wearables.Collection>(from: /storage/wearables) == nil {\n            let collection <- Wearables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/wearables)\n        }\n        if (acct.getCapability<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables).borrow() == nil) {\n            acct.unlink(/public/wearables)\n            acct.link<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables, target: /storage/wearables)\n        }\n\n        if (acct.getCapability<&Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/wearables).borrow() == nil) {\n            acct.unlink(/private/wearables)\n            acct.link<&Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/wearables, target: /storage/wearables)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/wearables)!\n        let collectionRef = acct\n            .getCapability(/public/wearables)\n            .borrow<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Wearables.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xWearables": {
          "Wearables": {
            "mainnet": {
              "address": "0xe81193c424cfd3fb",
              "contract": "Wearables",
              "fq_address": "A.0xe81193c424cfd3fb.Wearables",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47506611
            },
            "testnet": {
              "address": "0x1e0493ee604e7598",
              "contract": "Wearables",
              "fq_address": "A.0x1e0493ee604e7598.Wearables",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95805393
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506626
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805400
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506632
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805410
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506637
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95805412
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506639
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805414
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506643
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805423
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "9d6482979b33b4b1b524847d139dd9ce1d7dc61043aa4de2360f55bdddfc1120": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9d6482979b33b4b1b524847d139dd9ce1d7dc61043aa4de2360f55bdddfc1120",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Wearables NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Wearables from 0xWearables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Wearables\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Wearables.Collection>(from: /storage/wearables) == nil {\n            let collection <- Wearables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/wearables)\n            }\n        if (acct.getCapability<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables).borrow() == nil) {\n            acct.unlink(/public/wearables)\n            acct.link<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables, target: /storage/wearables)\n        }\n\n        if (acct.getCapability<&Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/wearables).borrow() == nil) {\n            acct.unlink(/private/wearables)\n            acct.link<&Wearables.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/wearables, target: /storage/wearables)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/wearables\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xWearables": {
          "Wearables": {
            "mainnet": {
              "address": "0xe81193c424cfd3fb",
              "contract": "Wearables",
              "fq_address": "A.0xe81193c424cfd3fb.Wearables",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47506662
            },
            "testnet": {
              "address": "0x1e0493ee604e7598",
              "contract": "Wearables",
              "fq_address": "A.0x1e0493ee604e7598.Wearables",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95805457
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506679
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805464
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506686
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805474
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506690
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95805476
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506691
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805477
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506696
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805487
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "212dff0efe8241c2eb0e2e1e883dbc0507f4fe2e83d4586fb1c947ae7d9a1301": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "212dff0efe8241c2eb0e2e1e883dbc0507f4fe2e83d4586fb1c947ae7d9a1301",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Wearables NFTs"
          }
        }
      },
      "cadence": "import Wearables from 0xWearables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Wearables\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Wearables.Collection>(from: /storage/wearables) == nil {\n      let collection <- Wearables.createEmptyCollection()\n      signer.save(<-collection, to: /storage/wearables)\n    }\n    if (signer.getCapability<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables).borrow() == nil) {\n      signer.unlink(/public/wearables)\n      signer.link<&Wearables.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/wearables, target: /storage/wearables)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xWearables": {
          "Wearables": {
            "mainnet": {
              "address": "0xe81193c424cfd3fb",
              "contract": "Wearables",
              "fq_address": "A.0xe81193c424cfd3fb.Wearables",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47506569
            },
            "testnet": {
              "address": "0x1e0493ee604e7598",
              "contract": "Wearables",
              "fq_address": "A.0x1e0493ee604e7598.Wearables",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95805342
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506586
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805349
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506593
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805359
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "2cf1659511fc7df239162b730cd027066a347a57414621b8bc24d06355b6bbd6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2cf1659511fc7df239162b730cd027066a347a57414621b8bc24d06355b6bbd6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a XvsXNFTCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: XvsXNFTCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510469
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809942
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "21d0281906b6a124bddd4d48d71e5a8ebd2fee4b2d7c0da4d6cfbeedc7e28cf9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "21d0281906b6a124bddd4d48d71e5a8ebd2fee4b2d7c0da4d6cfbeedc7e28cf9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a XvsXNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import XvsX from 0xXvsX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: XvsXNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&XvsX.Collection>(from: /storage/XvsXCollection) == nil {\n            let collection <- XvsX.createEmptyCollection()\n            acct.save(<-collection, to: /storage/XvsXCollection)\n        }\n        if (acct.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection).borrow() == nil) {\n            acct.unlink(/public/XvsXCollection)\n            acct.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection, target: /storage/XvsXCollection)\n        }\n\n        if (acct.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XvsXCollection).borrow() == nil) {\n            acct.unlink(/private/XvsXCollection)\n            acct.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XvsXCollection, target: /storage/XvsXCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/XvsXCollection)!\n        let collectionRef = acct\n            .getCapability(/public/XvsXCollection)\n            .borrow<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@XvsX.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xXvsX": {
          "XvsX": {
            "mainnet": {
              "address": "0xf2af175e411dfff8",
              "contract": "XvsX",
              "fq_address": "A.0xf2af175e411dfff8.XvsX",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510388
            },
            "testnet": {
              "address": "0x26e7006d6734ba69",
              "contract": "XvsX",
              "fq_address": "A.0x26e7006d6734ba69.XvsX",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809852
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510400
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809859
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510408
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809868
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47510413
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95809871
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510413
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809872
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510419
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809882
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "fbbc6c28612285ef78aaaa79b997fd038e37e04b1b45fbfe4eee1b24870a3303": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fbbc6c28612285ef78aaaa79b997fd038e37e04b1b45fbfe4eee1b24870a3303",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed XvsXNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import XvsX from 0xXvsX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: XvsXNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&XvsX.Collection>(from: /storage/XvsXCollection) == nil {\n            let collection <- XvsX.createEmptyCollection()\n            acct.save(<-collection, to: /storage/XvsXCollection)\n            }\n        if (acct.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection).borrow() == nil) {\n            acct.unlink(/public/XvsXCollection)\n            acct.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection, target: /storage/XvsXCollection)\n        }\n\n        if (acct.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XvsXCollection).borrow() == nil) {\n            acct.unlink(/private/XvsXCollection)\n            acct.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/XvsXCollection, target: /storage/XvsXCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/XvsXCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xXvsX": {
          "XvsX": {
            "mainnet": {
              "address": "0xf2af175e411dfff8",
              "contract": "XvsX",
              "fq_address": "A.0xf2af175e411dfff8.XvsX",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510431
            },
            "testnet": {
              "address": "0x26e7006d6734ba69",
              "contract": "XvsX",
              "fq_address": "A.0x26e7006d6734ba69.XvsX",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809902
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510442
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809909
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510449
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809919
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47510454
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95809921
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510455
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809922
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510460
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809932
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "b059047838952bddd071093c0c2623e15df86b198a1415b2eba1fd8b232d8eb1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b059047838952bddd071093c0c2623e15df86b198a1415b2eba1fd8b232d8eb1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support XvsXNFTCollection NFTs"
          }
        }
      },
      "cadence": "import XvsX from 0xXvsX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: XvsXNFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&XvsX.Collection>(from: /storage/XvsXCollection) == nil {\n      let collection <- XvsX.createEmptyCollection()\n      signer.save(<-collection, to: /storage/XvsXCollection)\n    }\n    if (signer.getCapability<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection).borrow() == nil) {\n      signer.unlink(/public/XvsXCollection)\n      signer.link<&XvsX.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/XvsXCollection, target: /storage/XvsXCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xXvsX": {
          "XvsX": {
            "mainnet": {
              "address": "0xf2af175e411dfff8",
              "contract": "XvsX",
              "fq_address": "A.0xf2af175e411dfff8.XvsX",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510358
            },
            "testnet": {
              "address": "0x26e7006d6734ba69",
              "contract": "XvsX",
              "fq_address": "A.0x26e7006d6734ba69.XvsX",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809815
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510368
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809822
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510374
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809832
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "db6d2936b1229d2be9a75de373e71c109217682c62f3741baa45f642381b5721": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "db6d2936b1229d2be9a75de373e71c109217682c62f3741baa45f642381b5721",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Versus NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Versus\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506554
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "5e557abd4af5833265313e59557ac6ec1627cc197a95598417e2af89f6f60c31": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5e557abd4af5833265313e59557ac6ec1627cc197a95598417e2af89f6f60c31",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Versus NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Art from 0xArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Versus\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Art.Collection>(from: /storage/versusArtCollection) == nil {\n            let collection <- Art.createEmptyCollection()\n            acct.save(<-collection, to: /storage/versusArtCollection)\n        }\n        if (acct.getCapability<&Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/public/versusArtCollection).borrow() == nil) {\n            acct.unlink(/public/versusArtCollection)\n            acct.link<&Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/public/versusArtCollection, target: /storage/versusArtCollection)\n        }\n\n        if (acct.getCapability<&Art.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/private/versusArtCollection).borrow() == nil) {\n            acct.unlink(/private/versusArtCollection)\n            acct.link<&Art.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/private/versusArtCollection, target: /storage/versusArtCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/versusArtCollection)!\n        let collectionRef = acct\n            .getCapability(/public/versusArtCollection)\n            .borrow<&Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Art.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xArt": {
          "Art": {
            "mainnet": {
              "address": "0xd796ff17107bbff6",
              "contract": "Art",
              "fq_address": "A.0xd796ff17107bbff6.Art",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47506512
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506516
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506521
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506521
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506521
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506526
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "d8d758209add2d707442cfa2c58a4d244f718d123b4e34375f331a3d91f60a1b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d8d758209add2d707442cfa2c58a4d244f718d123b4e34375f331a3d91f60a1b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Versus NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Art from 0xArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Versus\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Art.Collection>(from: /storage/versusArtCollection) == nil {\n            let collection <- Art.createEmptyCollection()\n            acct.save(<-collection, to: /storage/versusArtCollection)\n            }\n        if (acct.getCapability<&Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/public/versusArtCollection).borrow() == nil) {\n            acct.unlink(/public/versusArtCollection)\n            acct.link<&Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/public/versusArtCollection, target: /storage/versusArtCollection)\n        }\n\n        if (acct.getCapability<&Art.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/private/versusArtCollection).borrow() == nil) {\n            acct.unlink(/private/versusArtCollection)\n            acct.link<&Art.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/private/versusArtCollection, target: /storage/versusArtCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(\n            from: /storage/versusArtCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xArt": {
          "Art": {
            "mainnet": {
              "address": "0xd796ff17107bbff6",
              "contract": "Art",
              "fq_address": "A.0xd796ff17107bbff6.Art",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47506537
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506540
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506543
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506544
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506546
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506549
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "a13f43c67bf8f67ba8fce69f06be0fb94016c80c23b6a82c83cad9ca366adb05": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a13f43c67bf8f67ba8fce69f06be0fb94016c80c23b6a82c83cad9ca366adb05",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Versus NFTs"
          }
        }
      },
      "cadence": "import Art from 0xArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Versus\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Art.Collection>(from: /storage/versusArtCollection) == nil {\n      let collection <- Art.createEmptyCollection()\n      signer.save(<-collection, to: /storage/versusArtCollection)\n    }\n    if (signer.getCapability<&Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/public/versusArtCollection).borrow() == nil) {\n      signer.unlink(/public/versusArtCollection)\n      signer.link<&Art.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Art.CollectionPublic}>(/public/versusArtCollection, target: /storage/versusArtCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xArt": {
          "Art": {
            "mainnet": {
              "address": "0xd796ff17107bbff6",
              "contract": "Art",
              "fq_address": "A.0xd796ff17107bbff6.Art",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47506494
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506498
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506501
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "f2b953f245e38e784e7962af71b9b2571f489de26b28ec0e518abb2da8f95ac7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f2b953f245e38e784e7962af71b9b2571f489de26b28ec0e518abb2da8f95ac7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a UFCStrike NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: UFCStrike\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512505
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95812348
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "b82d49985e7795664d2305c62bf4494366c2ae63c605429ea0a2c73f759e4d5e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b82d49985e7795664d2305c62bf4494366c2ae63c605429ea0a2c73f759e4d5e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a UFCStrike NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import ufcInt_NFT from 0xufcInt_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: UFCStrike\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ufcInt_NFT.Collection>(from: /storage/ufcInt_NFTCollection) == nil {\n            let collection <- ufcInt_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ufcInt_NFTCollection)\n        }\n        if (acct.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/ufcInt_NFTCollection)\n            acct.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection, target: /storage/ufcInt_NFTCollection)\n        }\n\n        if (acct.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/ufcInt_NFT).borrow() == nil) {\n            acct.unlink(/private/ufcInt_NFT)\n            acct.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/ufcInt_NFT, target: /storage/ufcInt_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/ufcInt_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/ufcInt_NFTCollection)\n            .borrow<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@ufcInt_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95812267
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95812272
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95812273
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95812274
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95812278
            }
          }
        },
        "0xufcInt_NFT": {
          "ufcInt_NFT": {
            "testnet": {
              "address": "0x04625c28593d9408",
              "contract": "ufcInt_NFT",
              "fq_address": "A.0x04625c28593d9408.ufcInt_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95812287
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "4913493fcc68eaeb9bdf7238eaf0c2163d6feccdf445303d79e857ca92a46256": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4913493fcc68eaeb9bdf7238eaf0c2163d6feccdf445303d79e857ca92a46256",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a UFCStrike NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import UFC_NFT from 0xUFC_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: UFCStrike\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&UFC_NFT.Collection>(from: /storage/UFC_NFTCollection) == nil {\n            let collection <- UFC_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/UFC_NFTCollection)\n        }\n        if (acct.getCapability<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/UFC_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/UFC_NFTCollection)\n            acct.link<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/UFC_NFTCollection, target: /storage/UFC_NFTCollection)\n        }\n\n        if (acct.getCapability<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/UFC_NFT).borrow() == nil) {\n            acct.unlink(/private/UFC_NFT)\n            acct.link<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/UFC_NFT, target: /storage/UFC_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/UFC_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/UFC_NFTCollection)\n            .borrow<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@UFC_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xUFC_NFT": {
          "UFC_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "UFC_NFT",
              "fq_address": "A.0x329feb3ab062d289.UFC_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47512423
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512426
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512431
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512433
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512433
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512438
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "635655ad42e7a9dc831752febb8400d3d17fd4fa79b5cac08a86a424209f7c3d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "635655ad42e7a9dc831752febb8400d3d17fd4fa79b5cac08a86a424209f7c3d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed UFCStrike NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import ufcInt_NFT from 0xufcInt_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: UFCStrike\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ufcInt_NFT.Collection>(from: /storage/ufcInt_NFTCollection) == nil {\n            let collection <- ufcInt_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ufcInt_NFTCollection)\n            }\n        if (acct.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/ufcInt_NFTCollection)\n            acct.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection, target: /storage/ufcInt_NFTCollection)\n        }\n\n        if (acct.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/ufcInt_NFT).borrow() == nil) {\n            acct.unlink(/private/ufcInt_NFT)\n            acct.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/ufcInt_NFT, target: /storage/ufcInt_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/ufcInt_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95812317
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95812322
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95812323
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95812324
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95812329
            }
          }
        },
        "0xufcInt_NFT": {
          "ufcInt_NFT": {
            "testnet": {
              "address": "0x04625c28593d9408",
              "contract": "ufcInt_NFT",
              "fq_address": "A.0x04625c28593d9408.ufcInt_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95812339
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "4d1a9d16ddb0581dda53e1c06ce4868b5f14dbe57ad1234e6004e097c756c5d9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4d1a9d16ddb0581dda53e1c06ce4868b5f14dbe57ad1234e6004e097c756c5d9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed UFCStrike NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import UFC_NFT from 0xUFC_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: UFCStrike\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&UFC_NFT.Collection>(from: /storage/UFC_NFTCollection) == nil {\n            let collection <- UFC_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/UFC_NFTCollection)\n            }\n        if (acct.getCapability<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/UFC_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/UFC_NFTCollection)\n            acct.link<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/UFC_NFTCollection, target: /storage/UFC_NFTCollection)\n        }\n\n        if (acct.getCapability<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/UFC_NFT).borrow() == nil) {\n            acct.unlink(/private/UFC_NFT)\n            acct.link<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/UFC_NFT, target: /storage/UFC_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/UFC_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xUFC_NFT": {
          "UFC_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "UFC_NFT",
              "fq_address": "A.0x329feb3ab062d289.UFC_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47512467
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512471
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512476
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512477
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512477
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512481
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "7bcb598deb6ac80302544c5a7bc9fe2aeeec5f2854438e263affbc426c9161ba": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7bcb598deb6ac80302544c5a7bc9fe2aeeec5f2854438e263affbc426c9161ba",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's collection to support a UFCStrike NFT"
          }
        }
      },
      "cadence": "import ufcInt_NFT from 0xufcInt_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: UFCStrike\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&ufcInt_NFT.Collection>(from: /storage/ufcInt_NFTCollection) == nil {\n      let collection <- ufcInt_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ufcInt_NFTCollection)\n    }\n    if (signer.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/ufcInt_NFTCollection)\n      signer.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection, target: /storage/ufcInt_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95782192
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95782197
            }
          }
        },
        "0xufcInt_NFT": {
          "ufcInt_NFT": {
            "testnet": {
              "address": "0x04625c28593d9408",
              "contract": "ufcInt_NFT",
              "fq_address": "A.0x04625c28593d9408.ufcInt_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95782208
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "779341ebe200e360a225a1c6b067c072c90e6d4cd981d6e332b2062dacc0ff16": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "779341ebe200e360a225a1c6b067c072c90e6d4cd981d6e332b2062dacc0ff16",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's collection to support a UFCStrike NFT"
          }
        }
      },
      "cadence": "import ufcInt_NFT from 0xufcInt_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: UFCStrike\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&ufcInt_NFT.Collection>(from: /storage/ufcInt_NFTCollection) == nil {\n      let collection <- ufcInt_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ufcInt_NFTCollection)\n    }\n    if (signer.getCapability<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/ufcInt_NFTCollection)\n      signer.link<&ufcInt_NFT.Collection{ufcInt_NFT.ufcInt_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ufcInt_NFTCollection, target: /storage/ufcInt_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xUFC_NFT": {
          "UFC_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "UFC_NFT",
              "fq_address": "A.0x329feb3ab062d289.UFC_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47487061
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47487065
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487070
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "b6301af38fd9c9ff878cac206a3649aa97adb9d61040f1692f32b499d1b0af26": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b6301af38fd9c9ff878cac206a3649aa97adb9d61040f1692f32b499d1b0af26",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TuneGONFT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TuneGONFT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506255
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "cab5fa7df9d46ac5570cd563f08e648f42f93f3a67d81ff88e1abe2d60698575": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cab5fa7df9d46ac5570cd563f08e648f42f93f3a67d81ff88e1abe2d60698575",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TuneGONFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TuneGONFT from 0xTuneGONFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TuneGONFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TuneGONFT.Collection>(from: /storage/tunegoNFTCollection) == nil {\n            let collection <- TuneGONFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/tunegoNFTCollection)\n        }\n        if (acct.getCapability<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/tunegoNFTCollection).borrow() == nil) {\n            acct.unlink(/public/tunegoNFTCollection)\n            acct.link<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/tunegoNFTCollection, target: /storage/tunegoNFTCollection)\n        }\n\n        if (acct.getCapability<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/tunegoNFTCollection).borrow() == nil) {\n            acct.unlink(/private/tunegoNFTCollection)\n            acct.link<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/tunegoNFTCollection, target: /storage/tunegoNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/tunegoNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/tunegoNFTCollection)\n            .borrow<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TuneGONFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTuneGONFT": {
          "TuneGONFT": {
            "mainnet": {
              "address": "0xc6945445cdbefec9",
              "contract": "TuneGONFT",
              "fq_address": "A.0xc6945445cdbefec9.TuneGONFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506215
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506218
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506222
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506223
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506223
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506229
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "0642a2db5e801e9f90626c54c47f9a72cb8398933bd05ef530a810ada9a3eb46": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0642a2db5e801e9f90626c54c47f9a72cb8398933bd05ef530a810ada9a3eb46",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TuneGONFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TuneGONFT from 0xTuneGONFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TuneGONFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TuneGONFT.Collection>(from: /storage/tunegoNFTCollection) == nil {\n            let collection <- TuneGONFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/tunegoNFTCollection)\n            }\n        if (acct.getCapability<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/tunegoNFTCollection).borrow() == nil) {\n            acct.unlink(/public/tunegoNFTCollection)\n            acct.link<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/tunegoNFTCollection, target: /storage/tunegoNFTCollection)\n        }\n\n        if (acct.getCapability<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/tunegoNFTCollection).borrow() == nil) {\n            acct.unlink(/private/tunegoNFTCollection)\n            acct.link<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/tunegoNFTCollection, target: /storage/tunegoNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/tunegoNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTuneGONFT": {
          "TuneGONFT": {
            "mainnet": {
              "address": "0xc6945445cdbefec9",
              "contract": "TuneGONFT",
              "fq_address": "A.0xc6945445cdbefec9.TuneGONFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506237
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506241
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506245
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506245
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506246
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506249
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "c964c7346a284f74accd828710e33bd30dcce16fa2671c75524bda4b5b3890c0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c964c7346a284f74accd828710e33bd30dcce16fa2671c75524bda4b5b3890c0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TuneGONFT NFTs"
          }
        }
      },
      "cadence": "import TuneGONFT from 0xTuneGONFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TuneGONFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TuneGONFT.Collection>(from: /storage/tunegoNFTCollection) == nil {\n      let collection <- TuneGONFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/tunegoNFTCollection)\n    }\n    if (signer.getCapability<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/tunegoNFTCollection).borrow() == nil) {\n      signer.unlink(/public/tunegoNFTCollection)\n      signer.link<&TuneGONFT.Collection{TuneGONFT.TuneGONFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/tunegoNFTCollection, target: /storage/tunegoNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTuneGONFT": {
          "TuneGONFT": {
            "mainnet": {
              "address": "0xc6945445cdbefec9",
              "contract": "TuneGONFT",
              "fq_address": "A.0xc6945445cdbefec9.TuneGONFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506199
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506201
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506206
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "72d205c5ed91cb0cf7d23842a4519bc8b40e731ddc63dd33881e9a879344914d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "72d205c5ed91cb0cf7d23842a4519bc8b40e731ddc63dd33881e9a879344914d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TuneKitties NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TuneKitties\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506337
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "8f29348a1832d0984e085e8c175ebbb75a939a0b67c285860ba75ef5a939840f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8f29348a1832d0984e085e8c175ebbb75a939a0b67c285860ba75ef5a939840f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TuneKitties NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TuneGO from 0xTuneGO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TuneKitties\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TuneGO.Collection>(from: /storage/TuneGOCollection) == nil {\n            let collection <- TuneGO.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TuneGOCollection)\n        }\n        if (acct.getCapability<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TuneGOCollection).borrow() == nil) {\n            acct.unlink(/public/TuneGOCollection)\n            acct.link<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TuneGOCollection, target: /storage/TuneGOCollection)\n        }\n\n        if (acct.getCapability<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TuneGOCollection).borrow() == nil) {\n            acct.unlink(/private/TuneGOCollection)\n            acct.link<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TuneGOCollection, target: /storage/TuneGOCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TuneGOCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TuneGOCollection)\n            .borrow<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TuneGO.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTuneGO": {
          "TuneGO": {
            "mainnet": {
              "address": "0x0d9bc5af3fc0c2e3",
              "contract": "TuneGO",
              "fq_address": "A.0x0d9bc5af3fc0c2e3.TuneGO",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 47506291
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506294
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506297
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506298
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506299
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506303
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "e68c069faaddbe320440bc07d51dc094a731e75497fbfbd0a15b252fdec9cf87": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e68c069faaddbe320440bc07d51dc094a731e75497fbfbd0a15b252fdec9cf87",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TuneKitties NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TuneGO from 0xTuneGO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TuneKitties\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TuneGO.Collection>(from: /storage/TuneGOCollection) == nil {\n            let collection <- TuneGO.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TuneGOCollection)\n            }\n        if (acct.getCapability<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TuneGOCollection).borrow() == nil) {\n            acct.unlink(/public/TuneGOCollection)\n            acct.link<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TuneGOCollection, target: /storage/TuneGOCollection)\n        }\n\n        if (acct.getCapability<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TuneGOCollection).borrow() == nil) {\n            acct.unlink(/private/TuneGOCollection)\n            acct.link<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TuneGOCollection, target: /storage/TuneGOCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TuneGOCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTuneGO": {
          "TuneGO": {
            "mainnet": {
              "address": "0x0d9bc5af3fc0c2e3",
              "contract": "TuneGO",
              "fq_address": "A.0x0d9bc5af3fc0c2e3.TuneGO",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 47506319
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506323
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506326
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506327
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506327
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506332
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "a1376194745338db0a3f2cfd80e17af7ce7283eddeef04728ca4fbca6146d98f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a1376194745338db0a3f2cfd80e17af7ce7283eddeef04728ca4fbca6146d98f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TuneKitties NFTs"
          }
        }
      },
      "cadence": "import TuneGO from 0xTuneGO\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TuneKitties\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TuneGO.Collection>(from: /storage/TuneGOCollection) == nil {\n      let collection <- TuneGO.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TuneGOCollection)\n    }\n    if (signer.getCapability<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TuneGOCollection).borrow() == nil) {\n      signer.unlink(/public/TuneGOCollection)\n      signer.link<&TuneGO.Collection{TuneGO.TuneGOCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TuneGOCollection, target: /storage/TuneGOCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTuneGO": {
          "TuneGO": {
            "mainnet": {
              "address": "0x0d9bc5af3fc0c2e3",
              "contract": "TuneGO",
              "fq_address": "A.0x0d9bc5af3fc0c2e3.TuneGO",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 47506269
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506272
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506275
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "725ff336ccdfa0d66eff08cc3d86d52dc2d6637f08ae6fabfaccddb24baa3fcb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "725ff336ccdfa0d66eff08cc3d86d52dc2d6637f08ae6fabfaccddb24baa3fcb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Trart NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Trart\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512858
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "d4fd8aedc3c324b49c7dc983620c99b59d03b302236a0e20c5be6b27ae7ba408": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d4fd8aedc3c324b49c7dc983620c99b59d03b302236a0e20c5be6b27ae7ba408",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Trart NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TrartContractNFT from 0xTrartContractNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Trart\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TrartContractNFT.Collection>(from: /storage/TrartContractNFTCollection) == nil {\n            let collection <- TrartContractNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TrartContractNFTCollection)\n        }\n        if (acct.getCapability<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TrartContractNFTCollection).borrow() == nil) {\n            acct.unlink(/public/TrartContractNFTCollection)\n            acct.link<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TrartContractNFTCollection, target: /storage/TrartContractNFTCollection)\n        }\n\n        if (acct.getCapability<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TrartContractNFTCollection).borrow() == nil) {\n            acct.unlink(/private/TrartContractNFTCollection)\n            acct.link<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TrartContractNFTCollection, target: /storage/TrartContractNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TrartContractNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TrartContractNFTCollection)\n            .borrow<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TrartContractNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTrartContractNFT": {
          "TrartContractNFT": {
            "mainnet": {
              "address": "0x6f01a4b0046c1f87",
              "contract": "TrartContractNFT",
              "fq_address": "A.0x6f01a4b0046c1f87.TrartContractNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47512818
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512821
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512825
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512826
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512826
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512831
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "343c56550a974aba309f31fca98f4fc238ef624edcd68b80014a251732a8378c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "343c56550a974aba309f31fca98f4fc238ef624edcd68b80014a251732a8378c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Trart NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TrartContractNFT from 0xTrartContractNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Trart\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TrartContractNFT.Collection>(from: /storage/TrartContractNFTCollection) == nil {\n            let collection <- TrartContractNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TrartContractNFTCollection)\n            }\n        if (acct.getCapability<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TrartContractNFTCollection).borrow() == nil) {\n            acct.unlink(/public/TrartContractNFTCollection)\n            acct.link<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TrartContractNFTCollection, target: /storage/TrartContractNFTCollection)\n        }\n\n        if (acct.getCapability<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TrartContractNFTCollection).borrow() == nil) {\n            acct.unlink(/private/TrartContractNFTCollection)\n            acct.link<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TrartContractNFTCollection, target: /storage/TrartContractNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TrartContractNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTrartContractNFT": {
          "TrartContractNFT": {
            "mainnet": {
              "address": "0x6f01a4b0046c1f87",
              "contract": "TrartContractNFT",
              "fq_address": "A.0x6f01a4b0046c1f87.TrartContractNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47512840
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512842
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512848
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512849
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512849
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512853
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "eba5cd1894ae66490dcc4c8413ec645a2b74ac05dc0f81d6964d4a5c2c5a4b70": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "eba5cd1894ae66490dcc4c8413ec645a2b74ac05dc0f81d6964d4a5c2c5a4b70",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Trart NFTs"
          }
        }
      },
      "cadence": "import TrartContractNFT from 0xTrartContractNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Trart\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TrartContractNFT.Collection>(from: /storage/TrartContractNFTCollection) == nil {\n      let collection <- TrartContractNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TrartContractNFTCollection)\n    }\n    if (signer.getCapability<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TrartContractNFTCollection).borrow() == nil) {\n      signer.unlink(/public/TrartContractNFTCollection)\n      signer.link<&TrartContractNFT.Collection{TrartContractNFT.ICardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TrartContractNFTCollection, target: /storage/TrartContractNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTrartContractNFT": {
          "TrartContractNFT": {
            "mainnet": {
              "address": "0x6f01a4b0046c1f87",
              "contract": "TrartContractNFT",
              "fq_address": "A.0x6f01a4b0046c1f87.TrartContractNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47512801
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512803
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512808
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "18fe73f46c0c3aa64074ae8d73a3be984ee8be2a3dbeca3c5ae14a44bed1249b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "18fe73f46c0c3aa64074ae8d73a3be984ee8be2a3dbeca3c5ae14a44bed1249b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TouchstoneTheGritIron NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TouchstoneTheGritIron\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497225
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "79d590c3affbb5640524106deb6635ee10863ab4324de0fd9b1d6e41687100f3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "79d590c3affbb5640524106deb6635ee10863ab4324de0fd9b1d6e41687100f3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TouchstoneTheGritIron NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TouchstoneTheGritIron from 0xTouchstoneTheGritIron\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TouchstoneTheGritIron\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TouchstoneTheGritIron.Collection>(from: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3) == nil {\n            let collection <- TouchstoneTheGritIron.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n        }\n        if (acct.getCapability<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3).borrow() == nil) {\n            acct.unlink(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n            acct.link<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3, target: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n        }\n\n        if (acct.getCapability<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3).borrow() == nil) {\n            acct.unlink(/private/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n            acct.link<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3, target: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)!\n        let collectionRef = acct\n            .getCapability(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n            .borrow<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TouchstoneTheGritIron.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTouchstoneTheGritIron": {
          "TouchstoneTheGritIron": {
            "mainnet": {
              "address": "0x84e5586a3fae8ff3",
              "contract": "TouchstoneTheGritIron",
              "fq_address": "A.0x84e5586a3fae8ff3.TouchstoneTheGritIron",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47498874
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498877
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498882
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47498882
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498882
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498888
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "9271e9c7396cf32ff60a5e67d41983bf9b74fd0c73f73ad6a356679dfb87a48a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9271e9c7396cf32ff60a5e67d41983bf9b74fd0c73f73ad6a356679dfb87a48a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TouchstoneTheGritIron NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TouchstoneTheGritIron from 0xTouchstoneTheGritIron\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TouchstoneTheGritIron\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TouchstoneTheGritIron.Collection>(from: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3) == nil {\n            let collection <- TouchstoneTheGritIron.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n            }\n        if (acct.getCapability<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3).borrow() == nil) {\n            acct.unlink(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n            acct.link<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3, target: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n        }\n\n        if (acct.getCapability<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3).borrow() == nil) {\n            acct.unlink(/private/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n            acct.link<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3, target: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTouchstoneTheGritIron": {
          "TouchstoneTheGritIron": {
            "mainnet": {
              "address": "0x84e5586a3fae8ff3",
              "contract": "TouchstoneTheGritIron",
              "fq_address": "A.0x84e5586a3fae8ff3.TouchstoneTheGritIron",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47498927
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498929
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498933
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47498933
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498934
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498938
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "97834e40542219233567856e40b48d5a2a4de0810c5e5787eec325c4f245415f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "97834e40542219233567856e40b48d5a2a4de0810c5e5787eec325c4f245415f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TouchstoneTheGritIron NFTs"
          }
        }
      },
      "cadence": "import TouchstoneTheGritIron from 0xTouchstoneTheGritIron\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TouchstoneTheGritIron\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TouchstoneTheGritIron.Collection>(from: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3) == nil {\n      let collection <- TouchstoneTheGritIron.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n    }\n    if (signer.getCapability<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3).borrow() == nil) {\n      signer.unlink(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n      signer.link<&TouchstoneTheGritIron.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3, target: /storage/TouchstoneTheGritIronCollection_0x84e5586a3fae8ff3)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTouchstoneTheGritIron": {
          "TouchstoneTheGritIron": {
            "mainnet": {
              "address": "0x84e5586a3fae8ff3",
              "contract": "TouchstoneTheGritIron",
              "fq_address": "A.0x84e5586a3fae8ff3.TouchstoneTheGritIron",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47498828
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498831
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498836
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "5020c5d91487b058544ae5ed2a940fac3660162adc96dce2c3a58be7cdbdc224": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5020c5d91487b058544ae5ed2a940fac3660162adc96dce2c3a58be7cdbdc224",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TouchstoneProfessorMetasAcademyHackathon2023 NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TouchstoneProfessorMetasAcademyHackathon2023\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493110
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "a4d63ea5907f4aba6545b3e9e0126f992c0097845756e3ed80b0381063719a97": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a4d63ea5907f4aba6545b3e9e0126f992c0097845756e3ed80b0381063719a97",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TouchstoneProfessorMetasAcademyHackathon2023 NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TouchstoneProfessorMetasAcademyHackathon2023 from 0xTouchstoneProfessorMetasAcademyHackathon2023\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TouchstoneProfessorMetasAcademyHackathon2023\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TouchstoneProfessorMetasAcademyHackathon2023.Collection>(from: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26) == nil {\n            let collection <- TouchstoneProfessorMetasAcademyHackathon2023.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n        }\n        if (acct.getCapability<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26).borrow() == nil) {\n            acct.unlink(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n            acct.link<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26, target: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n        }\n\n        if (acct.getCapability<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26).borrow() == nil) {\n            acct.unlink(/private/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n            acct.link<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26, target: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)!\n        let collectionRef = acct\n            .getCapability(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n            .borrow<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TouchstoneProfessorMetasAcademyHackathon2023.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTouchstoneProfessorMetasAcademyHackathon2023": {
          "TouchstoneProfessorMetasAcademyHackathon2023": {
            "mainnet": {
              "address": "0xfcbe1e1ed18c5a26",
              "contract": "TouchstoneProfessorMetasAcademyHackathon2023",
              "fq_address": "A.0xfcbe1e1ed18c5a26.TouchstoneProfessorMetasAcademyHackathon2023",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47498476
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498478
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498483
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47498483
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498485
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498489
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "94a771832c786c5de9bbd0b013e16b739c2de79d7553ea3bb136cf7b120207df": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "94a771832c786c5de9bbd0b013e16b739c2de79d7553ea3bb136cf7b120207df",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TouchstoneProfessorMetasAcademyHackathon2023 NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TouchstoneProfessorMetasAcademyHackathon2023 from 0xTouchstoneProfessorMetasAcademyHackathon2023\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TouchstoneProfessorMetasAcademyHackathon2023\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TouchstoneProfessorMetasAcademyHackathon2023.Collection>(from: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26) == nil {\n            let collection <- TouchstoneProfessorMetasAcademyHackathon2023.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n            }\n        if (acct.getCapability<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26).borrow() == nil) {\n            acct.unlink(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n            acct.link<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26, target: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n        }\n\n        if (acct.getCapability<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26).borrow() == nil) {\n            acct.unlink(/private/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n            acct.link<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26, target: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTouchstoneProfessorMetasAcademyHackathon2023": {
          "TouchstoneProfessorMetasAcademyHackathon2023": {
            "mainnet": {
              "address": "0xfcbe1e1ed18c5a26",
              "contract": "TouchstoneProfessorMetasAcademyHackathon2023",
              "fq_address": "A.0xfcbe1e1ed18c5a26.TouchstoneProfessorMetasAcademyHackathon2023",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47498524
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498527
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498530
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47498531
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498531
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498536
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "1b8e4ebc3886509f3cd86dae20b0c9f95abae13011cd7a928e4377609b669292": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1b8e4ebc3886509f3cd86dae20b0c9f95abae13011cd7a928e4377609b669292",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TouchstoneProfessorMetasAcademyHackathon2023 NFTs"
          }
        }
      },
      "cadence": "import TouchstoneProfessorMetasAcademyHackathon2023 from 0xTouchstoneProfessorMetasAcademyHackathon2023\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TouchstoneProfessorMetasAcademyHackathon2023\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TouchstoneProfessorMetasAcademyHackathon2023.Collection>(from: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26) == nil {\n      let collection <- TouchstoneProfessorMetasAcademyHackathon2023.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n    }\n    if (signer.getCapability<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26).borrow() == nil) {\n      signer.unlink(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n      signer.link<&TouchstoneProfessorMetasAcademyHackathon2023.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26, target: /storage/TouchstoneProfessorMetasAcademyHackathon2023Collection_0xfcbe1e1ed18c5a26)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTouchstoneProfessorMetasAcademyHackathon2023": {
          "TouchstoneProfessorMetasAcademyHackathon2023": {
            "mainnet": {
              "address": "0xfcbe1e1ed18c5a26",
              "contract": "TouchstoneProfessorMetasAcademyHackathon2023",
              "fq_address": "A.0xfcbe1e1ed18c5a26.TouchstoneProfessorMetasAcademyHackathon2023",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47493006
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493009
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493013
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "bf6a94626a897e8e0f315dfb1a9b181a342785a43cc2caaeae8aa1080c494a06": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "bf6a94626a897e8e0f315dfb1a9b181a342785a43cc2caaeae8aa1080c494a06",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TouchstoneManekiPlanets NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TouchstoneManekiPlanets\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505285
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6324fc91c2b74856575d5d8a9c75e3a382c746aaf8d7b6f4f3c256c2fbf9d65d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6324fc91c2b74856575d5d8a9c75e3a382c746aaf8d7b6f4f3c256c2fbf9d65d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TouchstoneManekiPlanets NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TouchstoneManekiPlanets from 0xTouchstoneManekiPlanets\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TouchstoneManekiPlanets\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TouchstoneManekiPlanets.Collection>(from: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8) == nil {\n            let collection <- TouchstoneManekiPlanets.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n        }\n        if (acct.getCapability<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8).borrow() == nil) {\n            acct.unlink(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n            acct.link<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8, target: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n        }\n\n        if (acct.getCapability<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8).borrow() == nil) {\n            acct.unlink(/private/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n            acct.link<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8, target: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)!\n        let collectionRef = acct\n            .getCapability(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n            .borrow<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TouchstoneManekiPlanets.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTouchstoneManekiPlanets": {
          "TouchstoneManekiPlanets": {
            "mainnet": {
              "address": "0xcf3c77ef638573e8",
              "contract": "TouchstoneManekiPlanets",
              "fq_address": "A.0xcf3c77ef638573e8.TouchstoneManekiPlanets",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47505219
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505223
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505226
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505226
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505226
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505230
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "bb94cecb4781131576c3cd313d79b5033d2353a44f5aca5a3358c23470225647": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "bb94cecb4781131576c3cd313d79b5033d2353a44f5aca5a3358c23470225647",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TouchstoneManekiPlanets NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TouchstoneManekiPlanets from 0xTouchstoneManekiPlanets\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TouchstoneManekiPlanets\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TouchstoneManekiPlanets.Collection>(from: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8) == nil {\n            let collection <- TouchstoneManekiPlanets.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n            }\n        if (acct.getCapability<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8).borrow() == nil) {\n            acct.unlink(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n            acct.link<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8, target: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n        }\n\n        if (acct.getCapability<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8).borrow() == nil) {\n            acct.unlink(/private/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n            acct.link<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8, target: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTouchstoneManekiPlanets": {
          "TouchstoneManekiPlanets": {
            "mainnet": {
              "address": "0xcf3c77ef638573e8",
              "contract": "TouchstoneManekiPlanets",
              "fq_address": "A.0xcf3c77ef638573e8.TouchstoneManekiPlanets",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47505267
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505271
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505276
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505278
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505278
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505281
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "20e7770489721ea87bd62ae5b706bacbd419b6047b1c5066557f19e971262304": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "20e7770489721ea87bd62ae5b706bacbd419b6047b1c5066557f19e971262304",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TouchstoneManekiPlanets NFTs"
          }
        }
      },
      "cadence": "import TouchstoneManekiPlanets from 0xTouchstoneManekiPlanets\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TouchstoneManekiPlanets\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TouchstoneManekiPlanets.Collection>(from: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8) == nil {\n      let collection <- TouchstoneManekiPlanets.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n    }\n    if (signer.getCapability<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8).borrow() == nil) {\n      signer.unlink(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n      signer.link<&TouchstoneManekiPlanets.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8, target: /storage/TouchstoneManekiPlanetsCollection_0xcf3c77ef638573e8)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTouchstoneManekiPlanets": {
          "TouchstoneManekiPlanets": {
            "mainnet": {
              "address": "0xcf3c77ef638573e8",
              "contract": "TouchstoneManekiPlanets",
              "fq_address": "A.0xcf3c77ef638573e8.TouchstoneManekiPlanets",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47505177
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505180
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505185
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "28f1057af2f6daf73ea11c2f225e27c4086a6ee1d063d2414bf886ac3f074002": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "28f1057af2f6daf73ea11c2f225e27c4086a6ee1d063d2414bf886ac3f074002",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TouchstoneFLOWFREAKS NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TouchstoneFLOWFREAKS\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512657
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "9dfa4633298520b0b3f321057a9d023690cd836acd9ba76d8f18ea83ac2d57aa": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9dfa4633298520b0b3f321057a9d023690cd836acd9ba76d8f18ea83ac2d57aa",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TouchstoneFLOWFREAKS NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TouchstoneFLOWFREAKS from 0xTouchstoneFLOWFREAKS\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TouchstoneFLOWFREAKS\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TouchstoneFLOWFREAKS.Collection>(from: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb) == nil {\n            let collection <- TouchstoneFLOWFREAKS.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n        }\n        if (acct.getCapability<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb).borrow() == nil) {\n            acct.unlink(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n            acct.link<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb, target: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n        }\n\n        if (acct.getCapability<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb).borrow() == nil) {\n            acct.unlink(/private/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n            acct.link<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb, target: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)!\n        let collectionRef = acct\n            .getCapability(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n            .borrow<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TouchstoneFLOWFREAKS.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTouchstoneFLOWFREAKS": {
          "TouchstoneFLOWFREAKS": {
            "mainnet": {
              "address": "0xcf0c62932f6ff1eb",
              "contract": "TouchstoneFLOWFREAKS",
              "fq_address": "A.0xcf0c62932f6ff1eb.TouchstoneFLOWFREAKS",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47512590
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512593
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512598
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512599
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512599
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512604
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "783c40270c396c0b444e656713871678f67439c2af34c23fee4e3ee46ca1bbaf": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "783c40270c396c0b444e656713871678f67439c2af34c23fee4e3ee46ca1bbaf",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TouchstoneFLOWFREAKS NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TouchstoneFLOWFREAKS from 0xTouchstoneFLOWFREAKS\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TouchstoneFLOWFREAKS\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TouchstoneFLOWFREAKS.Collection>(from: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb) == nil {\n            let collection <- TouchstoneFLOWFREAKS.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n            }\n        if (acct.getCapability<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb).borrow() == nil) {\n            acct.unlink(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n            acct.link<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb, target: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n        }\n\n        if (acct.getCapability<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb).borrow() == nil) {\n            acct.unlink(/private/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n            acct.link<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb, target: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTouchstoneFLOWFREAKS": {
          "TouchstoneFLOWFREAKS": {
            "mainnet": {
              "address": "0xcf0c62932f6ff1eb",
              "contract": "TouchstoneFLOWFREAKS",
              "fq_address": "A.0xcf0c62932f6ff1eb.TouchstoneFLOWFREAKS",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47512639
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512644
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512647
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512647
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512648
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512652
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "d9174c4049a32bcf831c7d35b758f407cfecd5dbc00985ca78d4518f7180bef4": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d9174c4049a32bcf831c7d35b758f407cfecd5dbc00985ca78d4518f7180bef4",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TouchstoneFLOWFREAKS NFTs"
          }
        }
      },
      "cadence": "import TouchstoneFLOWFREAKS from 0xTouchstoneFLOWFREAKS\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TouchstoneFLOWFREAKS\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TouchstoneFLOWFREAKS.Collection>(from: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb) == nil {\n      let collection <- TouchstoneFLOWFREAKS.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n    }\n    if (signer.getCapability<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb).borrow() == nil) {\n      signer.unlink(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n      signer.link<&TouchstoneFLOWFREAKS.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb, target: /storage/TouchstoneFLOWFREAKSCollection_0xcf0c62932f6ff1eb)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTouchstoneFLOWFREAKS": {
          "TouchstoneFLOWFREAKS": {
            "mainnet": {
              "address": "0xcf0c62932f6ff1eb",
              "contract": "TouchstoneFLOWFREAKS",
              "fq_address": "A.0xcf0c62932f6ff1eb.TouchstoneFLOWFREAKS",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47512545
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512548
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512552
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "c3fec61c0493fe5a945bad7d01f2c3037a90181ca91f1b30dccaf9283a11f397": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c3fec61c0493fe5a945bad7d01f2c3037a90181ca91f1b30dccaf9283a11f397",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TicalUniverseUAT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TicalUniverseUAT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813393
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "938479e7b2c6e6d0650bf3e08e7707eb0a87c991caa3fc001643da47d040aafc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "938479e7b2c6e6d0650bf3e08e7707eb0a87c991caa3fc001643da47d040aafc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TicalUniverseUAT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TicalUniverseUAT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n            let collection <- TicalUniverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TicalUniverseCollection)\n        }\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/public/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/private/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TicalUniverseCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TicalUniverseCollection)\n            .borrow<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TicalUniverse.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTicalUniverse": {
          "TicalUniverse": {
            "testnet": {
              "address": "0x58b60c5240d3f39b",
              "contract": "TicalUniverse",
              "fq_address": "A.0x58b60c5240d3f39b.TicalUniverse",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813348
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813351
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813356
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813357
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813357
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813362
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "ff66c6320d66ad46cefc3c209eb20807675df12406e346d650580b00da1aba34": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ff66c6320d66ad46cefc3c209eb20807675df12406e346d650580b00da1aba34",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TicalUniverseUAT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TicalUniverseUAT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n            let collection <- TicalUniverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TicalUniverseCollection)\n            }\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/public/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/private/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TicalUniverseCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTicalUniverse": {
          "TicalUniverse": {
            "testnet": {
              "address": "0x58b60c5240d3f39b",
              "contract": "TicalUniverse",
              "fq_address": "A.0x58b60c5240d3f39b.TicalUniverse",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813372
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813376
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813381
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813382
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813383
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813388
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "8ae86ef9c995b8005b5fd5ae48168c54628f0b324830fb5d2e010ebcc7988f03": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8ae86ef9c995b8005b5fd5ae48168c54628f0b324830fb5d2e010ebcc7988f03",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TicalUniverseUAT NFTs"
          }
        }
      },
      "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TicalUniverseUAT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n      let collection <- TicalUniverse.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TicalUniverseCollection)\n    }\n    if (signer.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n      signer.unlink(/public/TicalUniverseCollection)\n      signer.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTicalUniverse": {
          "TicalUniverse": {
            "testnet": {
              "address": "0x58b60c5240d3f39b",
              "contract": "TicalUniverse",
              "fq_address": "A.0x58b60c5240d3f39b.TicalUniverse",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813329
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813332
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813337
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "902f8de0e796cb9d53d88851eb4cdf90589ac9c7808bf209f5fd03e80b549a19": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "902f8de0e796cb9d53d88851eb4cdf90589ac9c7808bf209f5fd03e80b549a19",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a ThisIsEpixV2Collection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: ThisIsEpixV2Collection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493437
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "0e9176880bb3e766640100051c096338d2027dd338dc3359411953ff31a8699b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0e9176880bb3e766640100051c096338d2027dd338dc3359411953ff31a8699b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a ThisIsEpixV2Collection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import EpixV2 from 0xEpixV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ThisIsEpixV2Collection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&EpixV2.Collection>(from: /storage/EpixV2Collection) == nil {\n            let collection <- EpixV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/EpixV2Collection)\n        }\n        if (acct.getCapability<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/EpixV2Collection).borrow() == nil) {\n            acct.unlink(/public/EpixV2Collection)\n            acct.link<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/EpixV2Collection, target: /storage/EpixV2Collection)\n        }\n\n        if (acct.getCapability<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/EpixV2Collection).borrow() == nil) {\n            acct.unlink(/private/EpixV2Collection)\n            acct.link<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/EpixV2Collection, target: /storage/EpixV2Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/EpixV2Collection)!\n        let collectionRef = acct\n            .getCapability(/public/EpixV2Collection)\n            .borrow<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@EpixV2.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xEpixV2": {
          "EpixV2": {
            "mainnet": {
              "address": "0xcc838e3f0213008f",
              "contract": "EpixV2",
              "fq_address": "A.0xcc838e3f0213008f.EpixV2",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47493397
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493400
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493404
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493405
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493407
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493410
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "c4d73fa5fc3f60443cfebaf8d0e7e76b5141d3ecc460ccb2f2c823b30854862a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c4d73fa5fc3f60443cfebaf8d0e7e76b5141d3ecc460ccb2f2c823b30854862a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed ThisIsEpixV2Collection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import EpixV2 from 0xEpixV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ThisIsEpixV2Collection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&EpixV2.Collection>(from: /storage/EpixV2Collection) == nil {\n            let collection <- EpixV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/EpixV2Collection)\n            }\n        if (acct.getCapability<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/EpixV2Collection).borrow() == nil) {\n            acct.unlink(/public/EpixV2Collection)\n            acct.link<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/EpixV2Collection, target: /storage/EpixV2Collection)\n        }\n\n        if (acct.getCapability<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/EpixV2Collection).borrow() == nil) {\n            acct.unlink(/private/EpixV2Collection)\n            acct.link<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/EpixV2Collection, target: /storage/EpixV2Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/EpixV2Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xEpixV2": {
          "EpixV2": {
            "mainnet": {
              "address": "0xcc838e3f0213008f",
              "contract": "EpixV2",
              "fq_address": "A.0xcc838e3f0213008f.EpixV2",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47493419
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493422
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493427
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493429
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493429
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493433
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "c82be7449df623e7ba3a8af08d87a862b3e9998bef35d28f00c439c229711f96": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c82be7449df623e7ba3a8af08d87a862b3e9998bef35d28f00c439c229711f96",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support ThisIsEpixV2Collection NFTs"
          }
        }
      },
      "cadence": "import EpixV2 from 0xEpixV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ThisIsEpixV2Collection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&EpixV2.Collection>(from: /storage/EpixV2Collection) == nil {\n      let collection <- EpixV2.createEmptyCollection()\n      signer.save(<-collection, to: /storage/EpixV2Collection)\n    }\n    if (signer.getCapability<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/EpixV2Collection).borrow() == nil) {\n      signer.unlink(/public/EpixV2Collection)\n      signer.link<&EpixV2.Collection{EpixV2.EpixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/EpixV2Collection, target: /storage/EpixV2Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xEpixV2": {
          "EpixV2": {
            "mainnet": {
              "address": "0xcc838e3f0213008f",
              "contract": "EpixV2",
              "fq_address": "A.0xcc838e3f0213008f.EpixV2",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47493383
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493384
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493388
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "f6376a4ce0b5c88668a964ef0ed3a555ce3a0f14df8943d25ae84f879175b39f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f6376a4ce0b5c88668a964ef0ed3a555ce3a0f14df8943d25ae84f879175b39f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TicalUniverse NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TicalUniverse\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508206
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "324124d821a053ec803bb1d6ae0fd18d6fe49edb564a815f0961485297b87093": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "324124d821a053ec803bb1d6ae0fd18d6fe49edb564a815f0961485297b87093",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TicalUniverse NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TicalUniverse\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n            let collection <- TicalUniverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TicalUniverseCollection)\n        }\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/public/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/private/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TicalUniverseCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TicalUniverseCollection)\n            .borrow<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TicalUniverse.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTicalUniverse": {
          "TicalUniverse": {
            "mainnet": {
              "address": "0xfef48806337aabf1",
              "contract": "TicalUniverse",
              "fq_address": "A.0xfef48806337aabf1.TicalUniverse",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508166
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508169
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508173
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508175
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508176
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508179
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "4142e0b2fafc6eee74d7c186e95355cc340efe81ad2b476cb14a2561495bf00a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4142e0b2fafc6eee74d7c186e95355cc340efe81ad2b476cb14a2561495bf00a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TicalUniverse NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TicalUniverse\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n            let collection <- TicalUniverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TicalUniverseCollection)\n            }\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/public/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n\n        if (acct.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection).borrow() == nil) {\n            acct.unlink(/private/TicalUniverseCollection)\n            acct.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TicalUniverseCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTicalUniverse": {
          "TicalUniverse": {
            "mainnet": {
              "address": "0xfef48806337aabf1",
              "contract": "TicalUniverse",
              "fq_address": "A.0xfef48806337aabf1.TicalUniverse",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508188
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508191
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508196
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508196
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508196
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508201
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "ce233c6fd53bc4a37ef4135c504a1c1d9223ee46e97ae0cc79af6e0b7c7514ed": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ce233c6fd53bc4a37ef4135c504a1c1d9223ee46e97ae0cc79af6e0b7c7514ed",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TicalUniverse NFTs"
          }
        }
      },
      "cadence": "import TicalUniverse from 0xTicalUniverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TicalUniverse\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TicalUniverse.Collection>(from: /storage/TicalUniverseCollection) == nil {\n      let collection <- TicalUniverse.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TicalUniverseCollection)\n    }\n    if (signer.getCapability<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection).borrow() == nil) {\n      signer.unlink(/public/TicalUniverseCollection)\n      signer.link<&TicalUniverse.Collection{TicalUniverse.TicalUniverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TicalUniverseCollection, target: /storage/TicalUniverseCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTicalUniverse": {
          "TicalUniverse": {
            "mainnet": {
              "address": "0xfef48806337aabf1",
              "contract": "TicalUniverse",
              "fq_address": "A.0xfef48806337aabf1.TicalUniverse",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508151
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508153
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508157
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "d399157c30790ff0773bc769eb277c84041eb25dc0788b0c955d2e2adbf7c6c2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d399157c30790ff0773bc769eb277c84041eb25dc0788b0c955d2e2adbf7c6c2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheSkyharborCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheSkyharborCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512413
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "5035c2fb453c3ea65591506600c4d4600babca13cc1c2db2f5a0fba68bdddc45": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5035c2fb453c3ea65591506600c4d4600babca13cc1c2db2f5a0fba68bdddc45",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheSkyharborCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SkyharborNFT from 0xSkyharborNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheSkyharborCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SkyharborNFT.Collection>(from: /storage/skyharborNFTCollection) == nil {\n            let collection <- SkyharborNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/skyharborNFTCollection)\n        }\n        if (acct.getCapability<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/skyharborNFTCollection).borrow() == nil) {\n            acct.unlink(/public/skyharborNFTCollection)\n            acct.link<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/skyharborNFTCollection, target: /storage/skyharborNFTCollection)\n        }\n\n        if (acct.getCapability<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/exampleNFTCollection).borrow() == nil) {\n            acct.unlink(/private/exampleNFTCollection)\n            acct.link<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/exampleNFTCollection, target: /storage/skyharborNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/exampleNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/skyharborNFTCollection)\n            .borrow<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SkyharborNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSkyharborNFT": {
          "SkyharborNFT": {
            "mainnet": {
              "address": "0x33f44e504a396ba7",
              "contract": "SkyharborNFT",
              "fq_address": "A.0x33f44e504a396ba7.SkyharborNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47512376
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512379
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512383
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512384
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512384
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512387
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "ab5749118787f7ff0b80ad36831023efa7ea0de6c825095569e722b0869a8ccf": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ab5749118787f7ff0b80ad36831023efa7ea0de6c825095569e722b0869a8ccf",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheSkyharborCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SkyharborNFT from 0xSkyharborNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheSkyharborCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SkyharborNFT.Collection>(from: /storage/skyharborNFTCollection) == nil {\n            let collection <- SkyharborNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/skyharborNFTCollection)\n            }\n        if (acct.getCapability<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/skyharborNFTCollection).borrow() == nil) {\n            acct.unlink(/public/skyharborNFTCollection)\n            acct.link<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/skyharborNFTCollection, target: /storage/skyharborNFTCollection)\n        }\n\n        if (acct.getCapability<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/exampleNFTCollection).borrow() == nil) {\n            acct.unlink(/private/exampleNFTCollection)\n            acct.link<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/exampleNFTCollection, target: /storage/skyharborNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/skyharborNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSkyharborNFT": {
          "SkyharborNFT": {
            "mainnet": {
              "address": "0x33f44e504a396ba7",
              "contract": "SkyharborNFT",
              "fq_address": "A.0x33f44e504a396ba7.SkyharborNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47512394
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512398
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512403
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512403
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512403
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512409
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "8bddb2a86805af82e0fe37f6689156c486e06f35474215707f2dc86792de96d0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8bddb2a86805af82e0fe37f6689156c486e06f35474215707f2dc86792de96d0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheSkyharborCollection NFTs"
          }
        }
      },
      "cadence": "import SkyharborNFT from 0xSkyharborNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheSkyharborCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SkyharborNFT.Collection>(from: /storage/skyharborNFTCollection) == nil {\n      let collection <- SkyharborNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/skyharborNFTCollection)\n    }\n    if (signer.getCapability<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/skyharborNFTCollection).borrow() == nil) {\n      signer.unlink(/public/skyharborNFTCollection)\n      signer.link<&SkyharborNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/skyharborNFTCollection, target: /storage/skyharborNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSkyharborNFT": {
          "SkyharborNFT": {
            "mainnet": {
              "address": "0x33f44e504a396ba7",
              "contract": "SkyharborNFT",
              "fq_address": "A.0x33f44e504a396ba7.SkyharborNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47512359
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512362
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512366
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "b81deb48a81d012dca066f22682e62e2b4fce2a7f1ff738dd9643c5282a0b806": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b81deb48a81d012dca066f22682e62e2b4fce2a7f1ff738dd9643c5282a0b806",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a ThingFundMembershipBadge NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: ThingFundMembershipBadge\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505768
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804377
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "e0d2b11d7fbc8eb1a2b711651da0294c74ef6c63c1d7b4a6ae2083b9b46bd547": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e0d2b11d7fbc8eb1a2b711651da0294c74ef6c63c1d7b4a6ae2083b9b46bd547",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a ThingFundMembershipBadge NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CaaPass from 0xCaaPass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ThingFundMembershipBadge\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CaaPass.Collection>(from: /storage/caaPassCollection) == nil {\n            let collection <- CaaPass.createEmptyCollection()\n            acct.save(<-collection, to: /storage/caaPassCollection)\n        }\n        if (acct.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection).borrow() == nil) {\n            acct.unlink(/public/caaPassCollection)\n            acct.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection, target: /storage/caaPassCollection)\n        }\n\n        if (acct.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/caaPassCollection).borrow() == nil) {\n            acct.unlink(/private/caaPassCollection)\n            acct.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/caaPassCollection, target: /storage/caaPassCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/caaPassCollection)!\n        let collectionRef = acct\n            .getCapability(/public/caaPassCollection)\n            .borrow<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CaaPass.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCaaPass": {
          "CaaPass": {
            "mainnet": {
              "address": "0x98c9c2e548b84d31",
              "contract": "CaaPass",
              "fq_address": "A.0x98c9c2e548b84d31.CaaPass",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505692
            },
            "testnet": {
              "address": "0xa8b1239250f8d342",
              "contract": "CaaPass",
              "fq_address": "A.0xa8b1239250f8d342.CaaPass",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804287
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505702
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804294
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505710
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804304
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505714
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804306
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505716
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804308
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505720
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804317
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "a8ad032570083c8c8dfe373a7cc0c090b110765b9fade3ec996054379611c39a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a8ad032570083c8c8dfe373a7cc0c090b110765b9fade3ec996054379611c39a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed ThingFundMembershipBadge NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CaaPass from 0xCaaPass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ThingFundMembershipBadge\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CaaPass.Collection>(from: /storage/caaPassCollection) == nil {\n            let collection <- CaaPass.createEmptyCollection()\n            acct.save(<-collection, to: /storage/caaPassCollection)\n            }\n        if (acct.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection).borrow() == nil) {\n            acct.unlink(/public/caaPassCollection)\n            acct.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection, target: /storage/caaPassCollection)\n        }\n\n        if (acct.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/caaPassCollection).borrow() == nil) {\n            acct.unlink(/private/caaPassCollection)\n            acct.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/caaPassCollection, target: /storage/caaPassCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/caaPassCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCaaPass": {
          "CaaPass": {
            "mainnet": {
              "address": "0x98c9c2e548b84d31",
              "contract": "CaaPass",
              "fq_address": "A.0x98c9c2e548b84d31.CaaPass",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505731
            },
            "testnet": {
              "address": "0xa8b1239250f8d342",
              "contract": "CaaPass",
              "fq_address": "A.0xa8b1239250f8d342.CaaPass",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804337
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505742
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804344
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505750
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804353
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505755
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804355
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505755
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804356
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505759
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804367
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "51c2921c79a0d15c7583493528292af2ea2a1db00c53859c24b163fc522eb037": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "51c2921c79a0d15c7583493528292af2ea2a1db00c53859c24b163fc522eb037",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support ThingFundMembershipBadge NFTs"
          }
        }
      },
      "cadence": "import CaaPass from 0xCaaPass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ThingFundMembershipBadge\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CaaPass.Collection>(from: /storage/caaPassCollection) == nil {\n      let collection <- CaaPass.createEmptyCollection()\n      signer.save(<-collection, to: /storage/caaPassCollection)\n    }\n    if (signer.getCapability<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection).borrow() == nil) {\n      signer.unlink(/public/caaPassCollection)\n      signer.link<&CaaPass.Collection{CaaPass.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/caaPassCollection, target: /storage/caaPassCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCaaPass": {
          "CaaPass": {
            "mainnet": {
              "address": "0x98c9c2e548b84d31",
              "contract": "CaaPass",
              "fq_address": "A.0x98c9c2e548b84d31.CaaPass",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505662
            },
            "testnet": {
              "address": "0xa8b1239250f8d342",
              "contract": "CaaPass",
              "fq_address": "A.0xa8b1239250f8d342.CaaPass",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804251
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505672
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804259
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505679
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804269
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "4e0fc670f86c486202bb8fbaf56970ed807690ff83055758797dc3a0e053c555": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4e0fc670f86c486202bb8fbaf56970ed807690ff83055758797dc3a0e053c555",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a ThePublishedNFTCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: ThePublishedNFTCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502049
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799939
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "c30e9ebe10ecc8244312d7dd9af3bb86b82f16fa7d7b9c4f9ba99863b1eb89e3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c30e9ebe10ecc8244312d7dd9af3bb86b82f16fa7d7b9c4f9ba99863b1eb89e3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a ThePublishedNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PublishedNFT from 0xPublishedNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ThePublishedNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PublishedNFT.Collection>(from: /storage/publishedNFTCollection) == nil {\n            let collection <- PublishedNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/publishedNFTCollection)\n        }\n        if (acct.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection).borrow() == nil) {\n            acct.unlink(/public/publishedNFTCollection)\n            acct.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection, target: /storage/publishedNFTCollection)\n        }\n\n        if (acct.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PublishedNFTCollection).borrow() == nil) {\n            acct.unlink(/private/PublishedNFTCollection)\n            acct.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PublishedNFTCollection, target: /storage/publishedNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/PublishedNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/publishedNFTCollection)\n            .borrow<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@PublishedNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xPublishedNFT": {
          "PublishedNFT": {
            "mainnet": {
              "address": "0x52cbea4e6f616b8e",
              "contract": "PublishedNFT",
              "fq_address": "A.0x52cbea4e6f616b8e.PublishedNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47501962
            },
            "testnet": {
              "address": "0x00af2ab363fa49e4",
              "contract": "PublishedNFT",
              "fq_address": "A.0x00af2ab363fa49e4.PublishedNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95799849
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501975
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799856
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501981
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799864
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501986
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95799867
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501988
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799868
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501993
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799878
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "560287dad7950aa72cd978f2ef782303c1ced79426e90e9277bcf7577155861b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "560287dad7950aa72cd978f2ef782303c1ced79426e90e9277bcf7577155861b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed ThePublishedNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PublishedNFT from 0xPublishedNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ThePublishedNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PublishedNFT.Collection>(from: /storage/publishedNFTCollection) == nil {\n            let collection <- PublishedNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/publishedNFTCollection)\n            }\n        if (acct.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection).borrow() == nil) {\n            acct.unlink(/public/publishedNFTCollection)\n            acct.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection, target: /storage/publishedNFTCollection)\n        }\n\n        if (acct.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PublishedNFTCollection).borrow() == nil) {\n            acct.unlink(/private/PublishedNFTCollection)\n            acct.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PublishedNFTCollection, target: /storage/publishedNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/publishedNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xPublishedNFT": {
          "PublishedNFT": {
            "mainnet": {
              "address": "0x52cbea4e6f616b8e",
              "contract": "PublishedNFT",
              "fq_address": "A.0x52cbea4e6f616b8e.PublishedNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47502006
            },
            "testnet": {
              "address": "0x00af2ab363fa49e4",
              "contract": "PublishedNFT",
              "fq_address": "A.0x00af2ab363fa49e4.PublishedNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95799898
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502019
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799905
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502027
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799915
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502033
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95799917
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502034
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799918
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502039
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799928
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "05ca10b82751f6676ea193cc5059c87489a5acf0c4a0245b1f71ebca61ec19f3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "05ca10b82751f6676ea193cc5059c87489a5acf0c4a0245b1f71ebca61ec19f3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support ThePublishedNFTCollection NFTs"
          }
        }
      },
      "cadence": "import PublishedNFT from 0xPublishedNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ThePublishedNFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&PublishedNFT.Collection>(from: /storage/publishedNFTCollection) == nil {\n      let collection <- PublishedNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/publishedNFTCollection)\n    }\n    if (signer.getCapability<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection).borrow() == nil) {\n      signer.unlink(/public/publishedNFTCollection)\n      signer.link<&PublishedNFT.Collection{PublishedNFT.PublishedNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/publishedNFTCollection, target: /storage/publishedNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xPublishedNFT": {
          "PublishedNFT": {
            "mainnet": {
              "address": "0x52cbea4e6f616b8e",
              "contract": "PublishedNFT",
              "fq_address": "A.0x52cbea4e6f616b8e.PublishedNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47501930
            },
            "testnet": {
              "address": "0x00af2ab363fa49e4",
              "contract": "PublishedNFT",
              "fq_address": "A.0x00af2ab363fa49e4.PublishedNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95799811
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501941
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799819
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501950
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799828
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "559d98be0033e8cb350de74ee651d34d7959fb84113cf2e09ee580c91f0c3786": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "559d98be0033e8cb350de74ee651d34d7959fb84113cf2e09ee580c91f0c3786",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a ThePotion NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: ThePotion\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501802
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "2949f2f8783b35cfb0d5a492545d56da02ad76e4838c733d381ac38cbbfdc977": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2949f2f8783b35cfb0d5a492545d56da02ad76e4838c733d381ac38cbbfdc977",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a ThePotion NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SomePlaceCollectible from 0xSomePlaceCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ThePotion\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SomePlaceCollectible.Collection>(from: /storage/somePlaceCollectibleCollection) == nil {\n            let collection <- SomePlaceCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/somePlaceCollectibleCollection)\n        }\n        if (acct.getCapability<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/somePlaceCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/somePlaceCollectibleCollection)\n            acct.link<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/somePlaceCollectibleCollection, target: /storage/somePlaceCollectibleCollection)\n        }\n\n        if (acct.getCapability<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/somePlaceCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/somePlaceCollectibleCollection)\n            acct.link<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/somePlaceCollectibleCollection, target: /storage/somePlaceCollectibleCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/somePlaceCollectibleCollection)!\n        let collectionRef = acct\n            .getCapability(/public/somePlaceCollectibleCollection)\n            .borrow<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SomePlaceCollectible.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSomePlaceCollectible": {
          "SomePlaceCollectible": {
            "mainnet": {
              "address": "0x667a16294a089ef8",
              "contract": "SomePlaceCollectible",
              "fq_address": "A.0x667a16294a089ef8.SomePlaceCollectible",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47501761
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501765
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501769
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501770
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501770
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501773
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "5814b94848ddcb06a686a927174ba2f0136ba80ca7647fbd4a19b1e368937ee0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5814b94848ddcb06a686a927174ba2f0136ba80ca7647fbd4a19b1e368937ee0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed ThePotion NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SomePlaceCollectible from 0xSomePlaceCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ThePotion\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SomePlaceCollectible.Collection>(from: /storage/somePlaceCollectibleCollection) == nil {\n            let collection <- SomePlaceCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/somePlaceCollectibleCollection)\n            }\n        if (acct.getCapability<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/somePlaceCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/somePlaceCollectibleCollection)\n            acct.link<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/somePlaceCollectibleCollection, target: /storage/somePlaceCollectibleCollection)\n        }\n\n        if (acct.getCapability<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/somePlaceCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/somePlaceCollectibleCollection)\n            acct.link<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/somePlaceCollectibleCollection, target: /storage/somePlaceCollectibleCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/somePlaceCollectibleCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSomePlaceCollectible": {
          "SomePlaceCollectible": {
            "mainnet": {
              "address": "0x667a16294a089ef8",
              "contract": "SomePlaceCollectible",
              "fq_address": "A.0x667a16294a089ef8.SomePlaceCollectible",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47501784
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501787
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501791
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501792
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501792
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501797
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "daad703fc0c0eba904aff091ab179376a895e83f68aac133bbd503b282ccddb1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "daad703fc0c0eba904aff091ab179376a895e83f68aac133bbd503b282ccddb1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support ThePotion NFTs"
          }
        }
      },
      "cadence": "import SomePlaceCollectible from 0xSomePlaceCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ThePotion\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SomePlaceCollectible.Collection>(from: /storage/somePlaceCollectibleCollection) == nil {\n      let collection <- SomePlaceCollectible.createEmptyCollection()\n      signer.save(<-collection, to: /storage/somePlaceCollectibleCollection)\n    }\n    if (signer.getCapability<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/somePlaceCollectibleCollection).borrow() == nil) {\n      signer.unlink(/public/somePlaceCollectibleCollection)\n      signer.link<&SomePlaceCollectible.Collection{SomePlaceCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/somePlaceCollectibleCollection, target: /storage/somePlaceCollectibleCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSomePlaceCollectible": {
          "SomePlaceCollectible": {
            "mainnet": {
              "address": "0x667a16294a089ef8",
              "contract": "SomePlaceCollectible",
              "fq_address": "A.0x667a16294a089ef8.SomePlaceCollectible",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47501745
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501748
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501752
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "9d4b98c63f7daf23dd58c6fab78bb9dc5b77b25ffa2922672943856375270932": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9d4b98c63f7daf23dd58c6fab78bb9dc5b77b25ffa2922672943856375270932",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a ThePlayersLounge NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: ThePlayersLounge\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493500
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6a6dfedc0a8ffaba277fc433aac1d8970003b944eb1c7cf4a3c0b8245967e325": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6a6dfedc0a8ffaba277fc433aac1d8970003b944eb1c7cf4a3c0b8245967e325",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a ThePlayersLounge NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DGD_NFT from 0xDGD_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ThePlayersLounge\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DGD_NFT.Collection>(from: /storage/DGD_NFTCollection) == nil {\n            let collection <- DGD_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DGD_NFTCollection)\n        }\n        if (acct.getCapability<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DGD_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/DGD_NFTCollection)\n            acct.link<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DGD_NFTCollection, target: /storage/DGD_NFTCollection)\n        }\n\n        if (acct.getCapability<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/DGD_NFT).borrow() == nil) {\n            acct.unlink(/private/DGD_NFT)\n            acct.link<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/DGD_NFT, target: /storage/DGD_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DGD_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/DGD_NFTCollection)\n            .borrow<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DGD_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDGD_NFT": {
          "DGD_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "DGD_NFT",
              "fq_address": "A.0x329feb3ab062d289.DGD_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493464
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493467
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493472
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493472
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493473
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493477
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b220acda70d5f83db5a721e705d96ae230c6a579732d74e6e57c39ec2d755fda": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b220acda70d5f83db5a721e705d96ae230c6a579732d74e6e57c39ec2d755fda",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed ThePlayersLounge NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DGD_NFT from 0xDGD_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ThePlayersLounge\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DGD_NFT.Collection>(from: /storage/DGD_NFTCollection) == nil {\n            let collection <- DGD_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DGD_NFTCollection)\n            }\n        if (acct.getCapability<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DGD_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/DGD_NFTCollection)\n            acct.link<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DGD_NFTCollection, target: /storage/DGD_NFTCollection)\n        }\n\n        if (acct.getCapability<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/DGD_NFT).borrow() == nil) {\n            acct.unlink(/private/DGD_NFT)\n            acct.link<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/DGD_NFT, target: /storage/DGD_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DGD_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDGD_NFT": {
          "DGD_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "DGD_NFT",
              "fq_address": "A.0x329feb3ab062d289.DGD_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493485
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493488
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493491
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493493
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493493
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493496
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "734b0947142a0070ab27324d8206613ff0a09f9f7ee813f425b16ba0145a1863": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "734b0947142a0070ab27324d8206613ff0a09f9f7ee813f425b16ba0145a1863",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support ThePlayersLounge NFTs"
          }
        }
      },
      "cadence": "import DGD_NFT from 0xDGD_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ThePlayersLounge\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DGD_NFT.Collection>(from: /storage/DGD_NFTCollection) == nil {\n      let collection <- DGD_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DGD_NFTCollection)\n    }\n    if (signer.getCapability<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DGD_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/DGD_NFTCollection)\n      signer.link<&DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DGD_NFTCollection, target: /storage/DGD_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDGD_NFT": {
          "DGD_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "DGD_NFT",
              "fq_address": "A.0x329feb3ab062d289.DGD_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493446
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493449
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493454
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "d351dffb68d4e162108ecaca266f11380df267e56b70ae46e250899ee5ca4729": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d351dffb68d4e162108ecaca266f11380df267e56b70ae46e250899ee5ca4729",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheKeeprCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheKeeprCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509619
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "46644df573978fea7e8179d6d72b2fbabdb4d88675af8f2bea9fbd4b0c98bff5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "46644df573978fea7e8179d6d72b2fbabdb4d88675af8f2bea9fbd4b0c98bff5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheKeeprCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import KeeprItems from 0xKeeprItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheKeeprCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&KeeprItems.Collection>(from: /storage/KeeprItemsCollectionV10) == nil {\n            let collection <- KeeprItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/KeeprItemsCollectionV10)\n        }\n        if (acct.getCapability<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KeeprItemsCollectionV10).borrow() == nil) {\n            acct.unlink(/public/KeeprItemsCollectionV10)\n            acct.link<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KeeprItemsCollectionV10, target: /storage/KeeprItemsCollectionV10)\n        }\n\n        if (acct.getCapability<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KittyItemsCollection).borrow() == nil) {\n            acct.unlink(/private/KittyItemsCollection)\n            acct.link<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KittyItemsCollection, target: /storage/KeeprItemsCollectionV10)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/KittyItemsCollection)!\n        let collectionRef = acct\n            .getCapability(/public/KeeprItemsCollectionV10)\n            .borrow<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@KeeprItems.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xKeeprItems": {
          "KeeprItems": {
            "mainnet": {
              "address": "0x5eb12ad3d5a99945",
              "contract": "KeeprItems",
              "fq_address": "A.0x5eb12ad3d5a99945.KeeprItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509582
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509584
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509590
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509590
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509590
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509593
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "2882c1999381ae25e6025d419ad52ea3dd8eafaae394651c0ee2f6942b577118": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2882c1999381ae25e6025d419ad52ea3dd8eafaae394651c0ee2f6942b577118",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheKeeprCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import KeeprItems from 0xKeeprItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheKeeprCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&KeeprItems.Collection>(from: /storage/KeeprItemsCollectionV10) == nil {\n            let collection <- KeeprItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/KeeprItemsCollectionV10)\n            }\n        if (acct.getCapability<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KeeprItemsCollectionV10).borrow() == nil) {\n            acct.unlink(/public/KeeprItemsCollectionV10)\n            acct.link<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KeeprItemsCollectionV10, target: /storage/KeeprItemsCollectionV10)\n        }\n\n        if (acct.getCapability<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KittyItemsCollection).borrow() == nil) {\n            acct.unlink(/private/KittyItemsCollection)\n            acct.link<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KittyItemsCollection, target: /storage/KeeprItemsCollectionV10)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/KeeprItemsCollectionV10\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xKeeprItems": {
          "KeeprItems": {
            "mainnet": {
              "address": "0x5eb12ad3d5a99945",
              "contract": "KeeprItems",
              "fq_address": "A.0x5eb12ad3d5a99945.KeeprItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509602
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509605
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509610
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509610
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509610
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509615
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "05d3c3e5784e80988bb916081f3c5c88df23c37573d04e945449dd2d51150b97": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "05d3c3e5784e80988bb916081f3c5c88df23c37573d04e945449dd2d51150b97",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheKeeprCollection NFTs"
          }
        }
      },
      "cadence": "import KeeprItems from 0xKeeprItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheKeeprCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&KeeprItems.Collection>(from: /storage/KeeprItemsCollectionV10) == nil {\n      let collection <- KeeprItems.createEmptyCollection()\n      signer.save(<-collection, to: /storage/KeeprItemsCollectionV10)\n    }\n    if (signer.getCapability<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KeeprItemsCollectionV10).borrow() == nil) {\n      signer.unlink(/public/KeeprItemsCollectionV10)\n      signer.link<&KeeprItems.Collection{KeeprItems.KeeprItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KeeprItemsCollectionV10, target: /storage/KeeprItemsCollectionV10)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xKeeprItems": {
          "KeeprItems": {
            "mainnet": {
              "address": "0x5eb12ad3d5a99945",
              "contract": "KeeprItems",
              "fq_address": "A.0x5eb12ad3d5a99945.KeeprItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509567
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509571
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509574
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "85a03a1117dd889ca9c865121430ac55689b926ecec87adb37abc21a16d10145": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "85a03a1117dd889ca9c865121430ac55689b926ecec87adb37abc21a16d10145",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheNFTDayTreasureChestCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheNFTDayTreasureChestCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505350
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "f73459b09e8367d85d9246d2c646d014035b0fd1c345332d454e1f8221a157d8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f73459b09e8367d85d9246d2c646d014035b0fd1c345332d454e1f8221a157d8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheNFTDayTreasureChestCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTDayTreasureChest from 0xNFTDayTreasureChest\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheNFTDayTreasureChestCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&NFTDayTreasureChest.Collection>(from: /storage/bbNFTDayTreasureChestCollection) == nil {\n            let collection <- NFTDayTreasureChest.createEmptyCollection()\n            acct.save(<-collection, to: /storage/bbNFTDayTreasureChestCollection)\n        }\n        if (acct.getCapability<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bbNFTDayTreasureChestCollection).borrow() == nil) {\n            acct.unlink(/public/bbNFTDayTreasureChestCollection)\n            acct.link<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bbNFTDayTreasureChestCollection, target: /storage/bbNFTDayTreasureChestCollection)\n        }\n\n        if (acct.getCapability<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NFTDayTreasureChestCollection).borrow() == nil) {\n            acct.unlink(/private/NFTDayTreasureChestCollection)\n            acct.link<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NFTDayTreasureChestCollection, target: /storage/bbNFTDayTreasureChestCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/NFTDayTreasureChestCollection)!\n        let collectionRef = acct\n            .getCapability(/public/bbNFTDayTreasureChestCollection)\n            .borrow<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@NFTDayTreasureChest.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xNFTDayTreasureChest": {
          "NFTDayTreasureChest": {
            "mainnet": {
              "address": "0x117396d8a72ad372",
              "contract": "NFTDayTreasureChest",
              "fq_address": "A.0x117396d8a72ad372.NFTDayTreasureChest",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47505312
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505316
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505319
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505320
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505320
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505324
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "e2229538b796f2fa7d40cd31e9e70ae9a82fc46ea481d96675ca042ca186c23e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e2229538b796f2fa7d40cd31e9e70ae9a82fc46ea481d96675ca042ca186c23e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheNFTDayTreasureChestCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTDayTreasureChest from 0xNFTDayTreasureChest\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheNFTDayTreasureChestCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&NFTDayTreasureChest.Collection>(from: /storage/bbNFTDayTreasureChestCollection) == nil {\n            let collection <- NFTDayTreasureChest.createEmptyCollection()\n            acct.save(<-collection, to: /storage/bbNFTDayTreasureChestCollection)\n            }\n        if (acct.getCapability<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bbNFTDayTreasureChestCollection).borrow() == nil) {\n            acct.unlink(/public/bbNFTDayTreasureChestCollection)\n            acct.link<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bbNFTDayTreasureChestCollection, target: /storage/bbNFTDayTreasureChestCollection)\n        }\n\n        if (acct.getCapability<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NFTDayTreasureChestCollection).borrow() == nil) {\n            acct.unlink(/private/NFTDayTreasureChestCollection)\n            acct.link<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NFTDayTreasureChestCollection, target: /storage/bbNFTDayTreasureChestCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/bbNFTDayTreasureChestCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xNFTDayTreasureChest": {
          "NFTDayTreasureChest": {
            "mainnet": {
              "address": "0x117396d8a72ad372",
              "contract": "NFTDayTreasureChest",
              "fq_address": "A.0x117396d8a72ad372.NFTDayTreasureChest",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47505335
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505338
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505342
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505342
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505342
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505346
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "6004cf9e61b9b3367d9c88638065f58af763499d026ef2006684b3fb9ee0be3f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6004cf9e61b9b3367d9c88638065f58af763499d026ef2006684b3fb9ee0be3f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheNFTDayTreasureChestCollection NFTs"
          }
        }
      },
      "cadence": "import NFTDayTreasureChest from 0xNFTDayTreasureChest\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheNFTDayTreasureChestCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&NFTDayTreasureChest.Collection>(from: /storage/bbNFTDayTreasureChestCollection) == nil {\n      let collection <- NFTDayTreasureChest.createEmptyCollection()\n      signer.save(<-collection, to: /storage/bbNFTDayTreasureChestCollection)\n    }\n    if (signer.getCapability<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bbNFTDayTreasureChestCollection).borrow() == nil) {\n      signer.unlink(/public/bbNFTDayTreasureChestCollection)\n      signer.link<&NFTDayTreasureChest.Collection{NFTDayTreasureChest.NFTDayTreasureChestCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/bbNFTDayTreasureChestCollection, target: /storage/bbNFTDayTreasureChestCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xNFTDayTreasureChest": {
          "NFTDayTreasureChest": {
            "mainnet": {
              "address": "0x117396d8a72ad372",
              "contract": "NFTDayTreasureChest",
              "fq_address": "A.0x117396d8a72ad372.NFTDayTreasureChest",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47505295
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505298
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505302
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "5b1c7af0193b5618fc4049d7485ecba6e1f6e5333d40c6c3dad33ca86424a992": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5b1c7af0193b5618fc4049d7485ecba6e1f6e5333d40c6c3dad33ca86424a992",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheFootballClub NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheFootballClub\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509493
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "2dbf5d7b560f8333a1c346611277532891420ec0067b474ad05742fac7fc59c9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2dbf5d7b560f8333a1c346611277532891420ec0067b474ad05742fac7fc59c9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheFootballClub NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TFCItems from 0xTFCItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheFootballClub\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TFCItems.Collection>(from: /storage/TFCItemsCollection) == nil {\n            let collection <- TFCItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TFCItemsCollection)\n        }\n        if (acct.getCapability<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TFCItemsCollection).borrow() == nil) {\n            acct.unlink(/public/TFCItemsCollection)\n            acct.link<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TFCItemsCollection, target: /storage/TFCItemsCollection)\n        }\n\n        if (acct.getCapability<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TFCItemsCollection).borrow() == nil) {\n            acct.unlink(/private/TFCItemsCollection)\n            acct.link<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TFCItemsCollection, target: /storage/TFCItemsCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TFCItemsCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TFCItemsCollection)\n            .borrow<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TFCItems.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTFCItems": {
          "TFCItems": {
            "mainnet": {
              "address": "0x81e95660ab5308e1",
              "contract": "TFCItems",
              "fq_address": "A.0x81e95660ab5308e1.TFCItems",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509453
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509456
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509460
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509462
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509462
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509466
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "cd49779fbd5f09c32e3b2c8e866c3d3fdee122f655f9693936056de751e89a2b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cd49779fbd5f09c32e3b2c8e866c3d3fdee122f655f9693936056de751e89a2b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheFootballClub NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TFCItems from 0xTFCItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheFootballClub\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TFCItems.Collection>(from: /storage/TFCItemsCollection) == nil {\n            let collection <- TFCItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TFCItemsCollection)\n            }\n        if (acct.getCapability<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TFCItemsCollection).borrow() == nil) {\n            acct.unlink(/public/TFCItemsCollection)\n            acct.link<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TFCItemsCollection, target: /storage/TFCItemsCollection)\n        }\n\n        if (acct.getCapability<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TFCItemsCollection).borrow() == nil) {\n            acct.unlink(/private/TFCItemsCollection)\n            acct.link<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TFCItemsCollection, target: /storage/TFCItemsCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TFCItemsCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTFCItems": {
          "TFCItems": {
            "mainnet": {
              "address": "0x81e95660ab5308e1",
              "contract": "TFCItems",
              "fq_address": "A.0x81e95660ab5308e1.TFCItems",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509476
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509479
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509482
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509484
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509485
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509488
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "8ecf7a4006b07e6952e1b42b71d59356711624fbae92350fa5718e9fb8a792d7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8ecf7a4006b07e6952e1b42b71d59356711624fbae92350fa5718e9fb8a792d7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheFootballClub NFTs"
          }
        }
      },
      "cadence": "import TFCItems from 0xTFCItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheFootballClub\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TFCItems.Collection>(from: /storage/TFCItemsCollection) == nil {\n      let collection <- TFCItems.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TFCItemsCollection)\n    }\n    if (signer.getCapability<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TFCItemsCollection).borrow() == nil) {\n      signer.unlink(/public/TFCItemsCollection)\n      signer.link<&TFCItems.Collection{TFCItems.TFCItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TFCItemsCollection, target: /storage/TFCItemsCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTFCItems": {
          "TFCItems": {
            "mainnet": {
              "address": "0x81e95660ab5308e1",
              "contract": "TFCItems",
              "fq_address": "A.0x81e95660ab5308e1.TFCItems",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509437
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509442
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509444
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "38d6d123de5c6e15a78a73c4697dbcb8ae46e23441bc66ff004f7e667f28fa0f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "38d6d123de5c6e15a78a73c4697dbcb8ae46e23441bc66ff004f7e667f28fa0f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheDooverseNFTCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheDooverseNFTCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507199
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "5328ffc2b10d89cc231e915fc973c2d6e1ca74dd96cd4cab65567338b067db28": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5328ffc2b10d89cc231e915fc973c2d6e1ca74dd96cd4cab65567338b067db28",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheDooverseNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DooverseItems from 0xDooverseItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheDooverseNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DooverseItems.Collection>(from: /storage/DooverseItemsCollection) == nil {\n            let collection <- DooverseItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DooverseItemsCollection)\n        }\n        if (acct.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection).borrow() == nil) {\n            acct.unlink(/public/DooverseItemsCollection)\n            acct.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n        }\n\n        if (acct.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DooverseItemsCollection).borrow() == nil) {\n            acct.unlink(/private/DooverseItemsCollection)\n            acct.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DooverseItemsCollection)!\n        let collectionRef = acct\n            .getCapability(/public/DooverseItemsCollection)\n            .borrow<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DooverseItems.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDooverseItems": {
          "DooverseItems": {
            "mainnet": {
              "address": "0x66ad29c7d7465437",
              "contract": "DooverseItems",
              "fq_address": "A.0x66ad29c7d7465437.DooverseItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507160
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507164
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507169
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507171
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507171
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507175
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "19c17863a3d25dfcb43c28b5d7963c5625eb71f9c0e03657726f79cec70a534a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "19c17863a3d25dfcb43c28b5d7963c5625eb71f9c0e03657726f79cec70a534a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheDooverseNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DooverseItems from 0xDooverseItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheDooverseNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DooverseItems.Collection>(from: /storage/DooverseItemsCollection) == nil {\n            let collection <- DooverseItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DooverseItemsCollection)\n            }\n        if (acct.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection).borrow() == nil) {\n            acct.unlink(/public/DooverseItemsCollection)\n            acct.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n        }\n\n        if (acct.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DooverseItemsCollection).borrow() == nil) {\n            acct.unlink(/private/DooverseItemsCollection)\n            acct.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DooverseItemsCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDooverseItems": {
          "DooverseItems": {
            "mainnet": {
              "address": "0x66ad29c7d7465437",
              "contract": "DooverseItems",
              "fq_address": "A.0x66ad29c7d7465437.DooverseItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507184
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507185
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507189
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507192
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507192
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507196
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "4bb6b3d658201b344c3e0d70c6f7057031cc3e8b87075bc32372785970de653f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4bb6b3d658201b344c3e0d70c6f7057031cc3e8b87075bc32372785970de653f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheDooverseNFTCollection NFTs"
          }
        }
      },
      "cadence": "import DooverseItems from 0xDooverseItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheDooverseNFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DooverseItems.Collection>(from: /storage/DooverseItemsCollection) == nil {\n      let collection <- DooverseItems.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DooverseItemsCollection)\n    }\n    if (signer.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection).borrow() == nil) {\n      signer.unlink(/public/DooverseItemsCollection)\n      signer.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDooverseItems": {
          "DooverseItems": {
            "mainnet": {
              "address": "0x66ad29c7d7465437",
              "contract": "DooverseItems",
              "fq_address": "A.0x66ad29c7d7465437.DooverseItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507145
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507149
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507152
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "d25b405a61d3710a95154187b04e020f47e94050dfec36d9f494f8b47a9dd14f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d25b405a61d3710a95154187b04e020f47e94050dfec36d9f494f8b47a9dd14f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheFabricant_WHOLELAND_XXories NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheFabricant_WHOLELAND_XXories\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502328
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95800278
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "f6812cedd2372b4f5f5ef612453c9de62fd23dbdc9832783a516fff6c0681787": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f6812cedd2372b4f5f5ef612453c9de62fd23dbdc9832783a516fff6c0681787",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheKrikeySolarpupsCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheKrikeySolarpupsCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508456
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "14eb773c317c39b696e65fb516cebc511a129e7ca27ea31acdf1c40e960287fc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "14eb773c317c39b696e65fb516cebc511a129e7ca27ea31acdf1c40e960287fc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheKrikeySolarpupsCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SolarpupsNFT from 0xSolarpupsNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheKrikeySolarpupsCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SolarpupsNFT.Collection>(from: /storage/SolarpupsNFTsProd01) == nil {\n            let collection <- SolarpupsNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SolarpupsNFTsProd01)\n        }\n        if (acct.getCapability<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SolarpupsNFTsProd01).borrow() == nil) {\n            acct.unlink(/public/SolarpupsNFTsProd01)\n            acct.link<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SolarpupsNFTsProd01, target: /storage/SolarpupsNFTsProd01)\n        }\n\n        if (acct.getCapability<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SolarpupsNFTsProd01).borrow() == nil) {\n            acct.unlink(/private/SolarpupsNFTsProd01)\n            acct.link<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SolarpupsNFTsProd01, target: /storage/SolarpupsNFTsProd01)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SolarpupsNFTsProd01)!\n        let collectionRef = acct\n            .getCapability(/public/SolarpupsNFTsProd01)\n            .borrow<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SolarpupsNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSolarpupsNFT": {
          "SolarpupsNFT": {
            "mainnet": {
              "address": "0xa8d493db1bb4df56",
              "contract": "SolarpupsNFT",
              "fq_address": "A.0xa8d493db1bb4df56.SolarpupsNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508419
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508421
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508425
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508427
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508427
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508431
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "3685ea2e355674b0a897ec5cd651d2b74a9456664fc8048b515fbb97ff1def18": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3685ea2e355674b0a897ec5cd651d2b74a9456664fc8048b515fbb97ff1def18",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheKrikeySolarpupsCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SolarpupsNFT from 0xSolarpupsNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheKrikeySolarpupsCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SolarpupsNFT.Collection>(from: /storage/SolarpupsNFTsProd01) == nil {\n            let collection <- SolarpupsNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SolarpupsNFTsProd01)\n            }\n        if (acct.getCapability<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SolarpupsNFTsProd01).borrow() == nil) {\n            acct.unlink(/public/SolarpupsNFTsProd01)\n            acct.link<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SolarpupsNFTsProd01, target: /storage/SolarpupsNFTsProd01)\n        }\n\n        if (acct.getCapability<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SolarpupsNFTsProd01).borrow() == nil) {\n            acct.unlink(/private/SolarpupsNFTsProd01)\n            acct.link<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SolarpupsNFTsProd01, target: /storage/SolarpupsNFTsProd01)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SolarpupsNFTsProd01\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSolarpupsNFT": {
          "SolarpupsNFT": {
            "mainnet": {
              "address": "0xa8d493db1bb4df56",
              "contract": "SolarpupsNFT",
              "fq_address": "A.0xa8d493db1bb4df56.SolarpupsNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508439
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508442
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508446
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508448
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508448
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508451
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "66e3500647ba948fa7e82ce7b828d5d8c95cf48cae64e995ed2f2d8d2210fb31": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "66e3500647ba948fa7e82ce7b828d5d8c95cf48cae64e995ed2f2d8d2210fb31",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheKrikeySolarpupsCollection NFTs"
          }
        }
      },
      "cadence": "import SolarpupsNFT from 0xSolarpupsNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheKrikeySolarpupsCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SolarpupsNFT.Collection>(from: /storage/SolarpupsNFTsProd01) == nil {\n      let collection <- SolarpupsNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SolarpupsNFTsProd01)\n    }\n    if (signer.getCapability<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SolarpupsNFTsProd01).borrow() == nil) {\n      signer.unlink(/public/SolarpupsNFTsProd01)\n      signer.link<&SolarpupsNFT.Collection{SolarpupsNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SolarpupsNFTsProd01, target: /storage/SolarpupsNFTsProd01)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSolarpupsNFT": {
          "SolarpupsNFT": {
            "mainnet": {
              "address": "0xa8d493db1bb4df56",
              "contract": "SolarpupsNFT",
              "fq_address": "A.0xa8d493db1bb4df56.SolarpupsNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508403
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508406
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508409
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "62dbd18ca394a725a016a46239eb34ed1cb1475098e0059f1080b8308e138ca0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "62dbd18ca394a725a016a46239eb34ed1cb1475098e0059f1080b8308e138ca0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheCryptoPiggoPotionCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheCryptoPiggoPotionCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488988
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6f7656b0a10209eef3fcdf3e57dd9d46177db1f518c9ce9b445553e33ce58434": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6f7656b0a10209eef3fcdf3e57dd9d46177db1f518c9ce9b445553e33ce58434",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheCryptoPiggoPotionCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CryptoPiggoPotion from 0xCryptoPiggoPotion\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheCryptoPiggoPotionCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggoPotion.Collection>(from: /storage/CryptoPiggoPotionCollection) == nil {\n            let collection <- CryptoPiggoPotion.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoPotionCollection)\n        }\n        if (acct.getCapability<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoPotionCollection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoPotionCollection)\n            acct.link<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoPotionCollection, target: /storage/CryptoPiggoPotionCollection)\n        }\n\n        if (acct.getCapability<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoPotionCollection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoPotionCollection)\n            acct.link<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoPotionCollection, target: /storage/CryptoPiggoPotionCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CryptoPiggoPotionCollection)!\n        let collectionRef = acct\n            .getCapability(/public/CryptoPiggoPotionCollection)\n            .borrow<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CryptoPiggoPotion.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCryptoPiggoPotion": {
          "CryptoPiggoPotion": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggoPotion",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoPotion",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488947
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488952
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488955
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488956
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488956
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488961
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "50104ceab3e811e1e10b3f63afb4325cc10c492d311c9d418dc22322634291bb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "50104ceab3e811e1e10b3f63afb4325cc10c492d311c9d418dc22322634291bb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheCryptoPiggoPotionCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CryptoPiggoPotion from 0xCryptoPiggoPotion\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheCryptoPiggoPotionCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggoPotion.Collection>(from: /storage/CryptoPiggoPotionCollection) == nil {\n            let collection <- CryptoPiggoPotion.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoPotionCollection)\n            }\n        if (acct.getCapability<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoPotionCollection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoPotionCollection)\n            acct.link<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoPotionCollection, target: /storage/CryptoPiggoPotionCollection)\n        }\n\n        if (acct.getCapability<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoPotionCollection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoPotionCollection)\n            acct.link<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoPotionCollection, target: /storage/CryptoPiggoPotionCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CryptoPiggoPotionCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCryptoPiggoPotion": {
          "CryptoPiggoPotion": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggoPotion",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoPotion",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488970
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488972
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488977
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488978
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488978
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488984
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "2794ef68c05a8a288027b3be0cff4c34ae5b3dccb54460be2a209ac836dba9ae": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2794ef68c05a8a288027b3be0cff4c34ae5b3dccb54460be2a209ac836dba9ae",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheCryptoPiggoPotionCollection NFTs"
          }
        }
      },
      "cadence": "import CryptoPiggoPotion from 0xCryptoPiggoPotion\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheCryptoPiggoPotionCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CryptoPiggoPotion.Collection>(from: /storage/CryptoPiggoPotionCollection) == nil {\n      let collection <- CryptoPiggoPotion.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CryptoPiggoPotionCollection)\n    }\n    if (signer.getCapability<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoPotionCollection).borrow() == nil) {\n      signer.unlink(/public/CryptoPiggoPotionCollection)\n      signer.link<&CryptoPiggoPotion.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoPotionCollection, target: /storage/CryptoPiggoPotionCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCryptoPiggoPotion": {
          "CryptoPiggoPotion": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggoPotion",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoPotion",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47488932
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488935
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488939
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "6e3d49d5a531c15161d89e903dcb46be0087cf7f52b780aabcad9648d42695e5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6e3d49d5a531c15161d89e903dcb46be0087cf7f52b780aabcad9648d42695e5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheCharlieCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheCharlieCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813778
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "adf6e15b6f42e3d8a626be8694384b821b30dd6710b02a9ac9aabcf775b796a4": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "adf6e15b6f42e3d8a626be8694384b821b30dd6710b02a9ac9aabcf775b796a4",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheCharlieCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CharlieNFT from 0xCharlieNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheCharlieCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CharlieNFT.Collection>(from: /storage/CharlieNFTCollection) == nil {\n            let collection <- CharlieNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CharlieNFTCollection)\n        }\n        if (acct.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection).borrow() == nil) {\n            acct.unlink(/public/CharlieNFTCollection)\n            acct.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n        }\n\n        if (acct.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CharlieNFTCollection).borrow() == nil) {\n            acct.unlink(/private/CharlieNFTCollection)\n            acct.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CharlieNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/CharlieNFTCollection)\n            .borrow<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CharlieNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCharlieNFT": {
          "CharlieNFT": {
            "testnet": {
              "address": "0x0c7f58ca4b64219d",
              "contract": "CharlieNFT",
              "fq_address": "A.0x0c7f58ca4b64219d.CharlieNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813734
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813737
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813742
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813743
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813743
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813748
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "fcbcee8e830efa963b88eab773b8d96a1821d98c24e4ae4dbde77c734854189b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fcbcee8e830efa963b88eab773b8d96a1821d98c24e4ae4dbde77c734854189b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheCharlieCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CharlieNFT from 0xCharlieNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheCharlieCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CharlieNFT.Collection>(from: /storage/CharlieNFTCollection) == nil {\n            let collection <- CharlieNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CharlieNFTCollection)\n            }\n        if (acct.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection).borrow() == nil) {\n            acct.unlink(/public/CharlieNFTCollection)\n            acct.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n        }\n\n        if (acct.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CharlieNFTCollection).borrow() == nil) {\n            acct.unlink(/private/CharlieNFTCollection)\n            acct.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CharlieNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCharlieNFT": {
          "CharlieNFT": {
            "testnet": {
              "address": "0x0c7f58ca4b64219d",
              "contract": "CharlieNFT",
              "fq_address": "A.0x0c7f58ca4b64219d.CharlieNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813758
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813761
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813766
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813767
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813768
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813773
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "88b22fafda22b717b43059d830792d3d03f397652ceb790aca34b016392ffee8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "88b22fafda22b717b43059d830792d3d03f397652ceb790aca34b016392ffee8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheCharlieCollection NFTs"
          }
        }
      },
      "cadence": "import CharlieNFT from 0xCharlieNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheCharlieCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CharlieNFT.Collection>(from: /storage/CharlieNFTCollection) == nil {\n      let collection <- CharlieNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CharlieNFTCollection)\n    }\n    if (signer.getCapability<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection).borrow() == nil) {\n      signer.unlink(/public/CharlieNFTCollection)\n      signer.link<&CharlieNFT.Collection{CharlieNFT.CharlieNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CharlieNFTCollection, target: /storage/CharlieNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCharlieNFT": {
          "CharlieNFT": {
            "testnet": {
              "address": "0x0c7f58ca4b64219d",
              "contract": "CharlieNFT",
              "fq_address": "A.0x0c7f58ca4b64219d.CharlieNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813715
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813719
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813724
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "c19a82207fda9c361879b2c17603f1a907ac7f3be2ddd2215d65fe542dad2a5d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c19a82207fda9c361879b2c17603f1a907ac7f3be2ddd2215d65fe542dad2a5d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TMNFTV2 NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TMNFTV2\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813936
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ecd33c1b6267d58643329716a528d99e10b6668b984b77867d16d8ce20221b42": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ecd33c1b6267d58643329716a528d99e10b6668b984b77867d16d8ce20221b42",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TMNFTV2 NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TMNFTV2 from 0xTMNFTV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TMNFTV2\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TMNFTV2.Collection>(from: /storage/TMNFTV2Collection) == nil {\n            let collection <- TMNFTV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TMNFTV2Collection)\n        }\n        if (acct.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection).borrow() == nil) {\n            acct.unlink(/public/TMNFTV2Collection)\n            acct.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n        }\n\n        if (acct.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TMNFTV2Collection).borrow() == nil) {\n            acct.unlink(/private/TMNFTV2Collection)\n            acct.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TMNFTV2Collection)!\n        let collectionRef = acct\n            .getCapability(/public/TMNFTV2Collection)\n            .borrow<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TMNFTV2.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTMNFTV2": {
          "TMNFTV2": {
            "testnet": {
              "address": "0x87dc938d9246d780",
              "contract": "TMNFTV2",
              "fq_address": "A.0x87dc938d9246d780.TMNFTV2",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813892
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813896
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813900
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813902
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813902
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813906
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "1724d781df47567504e14efe2d30c18c4ac090fa88293c10f9f4bee5fe978e1b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1724d781df47567504e14efe2d30c18c4ac090fa88293c10f9f4bee5fe978e1b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TMNFTV2 NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TMNFTV2 from 0xTMNFTV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TMNFTV2\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TMNFTV2.Collection>(from: /storage/TMNFTV2Collection) == nil {\n            let collection <- TMNFTV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TMNFTV2Collection)\n            }\n        if (acct.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection).borrow() == nil) {\n            acct.unlink(/public/TMNFTV2Collection)\n            acct.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n        }\n\n        if (acct.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TMNFTV2Collection).borrow() == nil) {\n            acct.unlink(/private/TMNFTV2Collection)\n            acct.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TMNFTV2Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTMNFTV2": {
          "TMNFTV2": {
            "testnet": {
              "address": "0x87dc938d9246d780",
              "contract": "TMNFTV2",
              "fq_address": "A.0x87dc938d9246d780.TMNFTV2",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813916
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813920
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813925
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813926
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813926
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813931
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "22eb8729533402ed9df17d992a287884689eaa1657d117cd03223ae9c093dc30": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "22eb8729533402ed9df17d992a287884689eaa1657d117cd03223ae9c093dc30",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TMNFTV2 NFTs"
          }
        }
      },
      "cadence": "import TMNFTV2 from 0xTMNFTV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TMNFTV2\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TMNFTV2.Collection>(from: /storage/TMNFTV2Collection) == nil {\n      let collection <- TMNFTV2.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TMNFTV2Collection)\n    }\n    if (signer.getCapability<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection).borrow() == nil) {\n      signer.unlink(/public/TMNFTV2Collection)\n      signer.link<&TMNFTV2.Collection{TMNFTV2.TMNFTV2CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TMNFTV2Collection, target: /storage/TMNFTV2Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTMNFTV2": {
          "TMNFTV2": {
            "testnet": {
              "address": "0x87dc938d9246d780",
              "contract": "TMNFTV2",
              "fq_address": "A.0x87dc938d9246d780.TMNFTV2",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813874
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813878
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813882
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "19928ced41722f6c0e56d83b9c31f227f67fd7d2e927410a410e40115954753f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "19928ced41722f6c0e56d83b9c31f227f67fd7d2e927410a410e40115954753f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TestEditionsNFTs NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TestEditionsNFTs\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813864
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "fe73856c6f475a92b7152d74831e49cc1f0a87f01ab1c5462ce23cd0bc2f6d10": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fe73856c6f475a92b7152d74831e49cc1f0a87f01ab1c5462ce23cd0bc2f6d10",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TestEditionsNFTs NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TestEditionsNfTs from 0xTestEditionsNfTs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TestEditionsNFTs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TestEditionsNfTs.Collection>(from: /storage/TestEditionsNfTs_Collection) == nil {\n            let collection <- TestEditionsNfTs.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TestEditionsNfTs_Collection)\n        }\n        if (acct.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection).borrow() == nil) {\n            acct.unlink(/public/TestEditionsNfTs_Collection)\n            acct.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n        }\n\n        if (acct.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TestEditionsNfTs_Collection).borrow() == nil) {\n            acct.unlink(/private/TestEditionsNfTs_Collection)\n            acct.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/TestEditionsNfTs_Collection)!\n        let collectionRef = acct\n            .getCapability(/public/TestEditionsNfTs_Collection)\n            .borrow<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TestEditionsNfTs.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTestEditionsNfTs": {
          "TestEditionsNfTs": {
            "testnet": {
              "address": "0x4f2b9df936b8ee37",
              "contract": "TestEditionsNfTs",
              "fq_address": "A.0x4f2b9df936b8ee37.TestEditionsNfTs",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 95813816
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813819
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813824
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813825
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813826
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813830
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "f3da9603e176a10c014dae840f1f556904c2177b21419be19c369b49b553f2c8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f3da9603e176a10c014dae840f1f556904c2177b21419be19c369b49b553f2c8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TestEditionsNFTs NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TestEditionsNfTs from 0xTestEditionsNfTs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TestEditionsNFTs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TestEditionsNfTs.Collection>(from: /storage/TestEditionsNfTs_Collection) == nil {\n            let collection <- TestEditionsNfTs.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TestEditionsNfTs_Collection)\n            }\n        if (acct.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection).borrow() == nil) {\n            acct.unlink(/public/TestEditionsNfTs_Collection)\n            acct.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n        }\n\n        if (acct.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TestEditionsNfTs_Collection).borrow() == nil) {\n            acct.unlink(/private/TestEditionsNfTs_Collection)\n            acct.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TestEditionsNfTs_Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTestEditionsNfTs": {
          "TestEditionsNfTs": {
            "testnet": {
              "address": "0x4f2b9df936b8ee37",
              "contract": "TestEditionsNfTs",
              "fq_address": "A.0x4f2b9df936b8ee37.TestEditionsNfTs",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 95813846
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813849
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813853
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813854
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813855
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813859
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "0c91871e5c928468598090b8a6c56ccacff609cc48778c6a6e41f0c0ffd2a37c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0c91871e5c928468598090b8a6c56ccacff609cc48778c6a6e41f0c0ffd2a37c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TestEditionsNFTs NFTs"
          }
        }
      },
      "cadence": "import TestEditionsNfTs from 0xTestEditionsNfTs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TestEditionsNFTs\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TestEditionsNfTs.Collection>(from: /storage/TestEditionsNfTs_Collection) == nil {\n      let collection <- TestEditionsNfTs.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TestEditionsNfTs_Collection)\n    }\n    if (signer.getCapability<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection).borrow() == nil) {\n      signer.unlink(/public/TestEditionsNfTs_Collection)\n      signer.link<&TestEditionsNfTs.Collection{TestEditionsNfTs.TestEditionsNfTsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TestEditionsNfTs_Collection, target: /storage/TestEditionsNfTs_Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTestEditionsNfTs": {
          "TestEditionsNfTs": {
            "testnet": {
              "address": "0x4f2b9df936b8ee37",
              "contract": "TestEditionsNfTs",
              "fq_address": "A.0x4f2b9df936b8ee37.TestEditionsNfTs",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 95813793
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813796
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813801
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "e7b1a2a377c6f53df14b32d3445a62c83e54a1695fc2af1f6667eea497fe2347": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e7b1a2a377c6f53df14b32d3445a62c83e54a1695fc2af1f6667eea497fe2347",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a TheBroadwayExchange NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: TheBroadwayExchange\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508270
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "02f7fc768191ba2dc1d08d516c900a9451079d441321b1e8762da58779697eb7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "02f7fc768191ba2dc1d08d516c900a9451079d441321b1e8762da58779697eb7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a TheBroadwayExchange NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import BWAYX_NFT from 0xBWAYX_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: TheBroadwayExchange\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BWAYX_NFT.Collection>(from: /storage/BWAYX_NFTCollection) == nil {\n            let collection <- BWAYX_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BWAYX_NFTCollection)\n        }\n        if (acct.getCapability<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BWAYX_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/BWAYX_NFTCollection)\n            acct.link<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BWAYX_NFTCollection, target: /storage/BWAYX_NFTCollection)\n        }\n\n        if (acct.getCapability<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/BWAYX_NFT).borrow() == nil) {\n            acct.unlink(/private/BWAYX_NFT)\n            acct.link<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/BWAYX_NFT, target: /storage/BWAYX_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/BWAYX_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/BWAYX_NFTCollection)\n            .borrow<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@BWAYX_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xBWAYX_NFT": {
          "BWAYX_NFT": {
            "mainnet": {
              "address": "0xf02b15e11eb3715b",
              "contract": "BWAYX_NFT",
              "fq_address": "A.0xf02b15e11eb3715b.BWAYX_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508229
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508234
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508238
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508239
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508239
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508243
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "7d5fa321d051c0197fa8ec7777b7e447e071c91bd242ee2549abfd3dd76897ed": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7d5fa321d051c0197fa8ec7777b7e447e071c91bd242ee2549abfd3dd76897ed",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed TheBroadwayExchange NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import BWAYX_NFT from 0xBWAYX_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: TheBroadwayExchange\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BWAYX_NFT.Collection>(from: /storage/BWAYX_NFTCollection) == nil {\n            let collection <- BWAYX_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BWAYX_NFTCollection)\n            }\n        if (acct.getCapability<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BWAYX_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/BWAYX_NFTCollection)\n            acct.link<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BWAYX_NFTCollection, target: /storage/BWAYX_NFTCollection)\n        }\n\n        if (acct.getCapability<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/BWAYX_NFT).borrow() == nil) {\n            acct.unlink(/private/BWAYX_NFT)\n            acct.link<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/BWAYX_NFT, target: /storage/BWAYX_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BWAYX_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xBWAYX_NFT": {
          "BWAYX_NFT": {
            "mainnet": {
              "address": "0xf02b15e11eb3715b",
              "contract": "BWAYX_NFT",
              "fq_address": "A.0xf02b15e11eb3715b.BWAYX_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508253
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508256
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508260
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508262
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508263
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508266
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "7a487c83ffcc455105bb41ddb7815b371355880cfda0d1391460a43df75889a7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7a487c83ffcc455105bb41ddb7815b371355880cfda0d1391460a43df75889a7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support TheBroadwayExchange NFTs"
          }
        }
      },
      "cadence": "import BWAYX_NFT from 0xBWAYX_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: TheBroadwayExchange\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&BWAYX_NFT.Collection>(from: /storage/BWAYX_NFTCollection) == nil {\n      let collection <- BWAYX_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BWAYX_NFTCollection)\n    }\n    if (signer.getCapability<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BWAYX_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/BWAYX_NFTCollection)\n      signer.link<&BWAYX_NFT.Collection{BWAYX_NFT.BWAYX_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BWAYX_NFTCollection, target: /storage/BWAYX_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xBWAYX_NFT": {
          "BWAYX_NFT": {
            "mainnet": {
              "address": "0xf02b15e11eb3715b",
              "contract": "BWAYX_NFT",
              "fq_address": "A.0xf02b15e11eb3715b.BWAYX_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508214
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508216
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508220
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "af9d47f4689caaeb87d36316dd19e70ad82ef1e7a1f786b982826703653ebe57": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "af9d47f4689caaeb87d36316dd19e70ad82ef1e7a1f786b982826703653ebe57",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SturdyExchange NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SturdyExchange\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507123
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "f0290f1d62245041f3c5e091837f9e5f4dbdcda3566a162c1c2ecdb0870be3c7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f0290f1d62245041f3c5e091837f9e5f4dbdcda3566a162c1c2ecdb0870be3c7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a SturdyExchange NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SturdyTokens from 0xSturdyTokens\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SturdyExchange\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SturdyTokens.Collection>(from: /storage/SturdyTokensCollection) == nil {\n            let collection <- SturdyTokens.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SturdyTokensCollection)\n        }\n        if (acct.getCapability<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyTokensCollection).borrow() == nil) {\n            acct.unlink(/public/SturdyTokensCollection)\n            acct.link<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyTokensCollection, target: /storage/SturdyTokensCollection)\n        }\n\n        if (acct.getCapability<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SturdyTokensCollection).borrow() == nil) {\n            acct.unlink(/private/SturdyTokensCollection)\n            acct.link<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SturdyTokensCollection, target: /storage/SturdyTokensCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SturdyTokensCollection)!\n        let collectionRef = acct\n            .getCapability(/public/SturdyTokensCollection)\n            .borrow<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SturdyTokens.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSturdyTokens": {
          "SturdyTokens": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "SturdyTokens",
              "fq_address": "A.0x427ceada271aa0b1.SturdyTokens",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507084
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507088
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507093
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507093
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507094
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507098
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "ab970df4a10205ff6bafe36f55e124ca585f4795012463f307bbda673ab61190": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ab970df4a10205ff6bafe36f55e124ca585f4795012463f307bbda673ab61190",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed SturdyExchange NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SturdyTokens from 0xSturdyTokens\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SturdyExchange\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SturdyTokens.Collection>(from: /storage/SturdyTokensCollection) == nil {\n            let collection <- SturdyTokens.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SturdyTokensCollection)\n            }\n        if (acct.getCapability<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyTokensCollection).borrow() == nil) {\n            acct.unlink(/public/SturdyTokensCollection)\n            acct.link<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyTokensCollection, target: /storage/SturdyTokensCollection)\n        }\n\n        if (acct.getCapability<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SturdyTokensCollection).borrow() == nil) {\n            acct.unlink(/private/SturdyTokensCollection)\n            acct.link<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SturdyTokensCollection, target: /storage/SturdyTokensCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SturdyTokensCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSturdyTokens": {
          "SturdyTokens": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "SturdyTokens",
              "fq_address": "A.0x427ceada271aa0b1.SturdyTokens",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507107
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507110
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507114
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507115
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507116
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507120
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "062fa780bd53da663203eaa3b68664600b4de5a690436b9764793e1720572f57": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "062fa780bd53da663203eaa3b68664600b4de5a690436b9764793e1720572f57",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support SturdyExchange NFTs"
          }
        }
      },
      "cadence": "import SturdyTokens from 0xSturdyTokens\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SturdyExchange\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SturdyTokens.Collection>(from: /storage/SturdyTokensCollection) == nil {\n      let collection <- SturdyTokens.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SturdyTokensCollection)\n    }\n    if (signer.getCapability<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyTokensCollection).borrow() == nil) {\n      signer.unlink(/public/SturdyTokensCollection)\n      signer.link<&SturdyTokens.Collection{SturdyTokens.SturdyTokensCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyTokensCollection, target: /storage/SturdyTokensCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSturdyTokens": {
          "SturdyTokens": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "SturdyTokens",
              "fq_address": "A.0x427ceada271aa0b1.SturdyTokens",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507070
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507073
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507078
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "168ae725987ea4060e55a700d0a3cc8bf0931c26941e7e820c9923574ccbdc5d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "168ae725987ea4060e55a700d0a3cc8bf0931c26941e7e820c9923574ccbdc5d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Starly NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Starly\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489305
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784839
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "7a29b26ca99e3ad94834d58cdc0d10c84a91d90c6a85dfdcdc8cdcfff9a361b1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7a29b26ca99e3ad94834d58cdc0d10c84a91d90c6a85dfdcdc8cdcfff9a361b1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Starly NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import StarlyCard from 0xStarlyCard\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Starly\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StarlyCard.Collection>(from: /storage/starlyCardCollection) == nil {\n            let collection <- StarlyCard.createEmptyCollection()\n            acct.save(<-collection, to: /storage/starlyCardCollection)\n        }\n        if (acct.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection).borrow() == nil) {\n            acct.unlink(/public/starlyCardCollection)\n            acct.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection, target: /storage/starlyCardCollection)\n        }\n\n        if (acct.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/starlyCardCollection).borrow() == nil) {\n            acct.unlink(/private/starlyCardCollection)\n            acct.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/starlyCardCollection, target: /storage/starlyCardCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/starlyCardCollection)!\n        let collectionRef = acct\n            .getCapability(/public/starlyCardCollection)\n            .borrow<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@StarlyCard.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xStarlyCard": {
          "StarlyCard": {
            "mainnet": {
              "address": "0x5b82f21c0edf76e3",
              "contract": "StarlyCard",
              "fq_address": "A.0x5b82f21c0edf76e3.StarlyCard",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47489202
            },
            "testnet": {
              "address": "0x697d72a988a77070",
              "contract": "StarlyCard",
              "fq_address": "A.0x697d72a988a77070.StarlyCard",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 95784729
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489220
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784737
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489229
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784747
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47489234
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95784749
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489235
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784750
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489240
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784760
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "94eddee0ffcbc167d095232a8c7da1df450d4959ea28f020c07f77a388e656db": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "94eddee0ffcbc167d095232a8c7da1df450d4959ea28f020c07f77a388e656db",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Starly NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import StarlyCard from 0xStarlyCard\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Starly\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StarlyCard.Collection>(from: /storage/starlyCardCollection) == nil {\n            let collection <- StarlyCard.createEmptyCollection()\n            acct.save(<-collection, to: /storage/starlyCardCollection)\n            }\n        if (acct.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection).borrow() == nil) {\n            acct.unlink(/public/starlyCardCollection)\n            acct.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection, target: /storage/starlyCardCollection)\n        }\n\n        if (acct.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/starlyCardCollection).borrow() == nil) {\n            acct.unlink(/private/starlyCardCollection)\n            acct.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/starlyCardCollection, target: /storage/starlyCardCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/starlyCardCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xStarlyCard": {
          "StarlyCard": {
            "mainnet": {
              "address": "0x5b82f21c0edf76e3",
              "contract": "StarlyCard",
              "fq_address": "A.0x5b82f21c0edf76e3.StarlyCard",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47489260
            },
            "testnet": {
              "address": "0x697d72a988a77070",
              "contract": "StarlyCard",
              "fq_address": "A.0x697d72a988a77070.StarlyCard",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 95784797
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489278
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784805
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489287
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784814
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47489291
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95784817
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489292
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784818
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489296
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784828
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e7013553cf7f695ccc0febc73b4027458a00e4628a46f824e7df61bbc4294414": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e7013553cf7f695ccc0febc73b4027458a00e4628a46f824e7df61bbc4294414",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Starly NFTs"
          }
        }
      },
      "cadence": "import StarlyCard from 0xStarlyCard\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Starly\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&StarlyCard.Collection>(from: /storage/starlyCardCollection) == nil {\n      let collection <- StarlyCard.createEmptyCollection()\n      signer.save(<-collection, to: /storage/starlyCardCollection)\n    }\n    if (signer.getCapability<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection).borrow() == nil) {\n      signer.unlink(/public/starlyCardCollection)\n      signer.link<&StarlyCard.Collection{StarlyCard.StarlyCardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/starlyCardCollection, target: /storage/starlyCardCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xStarlyCard": {
          "StarlyCard": {
            "mainnet": {
              "address": "0x5b82f21c0edf76e3",
              "contract": "StarlyCard",
              "fq_address": "A.0x5b82f21c0edf76e3.StarlyCard",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47489155
            },
            "testnet": {
              "address": "0x697d72a988a77070",
              "contract": "StarlyCard",
              "fq_address": "A.0x697d72a988a77070.StarlyCard",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 95784675
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489172
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784682
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489180
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784692
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "542dcafb0f5ae4c34dd0d22cd3f843354569f920b8f994ff78203de0ac0bb70d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "542dcafb0f5ae4c34dd0d22cd3f843354569f920b8f994ff78203de0ac0bb70d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a StoreFrontTR NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: StoreFrontTR\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497078
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794034
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "261a8941bef03039ecbfd545a863def4df36354e0b58bd87bc192ba2b5184abe": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "261a8941bef03039ecbfd545a863def4df36354e0b58bd87bc192ba2b5184abe",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a StoreFrontTR NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import StoreFront from 0xStoreFront\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: StoreFrontTR\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StoreFront.Collection>(from: /storage/StoreFrontCollection) == nil {\n            let collection <- StoreFront.createEmptyCollection()\n            acct.save(<-collection, to: /storage/StoreFrontCollection)\n        }\n        if (acct.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection).borrow() == nil) {\n            acct.unlink(/public/StoreFrontCollection)\n            acct.link<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection, target: /storage/StoreFrontCollection)\n        }\n\n        if (acct.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/storeFrontNFTCollection).borrow() == nil) {\n            acct.unlink(/private/storeFrontNFTCollection)\n            acct.link<&StoreFront.Collection{StoreFront.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/storeFrontNFTCollection, target: /storage/StoreFrontCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/storeFrontNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/StoreFrontCollection)\n            .borrow<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@StoreFront.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xStoreFront": {
          "StoreFront": {
            "mainnet": {
              "address": "0x766b859539a6679b",
              "contract": "StoreFront",
              "fq_address": "A.0x766b859539a6679b.StoreFront",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47498710
            },
            "testnet": {
              "address": "0x34d2a0f0a4f8c6e8",
              "contract": "StoreFront",
              "fq_address": "A.0x34d2a0f0a4f8c6e8.StoreFront",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95795994
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498724
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796001
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498732
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796010
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47498737
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95796013
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498738
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796014
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498742
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796024
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "2c90cbe23ad4d4c1c1ac953a90a605ee10edb7d6e3cda16da7eee2c073b7b482": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2c90cbe23ad4d4c1c1ac953a90a605ee10edb7d6e3cda16da7eee2c073b7b482",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed StoreFrontTR NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import StoreFront from 0xStoreFront\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: StoreFrontTR\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StoreFront.Collection>(from: /storage/StoreFrontCollection) == nil {\n            let collection <- StoreFront.createEmptyCollection()\n            acct.save(<-collection, to: /storage/StoreFrontCollection)\n            }\n        if (acct.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection).borrow() == nil) {\n            acct.unlink(/public/StoreFrontCollection)\n            acct.link<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection, target: /storage/StoreFrontCollection)\n        }\n\n        if (acct.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/storeFrontNFTCollection).borrow() == nil) {\n            acct.unlink(/private/storeFrontNFTCollection)\n            acct.link<&StoreFront.Collection{StoreFront.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/storeFrontNFTCollection, target: /storage/StoreFrontCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/StoreFrontCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xStoreFront": {
          "StoreFront": {
            "mainnet": {
              "address": "0x766b859539a6679b",
              "contract": "StoreFront",
              "fq_address": "A.0x766b859539a6679b.StoreFront",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47498757
            },
            "testnet": {
              "address": "0x34d2a0f0a4f8c6e8",
              "contract": "StoreFront",
              "fq_address": "A.0x34d2a0f0a4f8c6e8.StoreFront",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95796054
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498772
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796061
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498779
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796070
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47498783
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95796072
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498784
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796073
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498791
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796083
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "eaba502382a810ae9e6b7303ab7ff1ffa3ea3dacc5ca8b3d9546d78c18ef5a60": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "eaba502382a810ae9e6b7303ab7ff1ffa3ea3dacc5ca8b3d9546d78c18ef5a60",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support StoreFrontTR NFTs"
          }
        }
      },
      "cadence": "import StoreFront from 0xStoreFront\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: StoreFrontTR\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&StoreFront.Collection>(from: /storage/StoreFrontCollection) == nil {\n      let collection <- StoreFront.createEmptyCollection()\n      signer.save(<-collection, to: /storage/StoreFrontCollection)\n    }\n    if (signer.getCapability<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection).borrow() == nil) {\n      signer.unlink(/public/StoreFrontCollection)\n      signer.link<&StoreFront.Collection{StoreFront.CollectionPublic,StoreFront.IRevealNFT,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StoreFrontCollection, target: /storage/StoreFrontCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xStoreFront": {
          "StoreFront": {
            "mainnet": {
              "address": "0x766b859539a6679b",
              "contract": "StoreFront",
              "fq_address": "A.0x766b859539a6679b.StoreFront",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47496955
            },
            "testnet": {
              "address": "0x34d2a0f0a4f8c6e8",
              "contract": "StoreFront",
              "fq_address": "A.0x34d2a0f0a4f8c6e8.StoreFront",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95793896
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496969
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95793903
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496977
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95793913
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "35766a1683711296cd9fd184f69819b0b5de8ae71cec96333a626f661b8ba6a6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "35766a1683711296cd9fd184f69819b0b5de8ae71cec96333a626f661b8ba6a6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a StartupyWGrze NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: StartupyWGrze\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489139
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "faaa581ba1bfb21ab9a60480a924246e18516bc044d6ff3039bb7eaeebb5141c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "faaa581ba1bfb21ab9a60480a924246e18516bc044d6ff3039bb7eaeebb5141c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a StartupyWGrze NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import StartupyWGrze from 0xStartupyWGrze\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: StartupyWGrze\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StartupyWGrze.Collection>(from: /storage/collecticoStartupyWGrzeCollection) == nil {\n            let collection <- StartupyWGrze.createEmptyCollection()\n            acct.save(<-collection, to: /storage/collecticoStartupyWGrzeCollection)\n        }\n        if (acct.getCapability<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/collecticoStartupyWGrzeCollection).borrow() == nil) {\n            acct.unlink(/public/collecticoStartupyWGrzeCollection)\n            acct.link<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/collecticoStartupyWGrzeCollection, target: /storage/collecticoStartupyWGrzeCollection)\n        }\n\n        if (acct.getCapability<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/collecticoStartupyWGrzeCollection).borrow() == nil) {\n            acct.unlink(/private/collecticoStartupyWGrzeCollection)\n            acct.link<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/collecticoStartupyWGrzeCollection, target: /storage/collecticoStartupyWGrzeCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/collecticoStartupyWGrzeCollection)!\n        let collectionRef = acct\n            .getCapability(/public/collecticoStartupyWGrzeCollection)\n            .borrow<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@StartupyWGrze.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xStartupyWGrze": {
          "StartupyWGrze": {
            "mainnet": {
              "address": "0xd26750aab3b6e413",
              "contract": "StartupyWGrze",
              "fq_address": "A.0xd26750aab3b6e413.StartupyWGrze",
              "pin": "1c1a5bfbd73b43de459ac489a35c3e919aae8a8e5f1f421a4ae025971b275804",
              "pin_block_height": 47489071
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489075
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489079
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47489079
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489080
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489085
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "99ca73009a24a8c1970c5ef8ab8e908dcd7714d9581b250b02d4e25f5354d510": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "99ca73009a24a8c1970c5ef8ab8e908dcd7714d9581b250b02d4e25f5354d510",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed StartupyWGrze NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import StartupyWGrze from 0xStartupyWGrze\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: StartupyWGrze\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StartupyWGrze.Collection>(from: /storage/collecticoStartupyWGrzeCollection) == nil {\n            let collection <- StartupyWGrze.createEmptyCollection()\n            acct.save(<-collection, to: /storage/collecticoStartupyWGrzeCollection)\n            }\n        if (acct.getCapability<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/collecticoStartupyWGrzeCollection).borrow() == nil) {\n            acct.unlink(/public/collecticoStartupyWGrzeCollection)\n            acct.link<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/collecticoStartupyWGrzeCollection, target: /storage/collecticoStartupyWGrzeCollection)\n        }\n\n        if (acct.getCapability<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/collecticoStartupyWGrzeCollection).borrow() == nil) {\n            acct.unlink(/private/collecticoStartupyWGrzeCollection)\n            acct.link<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/collecticoStartupyWGrzeCollection, target: /storage/collecticoStartupyWGrzeCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/collecticoStartupyWGrzeCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xStartupyWGrze": {
          "StartupyWGrze": {
            "mainnet": {
              "address": "0xd26750aab3b6e413",
              "contract": "StartupyWGrze",
              "fq_address": "A.0xd26750aab3b6e413.StartupyWGrze",
              "pin": "1c1a5bfbd73b43de459ac489a35c3e919aae8a8e5f1f421a4ae025971b275804",
              "pin_block_height": 47489121
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489124
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489128
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47489129
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489130
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489135
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "45f8630468ee1122bf2eeeb2639d09f9c38b04b2041b27a76fd6b78327c09c59": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "45f8630468ee1122bf2eeeb2639d09f9c38b04b2041b27a76fd6b78327c09c59",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support StartupyWGrze NFTs"
          }
        }
      },
      "cadence": "import StartupyWGrze from 0xStartupyWGrze\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: StartupyWGrze\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&StartupyWGrze.Collection>(from: /storage/collecticoStartupyWGrzeCollection) == nil {\n      let collection <- StartupyWGrze.createEmptyCollection()\n      signer.save(<-collection, to: /storage/collecticoStartupyWGrzeCollection)\n    }\n    if (signer.getCapability<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/collecticoStartupyWGrzeCollection).borrow() == nil) {\n      signer.unlink(/public/collecticoStartupyWGrzeCollection)\n      signer.link<&StartupyWGrze.Collection{StartupyWGrze.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/collecticoStartupyWGrzeCollection, target: /storage/collecticoStartupyWGrzeCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xStartupyWGrze": {
          "StartupyWGrze": {
            "mainnet": {
              "address": "0xd26750aab3b6e413",
              "contract": "StartupyWGrze",
              "fq_address": "A.0xd26750aab3b6e413.StartupyWGrze",
              "pin": "1c1a5bfbd73b43de459ac489a35c3e919aae8a8e5f1f421a4ae025971b275804",
              "pin_block_height": 47489024
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489027
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489031
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "2f6eb41aa136c6d346d875464802c15b7352a9e7d2c8fcabc27fa9a8a350a8f6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2f6eb41aa136c6d346d875464802c15b7352a9e7d2c8fcabc27fa9a8a350a8f6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a StanzClubCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: StanzClubCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509737
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809090
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "fcba820a56d93f06ef06d0dc40d7ca4bdde86d712310d90ddc5883114865c3f0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fcba820a56d93f06ef06d0dc40d7ca4bdde86d712310d90ddc5883114865c3f0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a StanzClubCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import StanzClub from 0xStanzClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: StanzClubCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StanzClub.Collection>(from: /storage/StanzClubCollection) == nil {\n            let collection <- StanzClub.createEmptyCollection()\n            acct.save(<-collection, to: /storage/StanzClubCollection)\n        }\n        if (acct.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection).borrow() == nil) {\n            acct.unlink(/public/StanzClubCollection)\n            acct.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection, target: /storage/StanzClubCollection)\n        }\n\n        if (acct.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/StanzClubCollection).borrow() == nil) {\n            acct.unlink(/private/StanzClubCollection)\n            acct.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/StanzClubCollection, target: /storage/StanzClubCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/StanzClubCollection)!\n        let collectionRef = acct\n            .getCapability(/public/StanzClubCollection)\n            .borrow<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@StanzClub.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xStanzClub": {
          "StanzClub": {
            "mainnet": {
              "address": "0xda421c78e2f7e0e7",
              "contract": "StanzClub",
              "fq_address": "A.0xda421c78e2f7e0e7.StanzClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509657
            },
            "testnet": {
              "address": "0x87dc938d9246d780",
              "contract": "StanzClub",
              "fq_address": "A.0x87dc938d9246d780.StanzClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95809002
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509669
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809009
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509675
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809018
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509682
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95809020
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509682
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809021
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509687
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809030
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "0e726a5750505ab6f00182d3ae6e00136601b9bb454205db47c51d1d27eed1e2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0e726a5750505ab6f00182d3ae6e00136601b9bb454205db47c51d1d27eed1e2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed StanzClubCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import StanzClub from 0xStanzClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: StanzClubCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&StanzClub.Collection>(from: /storage/StanzClubCollection) == nil {\n            let collection <- StanzClub.createEmptyCollection()\n            acct.save(<-collection, to: /storage/StanzClubCollection)\n            }\n        if (acct.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection).borrow() == nil) {\n            acct.unlink(/public/StanzClubCollection)\n            acct.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection, target: /storage/StanzClubCollection)\n        }\n\n        if (acct.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/StanzClubCollection).borrow() == nil) {\n            acct.unlink(/private/StanzClubCollection)\n            acct.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/StanzClubCollection, target: /storage/StanzClubCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/StanzClubCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xStanzClub": {
          "StanzClub": {
            "mainnet": {
              "address": "0xda421c78e2f7e0e7",
              "contract": "StanzClub",
              "fq_address": "A.0xda421c78e2f7e0e7.StanzClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509700
            },
            "testnet": {
              "address": "0x87dc938d9246d780",
              "contract": "StanzClub",
              "fq_address": "A.0x87dc938d9246d780.StanzClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95809049
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509711
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809057
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509719
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809067
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509723
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95809068
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509725
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809069
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509729
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809079
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "288fb46ba2ede05c30cd00fac1b38e715351ee087c764f974f8f01106e256f78": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "288fb46ba2ede05c30cd00fac1b38e715351ee087c764f974f8f01106e256f78",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support StanzClubCollection NFTs"
          }
        }
      },
      "cadence": "import StanzClub from 0xStanzClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: StanzClubCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&StanzClub.Collection>(from: /storage/StanzClubCollection) == nil {\n      let collection <- StanzClub.createEmptyCollection()\n      signer.save(<-collection, to: /storage/StanzClubCollection)\n    }\n    if (signer.getCapability<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection).borrow() == nil) {\n      signer.unlink(/public/StanzClubCollection)\n      signer.link<&StanzClub.Collection{StanzClub.StanzClubCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/StanzClubCollection, target: /storage/StanzClubCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xStanzClub": {
          "StanzClub": {
            "mainnet": {
              "address": "0xda421c78e2f7e0e7",
              "contract": "StanzClub",
              "fq_address": "A.0xda421c78e2f7e0e7.StanzClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509627
            },
            "testnet": {
              "address": "0x87dc938d9246d780",
              "contract": "StanzClub",
              "fq_address": "A.0x87dc938d9246d780.StanzClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95808966
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509640
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808973
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509645
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808982
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "c162dfbad6d54e95e109586b1f6e888e589263ff988d39a5030af681cfb460bf": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c162dfbad6d54e95e109586b1f6e888e589263ff988d39a5030af681cfb460bf",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SportsIconCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SportsIconCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499252
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796623
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "99707d39df213c705dbcee17270f839dc7e757ed75f634329162ab117548c3d6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "99707d39df213c705dbcee17270f839dc7e757ed75f634329162ab117548c3d6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a SportsIconCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SportsIconCollectible from 0xSportsIconCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SportsIconCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SportsIconCollectible.Collection>(from: /storage/sportsIconCollectibleCollection) == nil {\n            let collection <- SportsIconCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/sportsIconCollectibleCollection)\n        }\n        if (acct.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/sportsIconCollectibleCollection)\n            acct.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n        }\n\n        if (acct.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sportsIconCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/sportsIconCollectibleCollection)\n            acct.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/sportsIconCollectibleCollection)!\n        let collectionRef = acct\n            .getCapability(/public/sportsIconCollectibleCollection)\n            .borrow<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SportsIconCollectible.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSportsIconCollectible": {
          "SportsIconCollectible": {
            "mainnet": {
              "address": "0x8de96244f54db422",
              "contract": "SportsIconCollectible",
              "fq_address": "A.0x8de96244f54db422.SportsIconCollectible",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47499165
            },
            "testnet": {
              "address": "0xaf4725f17cc7afdb",
              "contract": "SportsIconCollectible",
              "fq_address": "A.0xaf4725f17cc7afdb.SportsIconCollectible",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95796527
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499180
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796534
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499185
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796544
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499190
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95796546
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499193
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796547
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499197
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796557
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "7481f5707f2ceb507c72270587e9232584ee217dc838f58cdc1aac66823961c3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7481f5707f2ceb507c72270587e9232584ee217dc838f58cdc1aac66823961c3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed SportsIconCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SportsIconCollectible from 0xSportsIconCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SportsIconCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SportsIconCollectible.Collection>(from: /storage/sportsIconCollectibleCollection) == nil {\n            let collection <- SportsIconCollectible.createEmptyCollection()\n            acct.save(<-collection, to: /storage/sportsIconCollectibleCollection)\n            }\n        if (acct.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection).borrow() == nil) {\n            acct.unlink(/public/sportsIconCollectibleCollection)\n            acct.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n        }\n\n        if (acct.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sportsIconCollectibleCollection).borrow() == nil) {\n            acct.unlink(/private/sportsIconCollectibleCollection)\n            acct.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/sportsIconCollectibleCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSportsIconCollectible": {
          "SportsIconCollectible": {
            "mainnet": {
              "address": "0x8de96244f54db422",
              "contract": "SportsIconCollectible",
              "fq_address": "A.0x8de96244f54db422.SportsIconCollectible",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47499212
            },
            "testnet": {
              "address": "0xaf4725f17cc7afdb",
              "contract": "SportsIconCollectible",
              "fq_address": "A.0xaf4725f17cc7afdb.SportsIconCollectible",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95796583
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499224
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796590
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499232
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796599
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499237
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95796602
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499238
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796603
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499244
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796612
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "89b5d179d0ecf70292763c9a15110eca9fdd32eff28e958e36564fcd04678903": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "89b5d179d0ecf70292763c9a15110eca9fdd32eff28e958e36564fcd04678903",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support SportsIconCollection NFTs"
          }
        }
      },
      "cadence": "import SportsIconCollectible from 0xSportsIconCollectible\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SportsIconCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SportsIconCollectible.Collection>(from: /storage/sportsIconCollectibleCollection) == nil {\n      let collection <- SportsIconCollectible.createEmptyCollection()\n      signer.save(<-collection, to: /storage/sportsIconCollectibleCollection)\n    }\n    if (signer.getCapability<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection).borrow() == nil) {\n      signer.unlink(/public/sportsIconCollectibleCollection)\n      signer.link<&SportsIconCollectible.Collection{SportsIconCollectible.CollectibleCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sportsIconCollectibleCollection, target: /storage/sportsIconCollectibleCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSportsIconCollectible": {
          "SportsIconCollectible": {
            "mainnet": {
              "address": "0x8de96244f54db422",
              "contract": "SportsIconCollectible",
              "fq_address": "A.0x8de96244f54db422.SportsIconCollectible",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47499127
            },
            "testnet": {
              "address": "0xaf4725f17cc7afdb",
              "contract": "SportsIconCollectible",
              "fq_address": "A.0xaf4725f17cc7afdb.SportsIconCollectible",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95796483
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499142
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796491
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499148
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796500
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "453ccb6f4262e7769368aef0848b0d3d120f6f08d8f793e5bf051b3ac41b19ff": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "453ccb6f4262e7769368aef0848b0d3d120f6f08d8f793e5bf051b3ac41b19ff",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SlushTicketNFTs NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SlushTicketNFTs\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507475
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "30fcd12c64b4b277952fb7350e4b16a746f25e877e9b369cf302e4a6908975f6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "30fcd12c64b4b277952fb7350e4b16a746f25e877e9b369cf302e4a6908975f6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a SlushTicketNFTs NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Slush from 0xSlush\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SlushTicketNFTs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Slush.Collection>(from: /storage/SlushCollection) == nil {\n            let collection <- Slush.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SlushCollection)\n        }\n        if (acct.getCapability<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SlushCollection).borrow() == nil) {\n            acct.unlink(/public/SlushCollection)\n            acct.link<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SlushCollection, target: /storage/SlushCollection)\n        }\n\n        if (acct.getCapability<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SlushCollection).borrow() == nil) {\n            acct.unlink(/private/SlushCollection)\n            acct.link<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SlushCollection, target: /storage/SlushCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SlushCollection)!\n        let collectionRef = acct\n            .getCapability(/public/SlushCollection)\n            .borrow<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Slush.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSlush": {
          "Slush": {
            "mainnet": {
              "address": "0x5b17b74a0bf1fb10",
              "contract": "Slush",
              "fq_address": "A.0x5b17b74a0bf1fb10.Slush",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507437
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507439
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507444
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507446
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507446
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507449
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "350452a2d727b8e1511314f6fa433f075fbcae8733e6031f597cabb4ea3aa31c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "350452a2d727b8e1511314f6fa433f075fbcae8733e6031f597cabb4ea3aa31c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed SlushTicketNFTs NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Slush from 0xSlush\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SlushTicketNFTs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Slush.Collection>(from: /storage/SlushCollection) == nil {\n            let collection <- Slush.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SlushCollection)\n            }\n        if (acct.getCapability<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SlushCollection).borrow() == nil) {\n            acct.unlink(/public/SlushCollection)\n            acct.link<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SlushCollection, target: /storage/SlushCollection)\n        }\n\n        if (acct.getCapability<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SlushCollection).borrow() == nil) {\n            acct.unlink(/private/SlushCollection)\n            acct.link<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SlushCollection, target: /storage/SlushCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SlushCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSlush": {
          "Slush": {
            "mainnet": {
              "address": "0x5b17b74a0bf1fb10",
              "contract": "Slush",
              "fq_address": "A.0x5b17b74a0bf1fb10.Slush",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507457
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507460
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507465
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507466
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507466
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507470
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "d6f23f6032b012e5ae5da4f40eb6b65a6b7a4912111fc77ab2e2fae2607034b8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d6f23f6032b012e5ae5da4f40eb6b65a6b7a4912111fc77ab2e2fae2607034b8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support SlushTicketNFTs NFTs"
          }
        }
      },
      "cadence": "import Slush from 0xSlush\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SlushTicketNFTs\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Slush.Collection>(from: /storage/SlushCollection) == nil {\n      let collection <- Slush.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SlushCollection)\n    }\n    if (signer.getCapability<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SlushCollection).borrow() == nil) {\n      signer.unlink(/public/SlushCollection)\n      signer.link<&Slush.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SlushCollection, target: /storage/SlushCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSlush": {
          "Slush": {
            "mainnet": {
              "address": "0x5b17b74a0bf1fb10",
              "contract": "Slush",
              "fq_address": "A.0x5b17b74a0bf1fb10.Slush",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47507422
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507424
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507428
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "86c3d69c0220f2570ef0c706d4ab55ddae22d9f47a63ebfaedc0e1425b577bc7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "86c3d69c0220f2570ef0c706d4ab55ddae22d9f47a63ebfaedc0e1425b577bc7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SoulMadePack NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SoulMadePack\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513015
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95812945
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "bbf05bd911fc3804d068f57d872b1174807c2c961eb25f6691a4dca319fc756d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "bbf05bd911fc3804d068f57d872b1174807c2c961eb25f6691a4dca319fc756d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SoulMadeMain NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SoulMadeMain\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507695
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806664
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6175c7888e8dbf9c657136674f5e4f9bbe6c4049a33db8650ef5997709117972": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6175c7888e8dbf9c657136674f5e4f9bbe6c4049a33db8650ef5997709117972",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SoulMadeComponent NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SoulMadeComponent\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501438
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799231
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "da8cbe0159036cf1641215a9620ff91b6d124375f9d1ef313f9a7194b21226cf": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "da8cbe0159036cf1641215a9620ff91b6d124375f9d1ef313f9a7194b21226cf",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a ShebaHopeGrows NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: ShebaHopeGrows\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507136
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "29643784a72f2bda49d9bd8e424b3234495d99301294140469ac776a72ac26fb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "29643784a72f2bda49d9bd8e424b3234495d99301294140469ac776a72ac26fb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SequelDigitalArt NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SequelDigitalArt\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493647
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789960
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "5e049ce3daf98ec65206bfbb4b566add59716548a6f5e7f6ec86fa7e4dc837bc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5e049ce3daf98ec65206bfbb4b566add59716548a6f5e7f6ec86fa7e4dc837bc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a SequelDigitalArt NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DigitalArt from 0xDigitalArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SequelDigitalArt\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DigitalArt.Collection>(from: /storage/sequelDigitalArtCollection) == nil {\n            let collection <- DigitalArt.createEmptyCollection()\n            acct.save(<-collection, to: /storage/sequelDigitalArtCollection)\n        }\n        if (acct.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection).borrow() == nil) {\n            acct.unlink(/public/sequelDigitalArtCollection)\n            acct.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n        }\n\n        if (acct.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sequelDigitalArtCollection).borrow() == nil) {\n            acct.unlink(/private/sequelDigitalArtCollection)\n            acct.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/sequelDigitalArtCollection)!\n        let collectionRef = acct\n            .getCapability(/public/sequelDigitalArtCollection)\n            .borrow<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DigitalArt.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDigitalArt": {
          "DigitalArt": {
            "mainnet": {
              "address": "0x3cb7ceeb625a600a",
              "contract": "DigitalArt",
              "fq_address": "A.0x3cb7ceeb625a600a.DigitalArt",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47498599
            },
            "testnet": {
              "address": "0x745b085dafdd4fc0",
              "contract": "DigitalArt",
              "fq_address": "A.0x745b085dafdd4fc0.DigitalArt",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95795865
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498616
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95795872
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498624
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95795881
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47498629
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95795884
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498630
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95795885
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498635
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95795895
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "70791b8d0c259fcaad9656daa43a787927efb90bcbc7a508286bdc8a2ccf7c0d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "70791b8d0c259fcaad9656daa43a787927efb90bcbc7a508286bdc8a2ccf7c0d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed SequelDigitalArt NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DigitalArt from 0xDigitalArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SequelDigitalArt\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DigitalArt.Collection>(from: /storage/sequelDigitalArtCollection) == nil {\n            let collection <- DigitalArt.createEmptyCollection()\n            acct.save(<-collection, to: /storage/sequelDigitalArtCollection)\n            }\n        if (acct.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection).borrow() == nil) {\n            acct.unlink(/public/sequelDigitalArtCollection)\n            acct.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n        }\n\n        if (acct.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sequelDigitalArtCollection).borrow() == nil) {\n            acct.unlink(/private/sequelDigitalArtCollection)\n            acct.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/sequelDigitalArtCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDigitalArt": {
          "DigitalArt": {
            "mainnet": {
              "address": "0x3cb7ceeb625a600a",
              "contract": "DigitalArt",
              "fq_address": "A.0x3cb7ceeb625a600a.DigitalArt",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47498656
            },
            "testnet": {
              "address": "0x745b085dafdd4fc0",
              "contract": "DigitalArt",
              "fq_address": "A.0x745b085dafdd4fc0.DigitalArt",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95795934
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498675
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95795942
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498683
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95795951
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47498687
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95795953
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498689
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95795955
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498693
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95795964
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e034f1505d4851229cd060e26eb7acc485444160f2747480bb613bc855b3cc79": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e034f1505d4851229cd060e26eb7acc485444160f2747480bb613bc855b3cc79",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support SequelDigitalArt NFTs"
          }
        }
      },
      "cadence": "import DigitalArt from 0xDigitalArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SequelDigitalArt\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DigitalArt.Collection>(from: /storage/sequelDigitalArtCollection) == nil {\n      let collection <- DigitalArt.createEmptyCollection()\n      signer.save(<-collection, to: /storage/sequelDigitalArtCollection)\n    }\n    if (signer.getCapability<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection).borrow() == nil) {\n      signer.unlink(/public/sequelDigitalArtCollection)\n      signer.link<&DigitalArt.Collection{DigitalArt.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/sequelDigitalArtCollection, target: /storage/sequelDigitalArtCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDigitalArt": {
          "DigitalArt": {
            "mainnet": {
              "address": "0x3cb7ceeb625a600a",
              "contract": "DigitalArt",
              "fq_address": "A.0x3cb7ceeb625a600a.DigitalArt",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47498553
            },
            "testnet": {
              "address": "0x745b085dafdd4fc0",
              "contract": "DigitalArt",
              "fq_address": "A.0x745b085dafdd4fc0.DigitalArt",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95795809
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498571
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95795817
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498578
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95795826
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "26ee9d85a9e4277afbd8b46d1766736aeebb4a67b6beb4a97d1f0c97d23443ec": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "26ee9d85a9e4277afbd8b46d1766736aeebb4a67b6beb4a97d1f0c97d23443ec",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SeedsOfHappinessGenesis NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SeedsOfHappinessGenesis\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493192
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "790472bf9aacff3caec1ca96a338cf527381e67da9efc3c9b9c9f8ee68f61389": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "790472bf9aacff3caec1ca96a338cf527381e67da9efc3c9b9c9f8ee68f61389",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a SeedsOfHappinessGenesis NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SeedsOfHappinessGenesis from 0xSeedsOfHappinessGenesis\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SeedsOfHappinessGenesis\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SeedsOfHappinessGenesis.Collection>(from: /storage/SeedsOfHappinessGenesis_Collection) == nil {\n            let collection <- SeedsOfHappinessGenesis.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SeedsOfHappinessGenesis_Collection)\n        }\n        if (acct.getCapability<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SeedsOfHappinessGenesis_Collection).borrow() == nil) {\n            acct.unlink(/public/SeedsOfHappinessGenesis_Collection)\n            acct.link<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SeedsOfHappinessGenesis_Collection, target: /storage/SeedsOfHappinessGenesis_Collection)\n        }\n\n        if (acct.getCapability<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SeedsOfHappinessGenesis_Collection).borrow() == nil) {\n            acct.unlink(/private/SeedsOfHappinessGenesis_Collection)\n            acct.link<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SeedsOfHappinessGenesis_Collection, target: /storage/SeedsOfHappinessGenesis_Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SeedsOfHappinessGenesis_Collection)!\n        let collectionRef = acct\n            .getCapability(/public/SeedsOfHappinessGenesis_Collection)\n            .borrow<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SeedsOfHappinessGenesis.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSeedsOfHappinessGenesis": {
          "SeedsOfHappinessGenesis": {
            "mainnet": {
              "address": "0x52acb3b399df11fc",
              "contract": "SeedsOfHappinessGenesis",
              "fq_address": "A.0x52acb3b399df11fc.SeedsOfHappinessGenesis",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47493147
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493150
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493154
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493155
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493155
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493160
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "52aa96e60cf221834a7d3a011c3632c7282aac3ec008275703e6c96cbdbb670c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "52aa96e60cf221834a7d3a011c3632c7282aac3ec008275703e6c96cbdbb670c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed SeedsOfHappinessGenesis NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SeedsOfHappinessGenesis from 0xSeedsOfHappinessGenesis\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SeedsOfHappinessGenesis\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SeedsOfHappinessGenesis.Collection>(from: /storage/SeedsOfHappinessGenesis_Collection) == nil {\n            let collection <- SeedsOfHappinessGenesis.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SeedsOfHappinessGenesis_Collection)\n            }\n        if (acct.getCapability<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SeedsOfHappinessGenesis_Collection).borrow() == nil) {\n            acct.unlink(/public/SeedsOfHappinessGenesis_Collection)\n            acct.link<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SeedsOfHappinessGenesis_Collection, target: /storage/SeedsOfHappinessGenesis_Collection)\n        }\n\n        if (acct.getCapability<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SeedsOfHappinessGenesis_Collection).borrow() == nil) {\n            acct.unlink(/private/SeedsOfHappinessGenesis_Collection)\n            acct.link<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SeedsOfHappinessGenesis_Collection, target: /storage/SeedsOfHappinessGenesis_Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SeedsOfHappinessGenesis_Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSeedsOfHappinessGenesis": {
          "SeedsOfHappinessGenesis": {
            "mainnet": {
              "address": "0x52acb3b399df11fc",
              "contract": "SeedsOfHappinessGenesis",
              "fq_address": "A.0x52acb3b399df11fc.SeedsOfHappinessGenesis",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47493175
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493178
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493182
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493183
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493183
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493188
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f863840a355d82acf557755958e00e04f17d0ab47616d4ac430f37fae0a9dc29": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f863840a355d82acf557755958e00e04f17d0ab47616d4ac430f37fae0a9dc29",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support SeedsOfHappinessGenesis NFTs"
          }
        }
      },
      "cadence": "import SeedsOfHappinessGenesis from 0xSeedsOfHappinessGenesis\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SeedsOfHappinessGenesis\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SeedsOfHappinessGenesis.Collection>(from: /storage/SeedsOfHappinessGenesis_Collection) == nil {\n      let collection <- SeedsOfHappinessGenesis.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SeedsOfHappinessGenesis_Collection)\n    }\n    if (signer.getCapability<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SeedsOfHappinessGenesis_Collection).borrow() == nil) {\n      signer.unlink(/public/SeedsOfHappinessGenesis_Collection)\n      signer.link<&SeedsOfHappinessGenesis.Collection{SeedsOfHappinessGenesis.SeedsOfHappinessGenesisCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SeedsOfHappinessGenesis_Collection, target: /storage/SeedsOfHappinessGenesis_Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSeedsOfHappinessGenesis": {
          "SeedsOfHappinessGenesis": {
            "mainnet": {
              "address": "0x52acb3b399df11fc",
              "contract": "SeedsOfHappinessGenesis",
              "fq_address": "A.0x52acb3b399df11fc.SeedsOfHappinessGenesis",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47493126
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493129
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493133
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "0213d885d1fe23b51dbc80f46c9700d0ea88896242e5722d99960f451913e3b7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0213d885d1fe23b51dbc80f46c9700d0ea88896242e5722d99960f451913e3b7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SeussiblesNFTCollectionbyTibles NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503038
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801113
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "fede0e6ccbbff1f8f91852ecfec1d52a3f37286a6ea0632f48006a779111f198": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fede0e6ccbbff1f8f91852ecfec1d52a3f37286a6ea0632f48006a779111f198",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a SeussiblesNFTCollectionbyTibles NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DrSeuss from 0xDrSeuss\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DrSeuss.Collection>(from: /storage/TiblesDrSeussCollection) == nil {\n            let collection <- DrSeuss.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TiblesDrSeussCollection)\n        }\n        if (acct.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection).borrow() == nil) {\n            acct.unlink(/public/TiblesDrSeussCollection)\n            acct.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection, target: /storage/TiblesDrSeussCollection)\n        }\n\n        if (acct.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DrSeussCollection).borrow() == nil) {\n            acct.unlink(/private/DrSeussCollection)\n            acct.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DrSeussCollection, target: /storage/TiblesDrSeussCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DrSeussCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TiblesDrSeussCollection)\n            .borrow<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DrSeuss.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTiblesNFT": {
          "TiblesNFT": {
            "testnet": {
              "address": "0xe93c412c964bdf40",
              "contract": "TiblesNFT",
              "fq_address": "A.0xe93c412c964bdf40.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801025
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801029
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801033
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95801035
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801035
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801040
            }
          }
        },
        "0xDrSeuss": {
          "DrSeuss": {
            "testnet": {
              "address": "0xff68241f0f4fd521",
              "contract": "DrSeuss",
              "fq_address": "A.0xff68241f0f4fd521.DrSeuss",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95801051
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b0f8cf1a11a7ceea2547b8b3c18db55f50576391c6e0dcc4f4427321be6e7be5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b0f8cf1a11a7ceea2547b8b3c18db55f50576391c6e0dcc4f4427321be6e7be5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a SeussiblesNFTCollectionbyTibles NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Seussibles from 0xSeussibles\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Seussibles.Collection>(from: /storage/TiblesSeussiblesCollection) == nil {\n            let collection <- Seussibles.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TiblesSeussiblesCollection)\n        }\n        if (acct.getCapability<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesSeussiblesCollection).borrow() == nil) {\n            acct.unlink(/public/TiblesSeussiblesCollection)\n            acct.link<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesSeussiblesCollection, target: /storage/TiblesSeussiblesCollection)\n        }\n\n        if (acct.getCapability<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/SeussiblesCollection).borrow() == nil) {\n            acct.unlink(/private/SeussiblesCollection)\n            acct.link<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/SeussiblesCollection, target: /storage/TiblesSeussiblesCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SeussiblesCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TiblesSeussiblesCollection)\n            .borrow<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Seussibles.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSeussibles": {
          "Seussibles": {
            "mainnet": {
              "address": "0x321d8fcde05f6e8c",
              "contract": "Seussibles",
              "fq_address": "A.0x321d8fcde05f6e8c.Seussibles",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47502948
            }
          }
        },
        "0xTiblesNFT": {
          "TiblesNFT": {
            "mainnet": {
              "address": "0x5cdeb067561defcb",
              "contract": "TiblesNFT",
              "fq_address": "A.0x5cdeb067561defcb.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502951
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502954
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502960
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502961
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502962
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502967
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "aa000535c747f11de16573bf7631fde7ec179ac1ce17fe65f96a03ea770a84fc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "aa000535c747f11de16573bf7631fde7ec179ac1ce17fe65f96a03ea770a84fc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed SeussiblesNFTCollectionbyTibles NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DrSeuss from 0xDrSeuss\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DrSeuss.Collection>(from: /storage/TiblesDrSeussCollection) == nil {\n            let collection <- DrSeuss.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TiblesDrSeussCollection)\n            }\n        if (acct.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection).borrow() == nil) {\n            acct.unlink(/public/TiblesDrSeussCollection)\n            acct.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection, target: /storage/TiblesDrSeussCollection)\n        }\n\n        if (acct.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DrSeussCollection).borrow() == nil) {\n            acct.unlink(/private/DrSeussCollection)\n            acct.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DrSeussCollection, target: /storage/TiblesDrSeussCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TiblesDrSeussCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTiblesNFT": {
          "TiblesNFT": {
            "testnet": {
              "address": "0xe93c412c964bdf40",
              "contract": "TiblesNFT",
              "fq_address": "A.0xe93c412c964bdf40.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801078
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801081
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801086
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95801087
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801087
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801092
            }
          }
        },
        "0xDrSeuss": {
          "DrSeuss": {
            "testnet": {
              "address": "0xff68241f0f4fd521",
              "contract": "DrSeuss",
              "fq_address": "A.0xff68241f0f4fd521.DrSeuss",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95801103
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "956f62dd2a72860623053b7e5cc9598a0742f1b8cada086d5b590e1fbc7424ab": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "956f62dd2a72860623053b7e5cc9598a0742f1b8cada086d5b590e1fbc7424ab",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed SeussiblesNFTCollectionbyTibles NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Seussibles from 0xSeussibles\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Seussibles.Collection>(from: /storage/TiblesSeussiblesCollection) == nil {\n            let collection <- Seussibles.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TiblesSeussiblesCollection)\n            }\n        if (acct.getCapability<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesSeussiblesCollection).borrow() == nil) {\n            acct.unlink(/public/TiblesSeussiblesCollection)\n            acct.link<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesSeussiblesCollection, target: /storage/TiblesSeussiblesCollection)\n        }\n\n        if (acct.getCapability<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/SeussiblesCollection).borrow() == nil) {\n            acct.unlink(/private/SeussiblesCollection)\n            acct.link<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/SeussiblesCollection, target: /storage/TiblesSeussiblesCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TiblesSeussiblesCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSeussibles": {
          "Seussibles": {
            "mainnet": {
              "address": "0x321d8fcde05f6e8c",
              "contract": "Seussibles",
              "fq_address": "A.0x321d8fcde05f6e8c.Seussibles",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47502999
            }
          }
        },
        "0xTiblesNFT": {
          "TiblesNFT": {
            "mainnet": {
              "address": "0x5cdeb067561defcb",
              "contract": "TiblesNFT",
              "fq_address": "A.0x5cdeb067561defcb.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502999
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47503004
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503007
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47503007
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47503008
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503012
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "21a06594d9b250c9bf35ac8c6cb059015cc205d0fc97f40518cfc079bbdc3570": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "21a06594d9b250c9bf35ac8c6cb059015cc205d0fc97f40518cfc079bbdc3570",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support SeussiblesNFTCollectionbyTibles NFTs"
          }
        }
      },
      "cadence": "import DrSeuss from 0xDrSeuss\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DrSeuss.Collection>(from: /storage/TiblesDrSeussCollection) == nil {\n      let collection <- DrSeuss.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TiblesDrSeussCollection)\n    }\n    if (signer.getCapability<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection).borrow() == nil) {\n      signer.unlink(/public/TiblesDrSeussCollection)\n      signer.link<&DrSeuss.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesDrSeussCollection, target: /storage/TiblesDrSeussCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTiblesNFT": {
          "TiblesNFT": {
            "testnet": {
              "address": "0xe93c412c964bdf40",
              "contract": "TiblesNFT",
              "fq_address": "A.0xe93c412c964bdf40.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95800974
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95800978
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95800983
            }
          }
        },
        "0xDrSeuss": {
          "DrSeuss": {
            "testnet": {
              "address": "0xff68241f0f4fd521",
              "contract": "DrSeuss",
              "fq_address": "A.0xff68241f0f4fd521.DrSeuss",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95800994
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "eab4494c429bb6fc8c424b3909785df7d035db0eacf16026ef9fa9b5125e6dc9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "eab4494c429bb6fc8c424b3909785df7d035db0eacf16026ef9fa9b5125e6dc9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support SeussiblesNFTCollectionbyTibles NFTs"
          }
        }
      },
      "cadence": "import Seussibles from 0xSeussibles\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SeussiblesNFTCollectionbyTibles\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Seussibles.Collection>(from: /storage/TiblesSeussiblesCollection) == nil {\n      let collection <- Seussibles.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TiblesSeussiblesCollection)\n    }\n    if (signer.getCapability<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesSeussiblesCollection).borrow() == nil) {\n      signer.unlink(/public/TiblesSeussiblesCollection)\n      signer.link<&Seussibles.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesSeussiblesCollection, target: /storage/TiblesSeussiblesCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSeussibles": {
          "Seussibles": {
            "mainnet": {
              "address": "0x321d8fcde05f6e8c",
              "contract": "Seussibles",
              "fq_address": "A.0x321d8fcde05f6e8c.Seussibles",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47502915
            }
          }
        },
        "0xTiblesNFT": {
          "TiblesNFT": {
            "mainnet": {
              "address": "0x5cdeb067561defcb",
              "contract": "TiblesNFT",
              "fq_address": "A.0x5cdeb067561defcb.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502915
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502919
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502923
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "aff0b8b384bd496f5a992538fa80ed2f3a843a83f2bd36c37b9a7bf174842ef1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "aff0b8b384bd496f5a992538fa80ed2f3a843a83f2bd36c37b9a7bf174842ef1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a SNKRHUDNFT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: SNKRHUDNFT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508142
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "e50359a3457746c60efa8639bb5f9d50f527a74c15e7dbe16f373e4bd06a3841": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e50359a3457746c60efa8639bb5f9d50f527a74c15e7dbe16f373e4bd06a3841",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a SNKRHUDNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SNKRHUDNFT from 0xSNKRHUDNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: SNKRHUDNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SNKRHUDNFT.Collection>(from: /storage/SNKRHUDNFTCollection) == nil {\n            let collection <- SNKRHUDNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SNKRHUDNFTCollection)\n        }\n        if (acct.getCapability<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SNKRHUDNFTCollection).borrow() == nil) {\n            acct.unlink(/public/SNKRHUDNFTCollection)\n            acct.link<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SNKRHUDNFTCollection, target: /storage/SNKRHUDNFTCollection)\n        }\n\n        if (acct.getCapability<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SNKRHUDNFTCollection).borrow() == nil) {\n            acct.unlink(/private/SNKRHUDNFTCollection)\n            acct.link<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SNKRHUDNFTCollection, target: /storage/SNKRHUDNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SNKRHUDNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/SNKRHUDNFTCollection)\n            .borrow<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SNKRHUDNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSNKRHUDNFT": {
          "SNKRHUDNFT": {
            "mainnet": {
              "address": "0x80af1db15aa6535a",
              "contract": "SNKRHUDNFT",
              "fq_address": "A.0x80af1db15aa6535a.SNKRHUDNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508105
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508107
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508112
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508112
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508112
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508116
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "9556e927e8d60c9996a9051291dd3958574688dce865e44ae600ef475c1c6f7e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9556e927e8d60c9996a9051291dd3958574688dce865e44ae600ef475c1c6f7e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed SNKRHUDNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SNKRHUDNFT from 0xSNKRHUDNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: SNKRHUDNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SNKRHUDNFT.Collection>(from: /storage/SNKRHUDNFTCollection) == nil {\n            let collection <- SNKRHUDNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SNKRHUDNFTCollection)\n            }\n        if (acct.getCapability<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SNKRHUDNFTCollection).borrow() == nil) {\n            acct.unlink(/public/SNKRHUDNFTCollection)\n            acct.link<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SNKRHUDNFTCollection, target: /storage/SNKRHUDNFTCollection)\n        }\n\n        if (acct.getCapability<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SNKRHUDNFTCollection).borrow() == nil) {\n            acct.unlink(/private/SNKRHUDNFTCollection)\n            acct.link<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SNKRHUDNFTCollection, target: /storage/SNKRHUDNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SNKRHUDNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSNKRHUDNFT": {
          "SNKRHUDNFT": {
            "mainnet": {
              "address": "0x80af1db15aa6535a",
              "contract": "SNKRHUDNFT",
              "fq_address": "A.0x80af1db15aa6535a.SNKRHUDNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508125
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508129
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508132
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508133
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508134
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508138
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "df814b7c297b4405f188dde2f4cbd363a9126d5c01680a24b547ec617e686793": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "df814b7c297b4405f188dde2f4cbd363a9126d5c01680a24b547ec617e686793",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support SNKRHUDNFT NFTs"
          }
        }
      },
      "cadence": "import SNKRHUDNFT from 0xSNKRHUDNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: SNKRHUDNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SNKRHUDNFT.Collection>(from: /storage/SNKRHUDNFTCollection) == nil {\n      let collection <- SNKRHUDNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SNKRHUDNFTCollection)\n    }\n    if (signer.getCapability<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SNKRHUDNFTCollection).borrow() == nil) {\n      signer.unlink(/public/SNKRHUDNFTCollection)\n      signer.link<&SNKRHUDNFT.Collection{SNKRHUDNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SNKRHUDNFTCollection, target: /storage/SNKRHUDNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSNKRHUDNFT": {
          "SNKRHUDNFT": {
            "mainnet": {
              "address": "0x80af1db15aa6535a",
              "contract": "SNKRHUDNFT",
              "fq_address": "A.0x80af1db15aa6535a.SNKRHUDNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508087
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508090
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508095
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "6433cea02d04b9a1cd1b6e6750911a10de26a1d1d36ca09fbce291ed385b12da": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6433cea02d04b9a1cd1b6e6750911a10de26a1d1d36ca09fbce291ed385b12da",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a RogueBunnies NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: RogueBunnies\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509165
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "a902f2799b156cf5746aec7347a3755a45226ba5d1644e900abf0304e5c72285": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a902f2799b156cf5746aec7347a3755a45226ba5d1644e900abf0304e5c72285",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a RogueBunnies NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import RogueBunnies_NFT from 0xRogueBunnies_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: RogueBunnies\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&RogueBunnies_NFT.Collection>(from: /storage/RogueBunnies_NFTCollection) == nil {\n            let collection <- RogueBunnies_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/RogueBunnies_NFTCollection)\n        }\n        if (acct.getCapability<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RogueBunnies_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/RogueBunnies_NFTCollection)\n            acct.link<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RogueBunnies_NFTCollection, target: /storage/RogueBunnies_NFTCollection)\n        }\n\n        if (acct.getCapability<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RogueBunnies_NFT).borrow() == nil) {\n            acct.unlink(/private/RogueBunnies_NFT)\n            acct.link<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RogueBunnies_NFT, target: /storage/RogueBunnies_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/RogueBunnies_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/RogueBunnies_NFTCollection)\n            .borrow<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@RogueBunnies_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xRogueBunnies_NFT": {
          "RogueBunnies_NFT": {
            "mainnet": {
              "address": "0x396646f110afb2e6",
              "contract": "RogueBunnies_NFT",
              "fq_address": "A.0x396646f110afb2e6.RogueBunnies_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509127
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509131
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509134
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509135
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509135
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509140
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "6710c30afb72b1fc97a2b04ca0aec8891f07563cb8324926d058178795d74758": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6710c30afb72b1fc97a2b04ca0aec8891f07563cb8324926d058178795d74758",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed RogueBunnies NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import RogueBunnies_NFT from 0xRogueBunnies_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: RogueBunnies\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&RogueBunnies_NFT.Collection>(from: /storage/RogueBunnies_NFTCollection) == nil {\n            let collection <- RogueBunnies_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/RogueBunnies_NFTCollection)\n            }\n        if (acct.getCapability<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RogueBunnies_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/RogueBunnies_NFTCollection)\n            acct.link<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RogueBunnies_NFTCollection, target: /storage/RogueBunnies_NFTCollection)\n        }\n\n        if (acct.getCapability<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RogueBunnies_NFT).borrow() == nil) {\n            acct.unlink(/private/RogueBunnies_NFT)\n            acct.link<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RogueBunnies_NFT, target: /storage/RogueBunnies_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/RogueBunnies_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xRogueBunnies_NFT": {
          "RogueBunnies_NFT": {
            "mainnet": {
              "address": "0x396646f110afb2e6",
              "contract": "RogueBunnies_NFT",
              "fq_address": "A.0x396646f110afb2e6.RogueBunnies_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509148
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509152
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509154
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509156
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509156
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509161
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "17789bb75a68b89648b0184f5e86de2663bfe44fd889ad3207b4b659a071ba9d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "17789bb75a68b89648b0184f5e86de2663bfe44fd889ad3207b4b659a071ba9d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support RogueBunnies NFTs"
          }
        }
      },
      "cadence": "import RogueBunnies_NFT from 0xRogueBunnies_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: RogueBunnies\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&RogueBunnies_NFT.Collection>(from: /storage/RogueBunnies_NFTCollection) == nil {\n      let collection <- RogueBunnies_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/RogueBunnies_NFTCollection)\n    }\n    if (signer.getCapability<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RogueBunnies_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/RogueBunnies_NFTCollection)\n      signer.link<&RogueBunnies_NFT.Collection{RogueBunnies_NFT.RogueBunnies_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RogueBunnies_NFTCollection, target: /storage/RogueBunnies_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xRogueBunnies_NFT": {
          "RogueBunnies_NFT": {
            "mainnet": {
              "address": "0x396646f110afb2e6",
              "contract": "RogueBunnies_NFT",
              "fq_address": "A.0x396646f110afb2e6.RogueBunnies_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509111
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509115
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509118
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "a73cdecc969d8a107043956638aa3f4ee3f4621f7c0c6b6c463f762c35667e4c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a73cdecc969d8a107043956638aa3f4ee3f4621f7c0c6b6c463f762c35667e4c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a RaceDayNFT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: RaceDayNFT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510150
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809571
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "2b6ec5902718013619a61f6e630c3bfa1c9a17ab9c8a0fcb99ab3de3ba210d2a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2b6ec5902718013619a61f6e630c3bfa1c9a17ab9c8a0fcb99ab3de3ba210d2a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a RaceDayNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import RaceDay_NFT from 0xRaceDay_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: RaceDayNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&RaceDay_NFT.Collection>(from: /storage/RaceDay_NFTCollection) == nil {\n            let collection <- RaceDay_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/RaceDay_NFTCollection)\n        }\n        if (acct.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/RaceDay_NFTCollection)\n            acct.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection, target: /storage/RaceDay_NFTCollection)\n        }\n\n        if (acct.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RaceDay_NFT).borrow() == nil) {\n            acct.unlink(/private/RaceDay_NFT)\n            acct.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RaceDay_NFT, target: /storage/RaceDay_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/RaceDay_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/RaceDay_NFTCollection)\n            .borrow<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@RaceDay_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xRaceDay_NFT": {
          "RaceDay_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "RaceDay_NFT",
              "fq_address": "A.0x329feb3ab062d289.RaceDay_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510071
            },
            "testnet": {
              "address": "0x04625c28593d9408",
              "contract": "RaceDay_NFT",
              "fq_address": "A.0x04625c28593d9408.RaceDay_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809480
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510083
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809487
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510087
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809497
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47510094
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95809499
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510094
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809501
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510099
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809510
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "60c957cc7c0ae54126c72d7a064440fd7d80824a47a82a8a2e7f684d1335d1de": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "60c957cc7c0ae54126c72d7a064440fd7d80824a47a82a8a2e7f684d1335d1de",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed RaceDayNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import RaceDay_NFT from 0xRaceDay_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: RaceDayNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&RaceDay_NFT.Collection>(from: /storage/RaceDay_NFTCollection) == nil {\n            let collection <- RaceDay_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/RaceDay_NFTCollection)\n            }\n        if (acct.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/RaceDay_NFTCollection)\n            acct.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection, target: /storage/RaceDay_NFTCollection)\n        }\n\n        if (acct.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RaceDay_NFT).borrow() == nil) {\n            acct.unlink(/private/RaceDay_NFT)\n            acct.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/RaceDay_NFT, target: /storage/RaceDay_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/RaceDay_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xRaceDay_NFT": {
          "RaceDay_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "RaceDay_NFT",
              "fq_address": "A.0x329feb3ab062d289.RaceDay_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510112
            },
            "testnet": {
              "address": "0x04625c28593d9408",
              "contract": "RaceDay_NFT",
              "fq_address": "A.0x04625c28593d9408.RaceDay_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809531
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510124
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809538
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510130
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809548
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47510135
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95809551
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510136
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809552
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510141
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809562
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "24229807bf58412587fade77c4183fe243202045e286ec9610e278f2b112109a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "24229807bf58412587fade77c4183fe243202045e286ec9610e278f2b112109a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support RaceDayNFT NFTs"
          }
        }
      },
      "cadence": "import RaceDay_NFT from 0xRaceDay_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: RaceDayNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&RaceDay_NFT.Collection>(from: /storage/RaceDay_NFTCollection) == nil {\n      let collection <- RaceDay_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/RaceDay_NFTCollection)\n    }\n    if (signer.getCapability<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/RaceDay_NFTCollection)\n      signer.link<&RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RaceDay_NFTCollection, target: /storage/RaceDay_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xRaceDay_NFT": {
          "RaceDay_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "RaceDay_NFT",
              "fq_address": "A.0x329feb3ab062d289.RaceDay_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510038
            },
            "testnet": {
              "address": "0x04625c28593d9408",
              "contract": "RaceDay_NFT",
              "fq_address": "A.0x04625c28593d9408.RaceDay_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809443
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510050
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809450
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510058
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809459
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "bc1a301b85bcd775d194d27a9d3c52536b3d3f92909555a874bf224669e1d347": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "bc1a301b85bcd775d194d27a9d3c52536b3d3f92909555a874bf224669e1d347",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a RCRDSHP NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: RCRDSHP\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505655
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "fc8ce58a968943912ed01c46ca366e673c28b3373b249ac55289ffd053efadff": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fc8ce58a968943912ed01c46ca366e673c28b3373b249ac55289ffd053efadff",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a RCRDSHP NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import RCRDSHPNFT from 0xRCRDSHPNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: RCRDSHP\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&RCRDSHPNFT.Collection>(from: /storage/RCRDSHPNFTCollection) == nil {\n            let collection <- RCRDSHPNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/RCRDSHPNFTCollection)\n        }\n        if (acct.getCapability<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RCRDSHPNFTCollection).borrow() == nil) {\n            acct.unlink(/public/RCRDSHPNFTCollection)\n            acct.link<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RCRDSHPNFTCollection, target: /storage/RCRDSHPNFTCollection)\n        }\n\n        if (acct.getCapability<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/RCRDSHPNFTCollection).borrow() == nil) {\n            acct.unlink(/private/RCRDSHPNFTCollection)\n            acct.link<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/RCRDSHPNFTCollection, target: /storage/RCRDSHPNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/RCRDSHPNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/RCRDSHPNFTCollection)\n            .borrow<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@RCRDSHPNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xRCRDSHPNFT": {
          "RCRDSHPNFT": {
            "mainnet": {
              "address": "0x6c3ff40b90b928ab",
              "contract": "RCRDSHPNFT",
              "fq_address": "A.0x6c3ff40b90b928ab.RCRDSHPNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505617
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505620
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505623
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505625
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505625
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505629
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b1aa99d0636dcf2d27905327b940a0bb248ae67ae62e79352fd53f84616a6142": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b1aa99d0636dcf2d27905327b940a0bb248ae67ae62e79352fd53f84616a6142",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed RCRDSHP NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import RCRDSHPNFT from 0xRCRDSHPNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: RCRDSHP\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&RCRDSHPNFT.Collection>(from: /storage/RCRDSHPNFTCollection) == nil {\n            let collection <- RCRDSHPNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/RCRDSHPNFTCollection)\n            }\n        if (acct.getCapability<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RCRDSHPNFTCollection).borrow() == nil) {\n            acct.unlink(/public/RCRDSHPNFTCollection)\n            acct.link<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RCRDSHPNFTCollection, target: /storage/RCRDSHPNFTCollection)\n        }\n\n        if (acct.getCapability<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/RCRDSHPNFTCollection).borrow() == nil) {\n            acct.unlink(/private/RCRDSHPNFTCollection)\n            acct.link<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/RCRDSHPNFTCollection, target: /storage/RCRDSHPNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/RCRDSHPNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xRCRDSHPNFT": {
          "RCRDSHPNFT": {
            "mainnet": {
              "address": "0x6c3ff40b90b928ab",
              "contract": "RCRDSHPNFT",
              "fq_address": "A.0x6c3ff40b90b928ab.RCRDSHPNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505638
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505640
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505645
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505646
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505646
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505649
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f5f7510a277d01b85a0ff13ed49b6ea7ce7825100ea1ab61284b695331d3c7c0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f5f7510a277d01b85a0ff13ed49b6ea7ce7825100ea1ab61284b695331d3c7c0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support RCRDSHP NFTs"
          }
        }
      },
      "cadence": "import RCRDSHPNFT from 0xRCRDSHPNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: RCRDSHP\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&RCRDSHPNFT.Collection>(from: /storage/RCRDSHPNFTCollection) == nil {\n      let collection <- RCRDSHPNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/RCRDSHPNFTCollection)\n    }\n    if (signer.getCapability<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RCRDSHPNFTCollection).borrow() == nil) {\n      signer.unlink(/public/RCRDSHPNFTCollection)\n      signer.link<&RCRDSHPNFT.Collection{RCRDSHPNFT.RCRDSHPNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/RCRDSHPNFTCollection, target: /storage/RCRDSHPNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xRCRDSHPNFT": {
          "RCRDSHPNFT": {
            "mainnet": {
              "address": "0x6c3ff40b90b928ab",
              "contract": "RCRDSHPNFT",
              "fq_address": "A.0x6c3ff40b90b928ab.RCRDSHPNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505602
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505605
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505609
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "fb0ec30f31c1021f33dd53fe35c98322079117d894daee689a50a561ca70c8a3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fb0ec30f31c1021f33dd53fe35c98322079117d894daee689a50a561ca70c8a3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a PiratesOfTheMetaverse NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: PiratesOfTheMetaverse\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492903
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789071
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "d55cfaf44c3d7fade3b99202f1bfa60707b5b084b1b0951720f06bf41cca9f3f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d55cfaf44c3d7fade3b99202f1bfa60707b5b084b1b0951720f06bf41cca9f3f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a PiratesOfTheMetaverse NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PiratesOfTheMetaverse from 0xPiratesOfTheMetaverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: PiratesOfTheMetaverse\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PiratesOfTheMetaverse.Collection>(from: /storage/piratesOfTheMetaverseCollection) == nil {\n            let collection <- PiratesOfTheMetaverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/piratesOfTheMetaverseCollection)\n        }\n        if (acct.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection).borrow() == nil) {\n            acct.unlink(/public/piratesOfTheMetaverseCollection)\n            acct.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n        }\n\n        if (acct.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/piratesOfTheMetaverseCollection).borrow() == nil) {\n            acct.unlink(/private/piratesOfTheMetaverseCollection)\n            acct.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/piratesOfTheMetaverseCollection)!\n        let collectionRef = acct\n            .getCapability(/public/piratesOfTheMetaverseCollection)\n            .borrow<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@PiratesOfTheMetaverse.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xPiratesOfTheMetaverse": {
          "PiratesOfTheMetaverse": {
            "mainnet": {
              "address": "0xf5fc2c119a988722",
              "contract": "PiratesOfTheMetaverse",
              "fq_address": "A.0xf5fc2c119a988722.PiratesOfTheMetaverse",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47492826
            },
            "testnet": {
              "address": "0xc97017ed85e496bf",
              "contract": "PiratesOfTheMetaverse",
              "fq_address": "A.0xc97017ed85e496bf.PiratesOfTheMetaverse",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95788979
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492837
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95788986
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492844
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95788995
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492849
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95788998
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492850
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95788999
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492856
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789008
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "8335a775d6825688d2a5433d67235146f88f42b562c92adce3942d5f532444a5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8335a775d6825688d2a5433d67235146f88f42b562c92adce3942d5f532444a5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed PiratesOfTheMetaverse NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PiratesOfTheMetaverse from 0xPiratesOfTheMetaverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: PiratesOfTheMetaverse\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PiratesOfTheMetaverse.Collection>(from: /storage/piratesOfTheMetaverseCollection) == nil {\n            let collection <- PiratesOfTheMetaverse.createEmptyCollection()\n            acct.save(<-collection, to: /storage/piratesOfTheMetaverseCollection)\n            }\n        if (acct.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection).borrow() == nil) {\n            acct.unlink(/public/piratesOfTheMetaverseCollection)\n            acct.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n        }\n\n        if (acct.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/piratesOfTheMetaverseCollection).borrow() == nil) {\n            acct.unlink(/private/piratesOfTheMetaverseCollection)\n            acct.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/piratesOfTheMetaverseCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xPiratesOfTheMetaverse": {
          "PiratesOfTheMetaverse": {
            "mainnet": {
              "address": "0xf5fc2c119a988722",
              "contract": "PiratesOfTheMetaverse",
              "fq_address": "A.0xf5fc2c119a988722.PiratesOfTheMetaverse",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47496606
            },
            "testnet": {
              "address": "0xc97017ed85e496bf",
              "contract": "PiratesOfTheMetaverse",
              "fq_address": "A.0xc97017ed85e496bf.PiratesOfTheMetaverse",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95793472
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496618
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95793479
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496625
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95793489
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47496630
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95793491
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496631
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95793492
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496636
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95793502
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f0bdc3a4a8b894c9585c2fa3b9536da5b4df753b542538722e37dbcc23917eed": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f0bdc3a4a8b894c9585c2fa3b9536da5b4df753b542538722e37dbcc23917eed",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support PiratesOfTheMetaverse NFTs"
          }
        }
      },
      "cadence": "import PiratesOfTheMetaverse from 0xPiratesOfTheMetaverse\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: PiratesOfTheMetaverse\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&PiratesOfTheMetaverse.Collection>(from: /storage/piratesOfTheMetaverseCollection) == nil {\n      let collection <- PiratesOfTheMetaverse.createEmptyCollection()\n      signer.save(<-collection, to: /storage/piratesOfTheMetaverseCollection)\n    }\n    if (signer.getCapability<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection).borrow() == nil) {\n      signer.unlink(/public/piratesOfTheMetaverseCollection)\n      signer.link<&PiratesOfTheMetaverse.Collection{PiratesOfTheMetaverse.PiratesOfTheMetaverseCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/piratesOfTheMetaverseCollection, target: /storage/piratesOfTheMetaverseCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xPiratesOfTheMetaverse": {
          "PiratesOfTheMetaverse": {
            "mainnet": {
              "address": "0xf5fc2c119a988722",
              "contract": "PiratesOfTheMetaverse",
              "fq_address": "A.0xf5fc2c119a988722.PiratesOfTheMetaverse",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47492794
            },
            "testnet": {
              "address": "0xc97017ed85e496bf",
              "contract": "PiratesOfTheMetaverse",
              "fq_address": "A.0xc97017ed85e496bf.PiratesOfTheMetaverse",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95788939
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492806
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95788946
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492813
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95788956
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "13e448d16591e0d4f5440e53a3c22bfeed66c1d8500c92bd0508eba89a0249c5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "13e448d16591e0d4f5440e53a3c22bfeed66c1d8500c92bd0508eba89a0249c5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a PuddleV1 NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: PuddleV1\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505139
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "e1984c3cc18357ba6c6b4816663629c67692b1851bc2ab98c88aed68be98c9ab": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e1984c3cc18357ba6c6b4816663629c67692b1851bc2ab98c88aed68be98c9ab",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a PuddleV1 NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PuddleV1 from 0xPuddleV1\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: PuddleV1\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PuddleV1.Collection>(from: /storage/PuddleV1Collection) == nil {\n            let collection <- PuddleV1.createEmptyCollection()\n            acct.save(<-collection, to: /storage/PuddleV1Collection)\n        }\n        if (acct.getCapability<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/PuddleV1Collection).borrow() == nil) {\n            acct.unlink(/public/PuddleV1Collection)\n            acct.link<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/PuddleV1Collection, target: /storage/PuddleV1Collection)\n        }\n\n        if (acct.getCapability<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PuddleV1Collection).borrow() == nil) {\n            acct.unlink(/private/PuddleV1Collection)\n            acct.link<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PuddleV1Collection, target: /storage/PuddleV1Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/PuddleV1Collection)!\n        let collectionRef = acct\n            .getCapability(/public/PuddleV1Collection)\n            .borrow<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@PuddleV1.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xPuddleV1": {
          "PuddleV1": {
            "mainnet": {
              "address": "0x9496a99be6bceb8c",
              "contract": "PuddleV1",
              "fq_address": "A.0x9496a99be6bceb8c.PuddleV1",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505102
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505106
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505110
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505110
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505110
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505114
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "5337f7d5bda126211ec388cc4fab98753bafea492ad628a0584a09dc9ed5cd67": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5337f7d5bda126211ec388cc4fab98753bafea492ad628a0584a09dc9ed5cd67",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed PuddleV1 NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PuddleV1 from 0xPuddleV1\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: PuddleV1\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PuddleV1.Collection>(from: /storage/PuddleV1Collection) == nil {\n            let collection <- PuddleV1.createEmptyCollection()\n            acct.save(<-collection, to: /storage/PuddleV1Collection)\n            }\n        if (acct.getCapability<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/PuddleV1Collection).borrow() == nil) {\n            acct.unlink(/public/PuddleV1Collection)\n            acct.link<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/PuddleV1Collection, target: /storage/PuddleV1Collection)\n        }\n\n        if (acct.getCapability<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PuddleV1Collection).borrow() == nil) {\n            acct.unlink(/private/PuddleV1Collection)\n            acct.link<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/PuddleV1Collection, target: /storage/PuddleV1Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/PuddleV1Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xPuddleV1": {
          "PuddleV1": {
            "mainnet": {
              "address": "0x9496a99be6bceb8c",
              "contract": "PuddleV1",
              "fq_address": "A.0x9496a99be6bceb8c.PuddleV1",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505123
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505126
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505130
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505130
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505131
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505135
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "151d409bf93b9a6fcaaaee23c241c6796eecf8499dfafde80276e1498cb38ff2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "151d409bf93b9a6fcaaaee23c241c6796eecf8499dfafde80276e1498cb38ff2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support PuddleV1 NFTs"
          }
        }
      },
      "cadence": "import PuddleV1 from 0xPuddleV1\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: PuddleV1\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&PuddleV1.Collection>(from: /storage/PuddleV1Collection) == nil {\n      let collection <- PuddleV1.createEmptyCollection()\n      signer.save(<-collection, to: /storage/PuddleV1Collection)\n    }\n    if (signer.getCapability<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/PuddleV1Collection).borrow() == nil) {\n      signer.unlink(/public/PuddleV1Collection)\n      signer.link<&PuddleV1.Collection{PuddleV1.PuddleV1CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/PuddleV1Collection, target: /storage/PuddleV1Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xPuddleV1": {
          "PuddleV1": {
            "mainnet": {
              "address": "0x9496a99be6bceb8c",
              "contract": "PuddleV1",
              "fq_address": "A.0x9496a99be6bceb8c.PuddleV1",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505088
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505090
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505094
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "fd3a6d0c902dc55ceee2c5dcaa5a68cc0e4ce55db56873e8fba2f5ec624039fe": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fd3a6d0c902dc55ceee2c5dcaa5a68cc0e4ce55db56873e8fba2f5ec624039fe",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Pickem NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Pickem\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505075
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803541
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "af807be72591864c00259ce6ced21868bdb00edfe2c57690b2d1a50c0b5aeca3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "af807be72591864c00259ce6ced21868bdb00edfe2c57690b2d1a50c0b5aeca3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a PharaohCats NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: PharaohCats\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492972
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "0d29fb369edbf0077a2c3b9deee418faf528594a9ff227beaebbd415729cb1e3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0d29fb369edbf0077a2c3b9deee418faf528594a9ff227beaebbd415729cb1e3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a PharaohCats NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: PharaohCats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n            let collection <- Momentables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentablesCollection)\n        }\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n            acct.unlink(/public/MomentablesCollection)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n        }\n\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/MomentablesCollectionProvider)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider, target: /storage/MomentablesCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MomentablesCollectionProvider)!\n        let collectionRef = acct\n            .getCapability(/public/MomentablesCollection)\n            .borrow<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Momentables.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMomentables": {
          "Momentables": {
            "mainnet": {
              "address": "0x9d21537544d9123d",
              "contract": "Momentables",
              "fq_address": "A.0x9d21537544d9123d.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492934
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492935
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492939
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492939
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492940
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492944
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "dadb22d945ea4b4f691f9af4080674b87611348602fc66e79d085adaf3b0c45c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "dadb22d945ea4b4f691f9af4080674b87611348602fc66e79d085adaf3b0c45c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed PharaohCats NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: PharaohCats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n            let collection <- Momentables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentablesCollection)\n            }\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n            acct.unlink(/public/MomentablesCollection)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n        }\n\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/MomentablesCollectionProvider)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider, target: /storage/MomentablesCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MomentablesCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMomentables": {
          "Momentables": {
            "mainnet": {
              "address": "0x9d21537544d9123d",
              "contract": "Momentables",
              "fq_address": "A.0x9d21537544d9123d.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492953
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492956
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492961
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492963
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492963
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492968
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "20a3cc48121ae9910f522e23b43b798893774fe50aee44c05c2cb4b5120e8164": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "20a3cc48121ae9910f522e23b43b798893774fe50aee44c05c2cb4b5120e8164",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support PharaohCats NFTs"
          }
        }
      },
      "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: PharaohCats\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n      let collection <- Momentables.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MomentablesCollection)\n    }\n    if (signer.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n      signer.unlink(/public/MomentablesCollection)\n      signer.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMomentables": {
          "Momentables": {
            "mainnet": {
              "address": "0x9d21537544d9123d",
              "contract": "Momentables",
              "fq_address": "A.0x9d21537544d9123d.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492917
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492921
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492923
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "37d46005d350175ee8aacdddf1da6f3a7617f2154948ff8171f7bb5376e2af69": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "37d46005d350175ee8aacdddf1da6f3a7617f2154948ff8171f7bb5376e2af69",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a PartyGooberz NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: PartyGooberz\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497840
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "a061c780973aa80a574c813b542ddbe30803bd68926f9ac5a70a745e4e038e7d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a061c780973aa80a574c813b542ddbe30803bd68926f9ac5a70a745e4e038e7d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a PartyGooberz NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GooberXContract from 0xGooberXContract\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: PartyGooberz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GooberXContract.Collection>(from: /storage/GooberzPartyFolksCollection) == nil {\n            let collection <- GooberXContract.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GooberzPartyFolksCollection)\n        }\n        if (acct.getCapability<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/GooberzPartyFolksCollectionPublic).borrow() == nil) {\n            acct.unlink(/public/GooberzPartyFolksCollectionPublic)\n            acct.link<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/GooberzPartyFolksCollectionPublic, target: /storage/GooberzPartyFolksCollection)\n        }\n\n        if (acct.getCapability<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/GooberzPartyFolksCollection).borrow() == nil) {\n            acct.unlink(/private/GooberzPartyFolksCollection)\n            acct.link<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/GooberzPartyFolksCollection, target: /storage/GooberzPartyFolksCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/GooberzPartyFolksCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GooberzPartyFolksCollectionPublic)\n            .borrow<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@GooberXContract.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xGooberXContract": {
          "GooberXContract": {
            "mainnet": {
              "address": "0x34f2bf4a80bb0f69",
              "contract": "GooberXContract",
              "fq_address": "A.0x34f2bf4a80bb0f69.GooberXContract",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47497795
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497798
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497802
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497803
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497804
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497808
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "52cb93c018fe64e393cc5bc35884edba420e25fac8325504eea16e5e759376be": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "52cb93c018fe64e393cc5bc35884edba420e25fac8325504eea16e5e759376be",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed PartyGooberz NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GooberXContract from 0xGooberXContract\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: PartyGooberz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GooberXContract.Collection>(from: /storage/GooberzPartyFolksCollection) == nil {\n            let collection <- GooberXContract.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GooberzPartyFolksCollection)\n            }\n        if (acct.getCapability<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/GooberzPartyFolksCollectionPublic).borrow() == nil) {\n            acct.unlink(/public/GooberzPartyFolksCollectionPublic)\n            acct.link<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/GooberzPartyFolksCollectionPublic, target: /storage/GooberzPartyFolksCollection)\n        }\n\n        if (acct.getCapability<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/GooberzPartyFolksCollection).borrow() == nil) {\n            acct.unlink(/private/GooberzPartyFolksCollection)\n            acct.link<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/GooberzPartyFolksCollection, target: /storage/GooberzPartyFolksCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/GooberzPartyFolksCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xGooberXContract": {
          "GooberXContract": {
            "mainnet": {
              "address": "0x34f2bf4a80bb0f69",
              "contract": "GooberXContract",
              "fq_address": "A.0x34f2bf4a80bb0f69.GooberXContract",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47497821
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497826
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497830
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497830
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497830
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497835
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f3a00d37de24991160d49c0184c5fa232c2be6cd847003dcbb5dbd97f9c6e2ca": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f3a00d37de24991160d49c0184c5fa232c2be6cd847003dcbb5dbd97f9c6e2ca",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support PartyGooberz NFTs"
          }
        }
      },
      "cadence": "import GooberXContract from 0xGooberXContract\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: PartyGooberz\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&GooberXContract.Collection>(from: /storage/GooberzPartyFolksCollection) == nil {\n      let collection <- GooberXContract.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GooberzPartyFolksCollection)\n    }\n    if (signer.getCapability<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/GooberzPartyFolksCollectionPublic).borrow() == nil) {\n      signer.unlink(/public/GooberzPartyFolksCollectionPublic)\n      signer.link<&GooberXContract.Collection{GooberXContract.GooberCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/GooberzPartyFolksCollectionPublic, target: /storage/GooberzPartyFolksCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xGooberXContract": {
          "GooberXContract": {
            "mainnet": {
              "address": "0x34f2bf4a80bb0f69",
              "contract": "GooberXContract",
              "fq_address": "A.0x34f2bf4a80bb0f69.GooberXContract",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47497769
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497772
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497780
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "dd707e4ad9e72b2f22c7151eb37c9099f09c4956399ff517b8e72ff8ec539cb6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "dd707e4ad9e72b2f22c7151eb37c9099f09c4956399ff517b8e72ff8ec539cb6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a PartyDrinks NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: PartyDrinks\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499578
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ae062a8daa4c3333c4085a59134a9a5a016e3bfcfed9a5c59661511e41451c48": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ae062a8daa4c3333c4085a59134a9a5a016e3bfcfed9a5c59661511e41451c48",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a PartyDrinks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PartyMansionDrinksContract from 0xPartyMansionDrinksContract\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: PartyDrinks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PartyMansionDrinksContract.Collection>(from: /storage/PartyMansionDrinkCollection) == nil {\n            let collection <- PartyMansionDrinksContract.createEmptyCollection()\n            acct.save(<-collection, to: /storage/PartyMansionDrinkCollection)\n        }\n        if (acct.getCapability<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PartyMansionDrinkCollectionPublic).borrow() == nil) {\n            acct.unlink(/public/PartyMansionDrinkCollectionPublic)\n            acct.link<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PartyMansionDrinkCollectionPublic, target: /storage/PartyMansionDrinkCollection)\n        }\n\n        if (acct.getCapability<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PartyMansionDrinkCollectionPublic).borrow() == nil) {\n            acct.unlink(/private/PartyMansionDrinkCollectionPublic)\n            acct.link<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PartyMansionDrinkCollectionPublic, target: /storage/PartyMansionDrinkCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/PartyMansionDrinkCollectionPublic)!\n        let collectionRef = acct\n            .getCapability(/public/PartyMansionDrinkCollectionPublic)\n            .borrow<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@PartyMansionDrinksContract.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xPartyMansionDrinksContract": {
          "PartyMansionDrinksContract": {
            "mainnet": {
              "address": "0x34f2bf4a80bb0f69",
              "contract": "PartyMansionDrinksContract",
              "fq_address": "A.0x34f2bf4a80bb0f69.PartyMansionDrinksContract",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 47499531
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499533
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499537
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499540
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499540
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499544
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "5b954edd191c342ce0c37a31401b8533de76b23ca7c4404269040662cfebe172": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5b954edd191c342ce0c37a31401b8533de76b23ca7c4404269040662cfebe172",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed PartyDrinks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PartyMansionDrinksContract from 0xPartyMansionDrinksContract\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: PartyDrinks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PartyMansionDrinksContract.Collection>(from: /storage/PartyMansionDrinkCollection) == nil {\n            let collection <- PartyMansionDrinksContract.createEmptyCollection()\n            acct.save(<-collection, to: /storage/PartyMansionDrinkCollection)\n            }\n        if (acct.getCapability<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PartyMansionDrinkCollectionPublic).borrow() == nil) {\n            acct.unlink(/public/PartyMansionDrinkCollectionPublic)\n            acct.link<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PartyMansionDrinkCollectionPublic, target: /storage/PartyMansionDrinkCollection)\n        }\n\n        if (acct.getCapability<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PartyMansionDrinkCollectionPublic).borrow() == nil) {\n            acct.unlink(/private/PartyMansionDrinkCollectionPublic)\n            acct.link<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PartyMansionDrinkCollectionPublic, target: /storage/PartyMansionDrinkCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/PartyMansionDrinkCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xPartyMansionDrinksContract": {
          "PartyMansionDrinksContract": {
            "mainnet": {
              "address": "0x34f2bf4a80bb0f69",
              "contract": "PartyMansionDrinksContract",
              "fq_address": "A.0x34f2bf4a80bb0f69.PartyMansionDrinksContract",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 47499558
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499561
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499565
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499568
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499568
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499572
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "b8d9e1cdf256423f3d4977575b49709e5deb17f4df39e3ad45cec05ed2259a6e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b8d9e1cdf256423f3d4977575b49709e5deb17f4df39e3ad45cec05ed2259a6e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support PartyDrinks NFTs"
          }
        }
      },
      "cadence": "import PartyMansionDrinksContract from 0xPartyMansionDrinksContract\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: PartyDrinks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&PartyMansionDrinksContract.Collection>(from: /storage/PartyMansionDrinkCollection) == nil {\n      let collection <- PartyMansionDrinksContract.createEmptyCollection()\n      signer.save(<-collection, to: /storage/PartyMansionDrinkCollection)\n    }\n    if (signer.getCapability<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PartyMansionDrinkCollectionPublic).borrow() == nil) {\n      signer.unlink(/public/PartyMansionDrinkCollectionPublic)\n      signer.link<&PartyMansionDrinksContract.Collection{PartyMansionDrinksContract.DrinkCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PartyMansionDrinkCollectionPublic, target: /storage/PartyMansionDrinkCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xPartyMansionDrinksContract": {
          "PartyMansionDrinksContract": {
            "mainnet": {
              "address": "0x34f2bf4a80bb0f69",
              "contract": "PartyMansionDrinksContract",
              "fq_address": "A.0x34f2bf4a80bb0f69.PartyMansionDrinksContract",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 47499509
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499512
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499516
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "95ae68038a5eaab703f3ada2614eb6bfcbd6f87c0bc851765bb08d1a1fd80b3a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "95ae68038a5eaab703f3ada2614eb6bfcbd6f87c0bc851765bb08d1a1fd80b3a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a OpenLockerIncBoneYardHuskyzClub NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: OpenLockerIncBoneYardHuskyzClub\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506353
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805077
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "f37e14301c249ee5d7f7a69e943b00eb2f17f1d51567efe7378a9b22db5dba7c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f37e14301c249ee5d7f7a69e943b00eb2f17f1d51567efe7378a9b22db5dba7c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a OneShotsComicBookTradingCardsbyTibles NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: OneShotsComicBookTradingCardsbyTibles\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488346
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "12c8be3310fc501ea46de9860bffcde96721e9f70dac6d14d7a867941b05b040": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "12c8be3310fc501ea46de9860bffcde96721e9f70dac6d14d7a867941b05b040",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a OneShotsComicBookTradingCardsbyTibles NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import OneShots from 0xOneShots\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: OneShotsComicBookTradingCardsbyTibles\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&OneShots.Collection>(from: /storage/TiblesOneShotsCollection) == nil {\n            let collection <- OneShots.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TiblesOneShotsCollection)\n        }\n        if (acct.getCapability<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesOneShotsCollection).borrow() == nil) {\n            acct.unlink(/public/TiblesOneShotsCollection)\n            acct.link<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesOneShotsCollection, target: /storage/TiblesOneShotsCollection)\n        }\n\n        if (acct.getCapability<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/OneShotsCollection).borrow() == nil) {\n            acct.unlink(/private/OneShotsCollection)\n            acct.link<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/OneShotsCollection, target: /storage/TiblesOneShotsCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/OneShotsCollection)!\n        let collectionRef = acct\n            .getCapability(/public/TiblesOneShotsCollection)\n            .borrow<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@OneShots.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xOneShots": {
          "OneShots": {
            "mainnet": {
              "address": "0x4f7ff543c936072b",
              "contract": "OneShots",
              "fq_address": "A.0x4f7ff543c936072b.OneShots",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47488301
            }
          }
        },
        "0xTiblesNFT": {
          "TiblesNFT": {
            "mainnet": {
              "address": "0x5cdeb067561defcb",
              "contract": "TiblesNFT",
              "fq_address": "A.0x5cdeb067561defcb.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488301
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488306
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488310
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488312
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488312
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488315
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "c5994e2e2071e1d971823e82c7373491b5ee92475f642b1009adbcd718b8300f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c5994e2e2071e1d971823e82c7373491b5ee92475f642b1009adbcd718b8300f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed OneShotsComicBookTradingCardsbyTibles NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import OneShots from 0xOneShots\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: OneShotsComicBookTradingCardsbyTibles\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&OneShots.Collection>(from: /storage/TiblesOneShotsCollection) == nil {\n            let collection <- OneShots.createEmptyCollection()\n            acct.save(<-collection, to: /storage/TiblesOneShotsCollection)\n            }\n        if (acct.getCapability<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesOneShotsCollection).borrow() == nil) {\n            acct.unlink(/public/TiblesOneShotsCollection)\n            acct.link<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesOneShotsCollection, target: /storage/TiblesOneShotsCollection)\n        }\n\n        if (acct.getCapability<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/OneShotsCollection).borrow() == nil) {\n            acct.unlink(/private/OneShotsCollection)\n            acct.link<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/OneShotsCollection, target: /storage/TiblesOneShotsCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/TiblesOneShotsCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xOneShots": {
          "OneShots": {
            "mainnet": {
              "address": "0x4f7ff543c936072b",
              "contract": "OneShots",
              "fq_address": "A.0x4f7ff543c936072b.OneShots",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47488327
            }
          }
        },
        "0xTiblesNFT": {
          "TiblesNFT": {
            "mainnet": {
              "address": "0x5cdeb067561defcb",
              "contract": "TiblesNFT",
              "fq_address": "A.0x5cdeb067561defcb.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488327
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488331
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488335
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488336
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488336
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488341
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "9b1cc48af2ffe601818c37fda2e021b5c776915fb47a6c1718443e00c21be030": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9b1cc48af2ffe601818c37fda2e021b5c776915fb47a6c1718443e00c21be030",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support OneShotsComicBookTradingCardsbyTibles NFTs"
          }
        }
      },
      "cadence": "import OneShots from 0xOneShots\nimport TiblesNFT from 0xTiblesNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: OneShotsComicBookTradingCardsbyTibles\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&OneShots.Collection>(from: /storage/TiblesOneShotsCollection) == nil {\n      let collection <- OneShots.createEmptyCollection()\n      signer.save(<-collection, to: /storage/TiblesOneShotsCollection)\n    }\n    if (signer.getCapability<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesOneShotsCollection).borrow() == nil) {\n      signer.unlink(/public/TiblesOneShotsCollection)\n      signer.link<&OneShots.Collection{TiblesNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/TiblesOneShotsCollection, target: /storage/TiblesOneShotsCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xOneShots": {
          "OneShots": {
            "mainnet": {
              "address": "0x4f7ff543c936072b",
              "contract": "OneShots",
              "fq_address": "A.0x4f7ff543c936072b.OneShots",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47488284
            }
          }
        },
        "0xTiblesNFT": {
          "TiblesNFT": {
            "mainnet": {
              "address": "0x5cdeb067561defcb",
              "contract": "TiblesNFT",
              "fq_address": "A.0x5cdeb067561defcb.TiblesNFT",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488284
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488287
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488292
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "3cc874b1fc52516a530d1317dd135da27b8ff0fa1a3dafb8ec3f8f5068b152e7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3cc874b1fc52516a530d1317dd135da27b8ff0fa1a3dafb8ec3f8f5068b152e7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a NextName NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: NextName\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487917
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "325a2964f8b58d999b015f604fcf924fe03aa2bbdcef74a5dfc5481f64789076": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "325a2964f8b58d999b015f604fcf924fe03aa2bbdcef74a5dfc5481f64789076",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a NextName NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NextName from 0xNextName\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NextName\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&NextName.Collection>(from: /storage/NextNameCollection001) == nil {\n            let collection <- NextName.createEmptyCollection()\n            acct.save(<-collection, to: /storage/NextNameCollection001)\n        }\n        if (acct.getCapability<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NextNameCollection001).borrow() == nil) {\n            acct.unlink(/public/NextNameCollection001)\n            acct.link<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NextNameCollection001, target: /storage/NextNameCollection001)\n        }\n\n        if (acct.getCapability<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NextNameCollection001).borrow() == nil) {\n            acct.unlink(/private/NextNameCollection001)\n            acct.link<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NextNameCollection001, target: /storage/NextNameCollection001)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/NextNameCollection001)!\n        let collectionRef = acct\n            .getCapability(/public/NextNameCollection001)\n            .borrow<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@NextName.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xNextName": {
          "NextName": {
            "mainnet": {
              "address": "0x15b236723f4b88ee",
              "contract": "NextName",
              "fq_address": "A.0x15b236723f4b88ee.NextName",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47487876
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47487878
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487884
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47487884
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47487884
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487888
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "f92752105b17cfa4330784b09ce275d88e900302a041bd3487971ca51bd0ab89": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f92752105b17cfa4330784b09ce275d88e900302a041bd3487971ca51bd0ab89",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed NextName NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NextName from 0xNextName\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NextName\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&NextName.Collection>(from: /storage/NextNameCollection001) == nil {\n            let collection <- NextName.createEmptyCollection()\n            acct.save(<-collection, to: /storage/NextNameCollection001)\n            }\n        if (acct.getCapability<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NextNameCollection001).borrow() == nil) {\n            acct.unlink(/public/NextNameCollection001)\n            acct.link<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NextNameCollection001, target: /storage/NextNameCollection001)\n        }\n\n        if (acct.getCapability<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NextNameCollection001).borrow() == nil) {\n            acct.unlink(/private/NextNameCollection001)\n            acct.link<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NextNameCollection001, target: /storage/NextNameCollection001)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/NextNameCollection001\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xNextName": {
          "NextName": {
            "mainnet": {
              "address": "0x15b236723f4b88ee",
              "contract": "NextName",
              "fq_address": "A.0x15b236723f4b88ee.NextName",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47487898
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47487902
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487906
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47487907
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47487907
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487911
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "b2f6d01593c0ecfd0b9f39750d587bc5c2ea3274b32fd8d1543dd0cf2385c1b6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b2f6d01593c0ecfd0b9f39750d587bc5c2ea3274b32fd8d1543dd0cf2385c1b6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support NextName NFTs"
          }
        }
      },
      "cadence": "import NextName from 0xNextName\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NextName\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&NextName.Collection>(from: /storage/NextNameCollection001) == nil {\n      let collection <- NextName.createEmptyCollection()\n      signer.save(<-collection, to: /storage/NextNameCollection001)\n    }\n    if (signer.getCapability<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NextNameCollection001).borrow() == nil) {\n      signer.unlink(/public/NextNameCollection001)\n      signer.link<&NextName.Collection{NextName.NextNameCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NextNameCollection001, target: /storage/NextNameCollection001)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xNextName": {
          "NextName": {
            "mainnet": {
              "address": "0x15b236723f4b88ee",
              "contract": "NextName",
              "fq_address": "A.0x15b236723f4b88ee.NextName",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47487858
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47487862
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487865
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "26d096819219bf9e54968f6a8d122582da97b519e24aa50ff9a364058cffe511": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "26d096819219bf9e54968f6a8d122582da97b519e24aa50ff9a364058cffe511",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a NeoCharity2021 NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: NeoCharity2021\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502640
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "55ca56ba5ff525e57d98257134a1c7d99384ed557900c8428007edcce871e63a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "55ca56ba5ff525e57d98257134a1c7d99384ed557900c8428007edcce871e63a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a NeoCharity2021 NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CharityNFT from 0xCharityNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NeoCharity2021\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CharityNFT.Collection>(from: /storage/findCharityCollection) == nil {\n            let collection <- CharityNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/findCharityCollection)\n        }\n        if (acct.getCapability<&CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/public/findCharityCollection).borrow() == nil) {\n            acct.unlink(/public/findCharityCollection)\n            acct.link<&CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/public/findCharityCollection, target: /storage/findCharityCollection)\n        }\n\n        if (acct.getCapability<&CharityNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection).borrow() == nil) {\n            acct.unlink(/private/findCharityCollection)\n            acct.link<&CharityNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection, target: /storage/findCharityCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/findCharityCollection)!\n        let collectionRef = acct\n            .getCapability(/public/findCharityCollection)\n            .borrow<&CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CharityNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCharityNFT": {
          "CharityNFT": {
            "mainnet": {
              "address": "0x097bafa4e0b48eef",
              "contract": "CharityNFT",
              "fq_address": "A.0x097bafa4e0b48eef.CharityNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47502599
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502603
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502607
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502608
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502609
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502614
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "52606eb25ef541577ed0e56e98ac5a24186bb1a4aa23866c81c509fbe7799285": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "52606eb25ef541577ed0e56e98ac5a24186bb1a4aa23866c81c509fbe7799285",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed NeoCharity2021 NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CharityNFT from 0xCharityNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NeoCharity2021\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CharityNFT.Collection>(from: /storage/findCharityCollection) == nil {\n            let collection <- CharityNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/findCharityCollection)\n            }\n        if (acct.getCapability<&CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/public/findCharityCollection).borrow() == nil) {\n            acct.unlink(/public/findCharityCollection)\n            acct.link<&CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/public/findCharityCollection, target: /storage/findCharityCollection)\n        }\n\n        if (acct.getCapability<&CharityNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection).borrow() == nil) {\n            acct.unlink(/private/findCharityCollection)\n            acct.link<&CharityNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection, target: /storage/findCharityCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/findCharityCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCharityNFT": {
          "CharityNFT": {
            "mainnet": {
              "address": "0x097bafa4e0b48eef",
              "contract": "CharityNFT",
              "fq_address": "A.0x097bafa4e0b48eef.CharityNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47502621
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502624
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502628
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502629
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502630
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502635
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "baa7edea27a8b35e70556638cf0eea9c6093bf3fddbfb5f431eaeb6c4c4e6c85": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "baa7edea27a8b35e70556638cf0eea9c6093bf3fddbfb5f431eaeb6c4c4e6c85",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support NeoCharity2021 NFTs"
          }
        }
      },
      "cadence": "import CharityNFT from 0xCharityNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NeoCharity2021\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CharityNFT.Collection>(from: /storage/findCharityCollection) == nil {\n      let collection <- CharityNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/findCharityCollection)\n    }\n    if (signer.getCapability<&CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/public/findCharityCollection).borrow() == nil) {\n      signer.unlink(/public/findCharityCollection)\n      signer.link<&CharityNFT.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,CharityNFT.CollectionPublic,MetadataViews.ResolverCollection}>(/public/findCharityCollection, target: /storage/findCharityCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCharityNFT": {
          "CharityNFT": {
            "mainnet": {
              "address": "0x097bafa4e0b48eef",
              "contract": "CharityNFT",
              "fq_address": "A.0x097bafa4e0b48eef.CharityNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47502584
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502587
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502591
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "d88d3e62ea30bd150214ce47e2a149225aeef8506517280e3a9c0d44237913fb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d88d3e62ea30bd150214ce47e2a149225aeef8506517280e3a9c0d44237913fb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a NFLAllDay NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: NFLAllDay\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507410
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806333
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "5db3237bc7f46bb02315e70c9e0dd9c75e647715f6343b0ac86b0477ea0ec5e8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5db3237bc7f46bb02315e70c9e0dd9c75e647715f6343b0ac86b0477ea0ec5e8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a NFLAllDay NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import AllDay from 0xAllDay\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NFLAllDay\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AllDay.Collection>(from: /storage/AllDayNFTCollection) == nil {\n            let collection <- AllDay.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AllDayNFTCollection)\n        }\n        if (acct.getCapability<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection).borrow() == nil) {\n            acct.unlink(/public/AllDayNFTCollection)\n            acct.link<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n        }\n\n        if (acct.getCapability<&AllDay.Collection{NonFungibleToken.Provider,AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/AllDayNFTCollection).borrow() == nil) {\n            acct.unlink(/private/AllDayNFTCollection)\n            acct.link<&AllDay.Collection{NonFungibleToken.Provider,AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/AllDayNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/AllDayNFTCollection)\n            .borrow<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@AllDay.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xAllDay": {
          "AllDay": {
            "mainnet": {
              "address": "0xe4cf4bdc1751c65d",
              "contract": "AllDay",
              "fq_address": "A.0xe4cf4bdc1751c65d.AllDay",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507332
            },
            "testnet": {
              "address": "0x4dfd62c88d1b6462",
              "contract": "AllDay",
              "fq_address": "A.0x4dfd62c88d1b6462.AllDay",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95806244
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507344
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806252
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507351
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806261
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507356
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95806263
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507357
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806265
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507361
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806274
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "a39241d9994fd06acbf22c8ddc9b4e723a0d40d6aba714cd090ad248db316891": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a39241d9994fd06acbf22c8ddc9b4e723a0d40d6aba714cd090ad248db316891",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed NFLAllDay NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import AllDay from 0xAllDay\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NFLAllDay\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AllDay.Collection>(from: /storage/AllDayNFTCollection) == nil {\n            let collection <- AllDay.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AllDayNFTCollection)\n            }\n        if (acct.getCapability<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection).borrow() == nil) {\n            acct.unlink(/public/AllDayNFTCollection)\n            acct.link<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n        }\n\n        if (acct.getCapability<&AllDay.Collection{NonFungibleToken.Provider,AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/AllDayNFTCollection).borrow() == nil) {\n            acct.unlink(/private/AllDayNFTCollection)\n            acct.link<&AllDay.Collection{NonFungibleToken.Provider,AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/AllDayNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xAllDay": {
          "AllDay": {
            "mainnet": {
              "address": "0xe4cf4bdc1751c65d",
              "contract": "AllDay",
              "fq_address": "A.0xe4cf4bdc1751c65d.AllDay",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507373
            },
            "testnet": {
              "address": "0x4dfd62c88d1b6462",
              "contract": "AllDay",
              "fq_address": "A.0x4dfd62c88d1b6462.AllDay",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95806294
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507383
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806301
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507390
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806310
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507395
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95806313
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507396
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806314
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507401
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806323
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e67073d1670a5f917eaf485cb27b942ef2ab52bee0663aa007a75c723d6a8a66": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e67073d1670a5f917eaf485cb27b942ef2ab52bee0663aa007a75c723d6a8a66",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support NFLAllDay NFTs"
          }
        }
      },
      "cadence": "import AllDay from 0xAllDay\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NFLAllDay\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&AllDay.Collection>(from: /storage/AllDayNFTCollection) == nil {\n      let collection <- AllDay.createEmptyCollection()\n      signer.save(<-collection, to: /storage/AllDayNFTCollection)\n    }\n    if (signer.getCapability<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection).borrow() == nil) {\n      signer.unlink(/public/AllDayNFTCollection)\n      signer.link<&AllDay.Collection{AllDay.MomentNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/AllDayNFTCollection, target: /storage/AllDayNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xAllDay": {
          "AllDay": {
            "mainnet": {
              "address": "0xe4cf4bdc1751c65d",
              "contract": "AllDay",
              "fq_address": "A.0xe4cf4bdc1751c65d.AllDay",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507300
            },
            "testnet": {
              "address": "0x4dfd62c88d1b6462",
              "contract": "AllDay",
              "fq_address": "A.0x4dfd62c88d1b6462.AllDay",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95806207
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507312
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806215
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507319
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806225
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "266dcc81af3f1fe679beb9c97f5125e7700a1bc30153573594c775a546853511": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "266dcc81af3f1fe679beb9c97f5125e7700a1bc30153573594c775a546853511",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a NFLAllDayPacks NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: NFLAllDayPacks\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502901
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95800952
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ebddb6529bfd29043301be8e362fde796125ad12851e23904245a86174d773a1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ebddb6529bfd29043301be8e362fde796125ad12851e23904245a86174d773a1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a NFLAllDayPacks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PackNFT from 0xPackNFT\nimport IPackNFT from 0xIPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NFLAllDayPacks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PackNFT.Collection>(from: /storage/PackNFTCollection) == nil {\n            let collection <- PackNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/PackNFTCollection)\n        }\n        if (acct.getCapability<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub).borrow() == nil) {\n            acct.unlink(/public/PackNFTCollectionPub)\n            acct.link<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub, target: /storage/PackNFTCollection)\n        }\n\n        if (acct.getCapability<&PackNFT.Collection{NonFungibleToken.Provider,IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PackNFTOperatorPriv).borrow() == nil) {\n            acct.unlink(/private/PackNFTOperatorPriv)\n            acct.link<&PackNFT.Collection{NonFungibleToken.Provider,IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PackNFTOperatorPriv, target: /storage/PackNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/PackNFTOperatorPriv)!\n        let collectionRef = acct\n            .getCapability(/public/PackNFTCollectionPub)\n            .borrow<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@PackNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xPackNFT": {
          "PackNFT": {
            "mainnet": {
              "address": "0xe4cf4bdc1751c65d",
              "contract": "PackNFT",
              "fq_address": "A.0xe4cf4bdc1751c65d.PackNFT",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47502796
            },
            "testnet": {
              "address": "0x4dfd62c88d1b6462",
              "contract": "PackNFT",
              "fq_address": "A.0x4dfd62c88d1b6462.PackNFT",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95800834
            }
          }
        },
        "0xIPackNFT": {
          "IPackNFT": {
            "mainnet": {
              "address": "0x44c6a6fd2281b6cc",
              "contract": "IPackNFT",
              "fq_address": "A.0x44c6a6fd2281b6cc.IPackNFT",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502810
            },
            "testnet": {
              "address": "0x5e3c1eb7f25e3c99",
              "contract": "IPackNFT",
              "fq_address": "A.0x5e3c1eb7f25e3c99.IPackNFT",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95800842
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502816
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95800850
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502824
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95800859
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502829
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95800862
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502831
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95800863
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502835
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95800873
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "299746f153cd316fee8068e9d34c46e1be5271d4bccb57b371f8ce3821b295cb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "299746f153cd316fee8068e9d34c46e1be5271d4bccb57b371f8ce3821b295cb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed NFLAllDayPacks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import PackNFT from 0xPackNFT\nimport IPackNFT from 0xIPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NFLAllDayPacks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&PackNFT.Collection>(from: /storage/PackNFTCollection) == nil {\n            let collection <- PackNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/PackNFTCollection)\n            }\n        if (acct.getCapability<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub).borrow() == nil) {\n            acct.unlink(/public/PackNFTCollectionPub)\n            acct.link<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub, target: /storage/PackNFTCollection)\n        }\n\n        if (acct.getCapability<&PackNFT.Collection{NonFungibleToken.Provider,IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PackNFTOperatorPriv).borrow() == nil) {\n            acct.unlink(/private/PackNFTOperatorPriv)\n            acct.link<&PackNFT.Collection{NonFungibleToken.Provider,IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/PackNFTOperatorPriv, target: /storage/PackNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/PackNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xPackNFT": {
          "PackNFT": {
            "mainnet": {
              "address": "0xe4cf4bdc1751c65d",
              "contract": "PackNFT",
              "fq_address": "A.0xe4cf4bdc1751c65d.PackNFT",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47502852
            },
            "testnet": {
              "address": "0x4dfd62c88d1b6462",
              "contract": "PackNFT",
              "fq_address": "A.0x4dfd62c88d1b6462.PackNFT",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95800901
            }
          }
        },
        "0xIPackNFT": {
          "IPackNFT": {
            "mainnet": {
              "address": "0x44c6a6fd2281b6cc",
              "contract": "IPackNFT",
              "fq_address": "A.0x44c6a6fd2281b6cc.IPackNFT",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502867
            },
            "testnet": {
              "address": "0x5e3c1eb7f25e3c99",
              "contract": "IPackNFT",
              "fq_address": "A.0x5e3c1eb7f25e3c99.IPackNFT",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95800910
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502874
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95800917
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502880
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95800927
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502885
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95800929
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502886
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95800930
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502892
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95800940
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "6b7298592fa51be0af54c483ba1413250e2f2c3167a3d0e0468acba73e599eb2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6b7298592fa51be0af54c483ba1413250e2f2c3167a3d0e0468acba73e599eb2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support NFLAllDayPacks NFTs"
          }
        }
      },
      "cadence": "import PackNFT from 0xPackNFT\nimport IPackNFT from 0xIPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NFLAllDayPacks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&PackNFT.Collection>(from: /storage/PackNFTCollection) == nil {\n      let collection <- PackNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/PackNFTCollection)\n    }\n    if (signer.getCapability<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub).borrow() == nil) {\n      signer.unlink(/public/PackNFTCollectionPub)\n      signer.link<&PackNFT.Collection{IPackNFT.IPackNFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/PackNFTCollectionPub, target: /storage/PackNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xPackNFT": {
          "PackNFT": {
            "mainnet": {
              "address": "0xe4cf4bdc1751c65d",
              "contract": "PackNFT",
              "fq_address": "A.0xe4cf4bdc1751c65d.PackNFT",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47502748
            },
            "testnet": {
              "address": "0x4dfd62c88d1b6462",
              "contract": "PackNFT",
              "fq_address": "A.0x4dfd62c88d1b6462.PackNFT",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95800781
            }
          }
        },
        "0xIPackNFT": {
          "IPackNFT": {
            "mainnet": {
              "address": "0x44c6a6fd2281b6cc",
              "contract": "IPackNFT",
              "fq_address": "A.0x44c6a6fd2281b6cc.IPackNFT",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502762
            },
            "testnet": {
              "address": "0x5e3c1eb7f25e3c99",
              "contract": "IPackNFT",
              "fq_address": "A.0x5e3c1eb7f25e3c99.IPackNFT",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95800790
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502769
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95800796
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502777
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95800806
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "94ce7041b5e741c25c4bc982de34a95c20d5fe7351ebcb0dc5a23238eaee62b1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "94ce7041b5e741c25c4bc982de34a95c20d5fe7351ebcb0dc5a23238eaee62b1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a NBATopShotInArena NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: NBATopShotInArena\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488501
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783884
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "7c058865a8a114a4ebb331d64d95bce1333ae5375602b1a9c504a70c1f23d460": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7c058865a8a114a4ebb331d64d95bce1333ae5375602b1a9c504a70c1f23d460",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a NBATopShotInArena NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NBATopShotArena from 0xNBATopShotArena\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NBATopShotInArena\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&NBATopShotArena.Collection>(from: /storage/NBATopShotArena_Collection) == nil {\n            let collection <- NBATopShotArena.createEmptyCollection()\n            acct.save(<-collection, to: /storage/NBATopShotArena_Collection)\n        }\n        if (acct.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection).borrow() == nil) {\n            acct.unlink(/public/NBATopShotArena_Collection)\n            acct.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n        }\n\n        if (acct.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NBATopShotArena_Collection).borrow() == nil) {\n            acct.unlink(/private/NBATopShotArena_Collection)\n            acct.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/NBATopShotArena_Collection)!\n        let collectionRef = acct\n            .getCapability(/public/NBATopShotArena_Collection)\n            .borrow<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@NBATopShotArena.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xNBATopShotArena": {
          "NBATopShotArena": {
            "mainnet": {
              "address": "0x27ece19eff91bab0",
              "contract": "NBATopShotArena",
              "fq_address": "A.0x27ece19eff91bab0.NBATopShotArena",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 47488403
            },
            "testnet": {
              "address": "0x6ad6a8246cec9822",
              "contract": "NBATopShotArena",
              "fq_address": "A.0x6ad6a8246cec9822.NBATopShotArena",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 95783780
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488421
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783788
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488428
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783798
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488433
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95783800
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488435
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783801
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488439
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783812
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "0fa324eef9b8d9053e7251452dbc260f56f4886dedd00b2695337454971f802d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0fa324eef9b8d9053e7251452dbc260f56f4886dedd00b2695337454971f802d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed NBATopShotInArena NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NBATopShotArena from 0xNBATopShotArena\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NBATopShotInArena\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&NBATopShotArena.Collection>(from: /storage/NBATopShotArena_Collection) == nil {\n            let collection <- NBATopShotArena.createEmptyCollection()\n            acct.save(<-collection, to: /storage/NBATopShotArena_Collection)\n            }\n        if (acct.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection).borrow() == nil) {\n            acct.unlink(/public/NBATopShotArena_Collection)\n            acct.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n        }\n\n        if (acct.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NBATopShotArena_Collection).borrow() == nil) {\n            acct.unlink(/private/NBATopShotArena_Collection)\n            acct.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/NBATopShotArena_Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xNBATopShotArena": {
          "NBATopShotArena": {
            "mainnet": {
              "address": "0x27ece19eff91bab0",
              "contract": "NBATopShotArena",
              "fq_address": "A.0x27ece19eff91bab0.NBATopShotArena",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 47488456
            },
            "testnet": {
              "address": "0x6ad6a8246cec9822",
              "contract": "NBATopShotArena",
              "fq_address": "A.0x6ad6a8246cec9822.NBATopShotArena",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 95783843
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488473
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783851
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488480
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783860
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488485
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95783863
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488486
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783864
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488491
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783873
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "4dbde75ecd624076a49e27afcc9f6992e4e0c44dfecd6c24bba5690a81108b59": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4dbde75ecd624076a49e27afcc9f6992e4e0c44dfecd6c24bba5690a81108b59",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support NBATopShotInArena NFTs"
          }
        }
      },
      "cadence": "import NBATopShotArena from 0xNBATopShotArena\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NBATopShotInArena\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&NBATopShotArena.Collection>(from: /storage/NBATopShotArena_Collection) == nil {\n      let collection <- NBATopShotArena.createEmptyCollection()\n      signer.save(<-collection, to: /storage/NBATopShotArena_Collection)\n    }\n    if (signer.getCapability<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection).borrow() == nil) {\n      signer.unlink(/public/NBATopShotArena_Collection)\n      signer.link<&NBATopShotArena.Collection{NBATopShotArena.NBATopShotArenaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/NBATopShotArena_Collection, target: /storage/NBATopShotArena_Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xNBATopShotArena": {
          "NBATopShotArena": {
            "mainnet": {
              "address": "0x27ece19eff91bab0",
              "contract": "NBATopShotArena",
              "fq_address": "A.0x27ece19eff91bab0.NBATopShotArena",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 47488361
            },
            "testnet": {
              "address": "0x6ad6a8246cec9822",
              "contract": "NBATopShotArena",
              "fq_address": "A.0x6ad6a8246cec9822.NBATopShotArena",
              "pin": "2185836c3c174a199b2f7130d573fa1150538c07466407ba347e154dce41a95a",
              "pin_block_height": 95783731
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488378
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783738
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488384
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783748
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "2a3834dfc1cf5d6113e597817a1b467cd7c85f2bca79500d7b3989d318757836": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2a3834dfc1cf5d6113e597817a1b467cd7c85f2bca79500d7b3989d318757836",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a NBATopShot NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: NBATopShot\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489455
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95785013
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "4abab5444510fafbb31484a1244bd005de39102e2f18e826a27ec86e503993fa": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4abab5444510fafbb31484a1244bd005de39102e2f18e826a27ec86e503993fa",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a NBATopShot NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TopShot from 0xTopShot\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: NBATopShot\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {\n            let collection <- TopShot.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentCollection)\n        }\n        if (acct.getCapability<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection).borrow() == nil) {\n            acct.unlink(/public/MomentCollection)\n            acct.link<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection, target: /storage/MomentCollection)\n        }\n\n        if (acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MomentCollection).borrow() == nil) {\n            acct.unlink(/private/MomentCollection)\n            acct.link<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MomentCollection, target: /storage/MomentCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MomentCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MomentCollection)\n            .borrow<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@TopShot.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xTopShot": {
          "TopShot": {
            "mainnet": {
              "address": "0x0b2a3299cc857e29",
              "contract": "TopShot",
              "fq_address": "A.0x0b2a3299cc857e29.TopShot",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47489361
            },
            "testnet": {
              "address": "0x877931736ee77cff",
              "contract": "TopShot",
              "fq_address": "A.0x877931736ee77cff.TopShot",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95784914
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489377
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784921
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489385
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784931
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47489390
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95784934
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489391
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784935
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489396
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784944
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "7257721c003c8d3088fd8f4816bc25989575afed88349fe106e594f72aec5ff3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7257721c003c8d3088fd8f4816bc25989575afed88349fe106e594f72aec5ff3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed NBATopShot NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import TopShot from 0xTopShot\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: NBATopShot\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {\n            let collection <- TopShot.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentCollection)\n            }\n        if (acct.getCapability<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection).borrow() == nil) {\n            acct.unlink(/public/MomentCollection)\n            acct.link<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection, target: /storage/MomentCollection)\n        }\n\n        if (acct.getCapability<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MomentCollection).borrow() == nil) {\n            acct.unlink(/private/MomentCollection)\n            acct.link<&TopShot.Collection{NonFungibleToken.Provider,TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MomentCollection, target: /storage/MomentCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MomentCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xTopShot": {
          "TopShot": {
            "mainnet": {
              "address": "0x0b2a3299cc857e29",
              "contract": "TopShot",
              "fq_address": "A.0x0b2a3299cc857e29.TopShot",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47489413
            },
            "testnet": {
              "address": "0x877931736ee77cff",
              "contract": "TopShot",
              "fq_address": "A.0x877931736ee77cff.TopShot",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95784974
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489428
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784982
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489435
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784990
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47489441
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95784992
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489441
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784993
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489447
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95785003
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "ec10e6483f820623ab30d61d6c2757768a4565edd550150ab8403a1abfd524ec": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ec10e6483f820623ab30d61d6c2757768a4565edd550150ab8403a1abfd524ec",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support NBATopShot NFTs"
          }
        }
      },
      "cadence": "import TopShot from 0xTopShot\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: NBATopShot\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&TopShot.Collection>(from: /storage/MomentCollection) == nil {\n      let collection <- TopShot.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MomentCollection)\n    }\n    if (signer.getCapability<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection).borrow() == nil) {\n      signer.unlink(/public/MomentCollection)\n      signer.link<&TopShot.Collection{TopShot.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MomentCollection, target: /storage/MomentCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xTopShot": {
          "TopShot": {
            "mainnet": {
              "address": "0x0b2a3299cc857e29",
              "contract": "TopShot",
              "fq_address": "A.0x0b2a3299cc857e29.TopShot",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47489322
            },
            "testnet": {
              "address": "0x877931736ee77cff",
              "contract": "TopShot",
              "fq_address": "A.0x877931736ee77cff.TopShot",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 95784868
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47489337
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784875
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47489344
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784884
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "3237dfdba120da0a8a0d3f494743fdb603f8221fbab0931657779c42896e98fb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3237dfdba120da0a8a0d3f494743fdb603f8221fbab0931657779c42896e98fb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MusicPeaksVideoNFT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksVideoNFT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505468
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804010
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "1142e463dd6bf8ae35a6e2de77b4d37fd4e2e4cdeb499a239b90c3615508907e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1142e463dd6bf8ae35a6e2de77b4d37fd4e2e4cdeb499a239b90c3615508907e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MusicPeaksVideoNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MusicPeaksVideoNFT from 0xMusicPeaksVideoNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksVideoNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksVideoNFT.Collection>(from: /storage/MusicPeaksVideoCollection) == nil {\n            let collection <- MusicPeaksVideoNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksVideoCollection)\n        }\n        if (acct.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksVideoCollection)\n            acct.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n        }\n\n        if (acct.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksVideoCollection).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksVideoCollection)\n            acct.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MusicPeaksVideoCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MusicPeaksVideoCollection)\n            .borrow<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MusicPeaksVideoNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMusicPeaksVideoNFT": {
          "MusicPeaksVideoNFT": {
            "mainnet": {
              "address": "0xd5c1f9ff20308c59",
              "contract": "MusicPeaksVideoNFT",
              "fq_address": "A.0xd5c1f9ff20308c59.MusicPeaksVideoNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505389
            },
            "testnet": {
              "address": "0x171d2aeb325e6e3e",
              "contract": "MusicPeaksVideoNFT",
              "fq_address": "A.0x171d2aeb325e6e3e.MusicPeaksVideoNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95803920
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505398
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803928
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505405
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803937
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505412
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95803940
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505413
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803941
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505417
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803950
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "309fc978c3889b09647d1580e83c35d8390a15e773d0f3e02d4084f71c23c730": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "309fc978c3889b09647d1580e83c35d8390a15e773d0f3e02d4084f71c23c730",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MusicPeaksVideoNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MusicPeaksVideoNFT from 0xMusicPeaksVideoNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MusicPeaksVideoNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksVideoNFT.Collection>(from: /storage/MusicPeaksVideoCollection) == nil {\n            let collection <- MusicPeaksVideoNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksVideoCollection)\n            }\n        if (acct.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksVideoCollection)\n            acct.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n        }\n\n        if (acct.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksVideoCollection).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksVideoCollection)\n            acct.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MusicPeaksVideoCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMusicPeaksVideoNFT": {
          "MusicPeaksVideoNFT": {
            "mainnet": {
              "address": "0xd5c1f9ff20308c59",
              "contract": "MusicPeaksVideoNFT",
              "fq_address": "A.0xd5c1f9ff20308c59.MusicPeaksVideoNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505429
            },
            "testnet": {
              "address": "0x171d2aeb325e6e3e",
              "contract": "MusicPeaksVideoNFT",
              "fq_address": "A.0x171d2aeb325e6e3e.MusicPeaksVideoNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95803970
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505441
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803977
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505448
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803987
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505454
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95803990
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505455
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803991
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505459
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804000
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "8f192a46815fa7c20d86197197c3896d90c52b1785b316f542fbecfebdbe5d5c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8f192a46815fa7c20d86197197c3896d90c52b1785b316f542fbecfebdbe5d5c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MusicPeaksVideoNFT NFTs"
          }
        }
      },
      "cadence": "import MusicPeaksVideoNFT from 0xMusicPeaksVideoNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MusicPeaksVideoNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MusicPeaksVideoNFT.Collection>(from: /storage/MusicPeaksVideoCollection) == nil {\n      let collection <- MusicPeaksVideoNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MusicPeaksVideoCollection)\n    }\n    if (signer.getCapability<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection).borrow() == nil) {\n      signer.unlink(/public/MusicPeaksVideoCollection)\n      signer.link<&MusicPeaksVideoNFT.Collection{MusicPeaksVideoNFT.MusicPeaksVideoNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksVideoCollection, target: /storage/MusicPeaksVideoCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMusicPeaksVideoNFT": {
          "MusicPeaksVideoNFT": {
            "mainnet": {
              "address": "0xd5c1f9ff20308c59",
              "contract": "MusicPeaksVideoNFT",
              "fq_address": "A.0xd5c1f9ff20308c59.MusicPeaksVideoNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505360
            },
            "testnet": {
              "address": "0x171d2aeb325e6e3e",
              "contract": "MusicPeaksVideoNFT",
              "fq_address": "A.0x171d2aeb325e6e3e.MusicPeaksVideoNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95803885
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505368
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803892
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505375
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803901
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "da2b866a2c9654541a0aa9a8490b285d92c011caba8c01577ad29f98c078fba6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "da2b866a2c9654541a0aa9a8490b285d92c011caba8c01577ad29f98c078fba6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MusicPeaksAttendanceToken NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksAttendanceToken\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508691
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807842
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6a8da986f1e321618e1339ff2d485f7e2a7e14a81dcbeae6380173e3955f9392": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6a8da986f1e321618e1339ff2d485f7e2a7e14a81dcbeae6380173e3955f9392",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MusicPeaksAttendanceToken NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MusicPeaksAttendanceToken from 0xMusicPeaksAttendanceToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksAttendanceToken\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksAttendanceToken.Collection>(from: /storage/MusicPeaksAttendanceTokenCollectionStoragePath) == nil {\n            let collection <- MusicPeaksAttendanceToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n        if (acct.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksAttendanceTokenCollectionPublicPath)\n            acct.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksAttendanceTokenCollectionPrivatePath)\n            acct.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath)!\n        let collectionRef = acct\n            .getCapability(/public/MusicPeaksAttendanceTokenCollectionPublicPath)\n            .borrow<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MusicPeaksAttendanceToken.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMusicPeaksAttendanceToken": {
          "MusicPeaksAttendanceToken": {
            "mainnet": {
              "address": "0xc467cbdf44afa9eb",
              "contract": "MusicPeaksAttendanceToken",
              "fq_address": "A.0xc467cbdf44afa9eb.MusicPeaksAttendanceToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47508583
            },
            "testnet": {
              "address": "0x644ee69fccf4ab48",
              "contract": "MusicPeaksAttendanceToken",
              "fq_address": "A.0x644ee69fccf4ab48.MusicPeaksAttendanceToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95807734
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508604
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807741
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508611
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807750
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508617
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95807753
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508617
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807754
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508622
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807763
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b6b93431b57d12e5c8b41160e1aa54669f5f654ffc3f2f776e88c0f9541cf7c2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b6b93431b57d12e5c8b41160e1aa54669f5f654ffc3f2f776e88c0f9541cf7c2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MusicPeaksAttendanceToken NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MusicPeaksAttendanceToken from 0xMusicPeaksAttendanceToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MusicPeaksAttendanceToken\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksAttendanceToken.Collection>(from: /storage/MusicPeaksAttendanceTokenCollectionStoragePath) == nil {\n            let collection <- MusicPeaksAttendanceToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n            }\n        if (acct.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksAttendanceTokenCollectionPublicPath)\n            acct.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksAttendanceTokenCollectionPrivatePath)\n            acct.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksAttendanceTokenCollectionPrivatePath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MusicPeaksAttendanceTokenCollectionStoragePath\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMusicPeaksAttendanceToken": {
          "MusicPeaksAttendanceToken": {
            "mainnet": {
              "address": "0xc467cbdf44afa9eb",
              "contract": "MusicPeaksAttendanceToken",
              "fq_address": "A.0xc467cbdf44afa9eb.MusicPeaksAttendanceToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47508644
            },
            "testnet": {
              "address": "0x644ee69fccf4ab48",
              "contract": "MusicPeaksAttendanceToken",
              "fq_address": "A.0x644ee69fccf4ab48.MusicPeaksAttendanceToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95807801
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508664
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807809
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508672
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807819
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508675
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95807821
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508677
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807822
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508682
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807832
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "1f8dc27f12a2a38d60a0c35354a1bef8d25eea72d69132e4a796b7ccfc48f1b6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1f8dc27f12a2a38d60a0c35354a1bef8d25eea72d69132e4a796b7ccfc48f1b6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MusicPeaksAttendanceToken NFTs"
          }
        }
      },
      "cadence": "import MusicPeaksAttendanceToken from 0xMusicPeaksAttendanceToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MusicPeaksAttendanceToken\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MusicPeaksAttendanceToken.Collection>(from: /storage/MusicPeaksAttendanceTokenCollectionStoragePath) == nil {\n      let collection <- MusicPeaksAttendanceToken.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n    }\n    if (signer.getCapability<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath).borrow() == nil) {\n      signer.unlink(/public/MusicPeaksAttendanceTokenCollectionPublicPath)\n      signer.link<&MusicPeaksAttendanceToken.Collection{MusicPeaksAttendanceToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksAttendanceTokenCollectionPublicPath, target: /storage/MusicPeaksAttendanceTokenCollectionStoragePath)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMusicPeaksAttendanceToken": {
          "MusicPeaksAttendanceToken": {
            "mainnet": {
              "address": "0xc467cbdf44afa9eb",
              "contract": "MusicPeaksAttendanceToken",
              "fq_address": "A.0xc467cbdf44afa9eb.MusicPeaksAttendanceToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47508537
            },
            "testnet": {
              "address": "0x644ee69fccf4ab48",
              "contract": "MusicPeaksAttendanceToken",
              "fq_address": "A.0x644ee69fccf4ab48.MusicPeaksAttendanceToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95807677
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508556
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807684
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508564
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807693
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "12290e7470bb644e0d333b46c7c7305867cc5a9d86d48f626356d6fb028fce37": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "12290e7470bb644e0d333b46c7c7305867cc5a9d86d48f626356d6fb028fce37",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MusicPeaksMembershipToken NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksMembershipToken\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503209
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801317
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "0f0c5e7acd2a0dd4f8fbff660b8ea9130922dc4f4c80f34d7f09966a22ccd1a1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0f0c5e7acd2a0dd4f8fbff660b8ea9130922dc4f4c80f34d7f09966a22ccd1a1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MusicPeaksMembershipToken NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MusicPeaksMembershipToken from 0xMusicPeaksMembershipToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MusicPeaksMembershipToken\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksMembershipToken.Collection>(from: /storage/MusicPeaksMembershipTokenCollectionStoragePath) == nil {\n            let collection <- MusicPeaksMembershipToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n        if (acct.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksMembershipTokenCollectionPublicPath)\n            acct.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksMembershipTokenCollectionPrivatePath)\n            acct.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath)!\n        let collectionRef = acct\n            .getCapability(/public/MusicPeaksMembershipTokenCollectionPublicPath)\n            .borrow<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MusicPeaksMembershipToken.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMusicPeaksMembershipToken": {
          "MusicPeaksMembershipToken": {
            "mainnet": {
              "address": "0xa02c28dc0aa50c18",
              "contract": "MusicPeaksMembershipToken",
              "fq_address": "A.0xa02c28dc0aa50c18.MusicPeaksMembershipToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47503108
            },
            "testnet": {
              "address": "0x860aded18da159c0",
              "contract": "MusicPeaksMembershipToken",
              "fq_address": "A.0x860aded18da159c0.MusicPeaksMembershipToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95801209
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47503125
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801216
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503132
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801226
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47503137
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95801228
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47503138
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801229
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503143
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801239
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "8503a59ab8dd1a3ef7e9b23dbdd62e5c9fd74cba61ee970b9823a72e20cbf85a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8503a59ab8dd1a3ef7e9b23dbdd62e5c9fd74cba61ee970b9823a72e20cbf85a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MusicPeaksMembershipToken NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MusicPeaksMembershipToken from 0xMusicPeaksMembershipToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MusicPeaksMembershipToken\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MusicPeaksMembershipToken.Collection>(from: /storage/MusicPeaksMembershipTokenCollectionStoragePath) == nil {\n            let collection <- MusicPeaksMembershipToken.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n            }\n        if (acct.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/MusicPeaksMembershipTokenCollectionPublicPath)\n            acct.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/MusicPeaksMembershipTokenCollectionPrivatePath)\n            acct.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MusicPeaksMembershipTokenCollectionPrivatePath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MusicPeaksMembershipTokenCollectionStoragePath\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMusicPeaksMembershipToken": {
          "MusicPeaksMembershipToken": {
            "mainnet": {
              "address": "0xa02c28dc0aa50c18",
              "contract": "MusicPeaksMembershipToken",
              "fq_address": "A.0xa02c28dc0aa50c18.MusicPeaksMembershipToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47503165
            },
            "testnet": {
              "address": "0x860aded18da159c0",
              "contract": "MusicPeaksMembershipToken",
              "fq_address": "A.0x860aded18da159c0.MusicPeaksMembershipToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95801277
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47503181
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801284
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503188
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801294
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47503193
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95801296
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47503196
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801297
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503201
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801307
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "2c3fbf6e26fae54df67f652577332e44748747528e8cdb3599135ff3597ccb94": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2c3fbf6e26fae54df67f652577332e44748747528e8cdb3599135ff3597ccb94",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MusicPeaksMembershipToken NFTs"
          }
        }
      },
      "cadence": "import MusicPeaksMembershipToken from 0xMusicPeaksMembershipToken\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MusicPeaksMembershipToken\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MusicPeaksMembershipToken.Collection>(from: /storage/MusicPeaksMembershipTokenCollectionStoragePath) == nil {\n      let collection <- MusicPeaksMembershipToken.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n    }\n    if (signer.getCapability<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath).borrow() == nil) {\n      signer.unlink(/public/MusicPeaksMembershipTokenCollectionPublicPath)\n      signer.link<&MusicPeaksMembershipToken.Collection{MusicPeaksMembershipToken.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MusicPeaksMembershipTokenCollectionPublicPath, target: /storage/MusicPeaksMembershipTokenCollectionStoragePath)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMusicPeaksMembershipToken": {
          "MusicPeaksMembershipToken": {
            "mainnet": {
              "address": "0xa02c28dc0aa50c18",
              "contract": "MusicPeaksMembershipToken",
              "fq_address": "A.0xa02c28dc0aa50c18.MusicPeaksMembershipToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47503061
            },
            "testnet": {
              "address": "0x860aded18da159c0",
              "contract": "MusicPeaksMembershipToken",
              "fq_address": "A.0x860aded18da159c0.MusicPeaksMembershipToken",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95801152
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47503081
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95801159
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47503088
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95801169
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "b5bb2d493a44c6aee57b79c5bca3e0df4773c0854e59ee43303dd1bfbd51e36d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b5bb2d493a44c6aee57b79c5bca3e0df4773c0854e59ee43303dd1bfbd51e36d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MonoCatsGashapon NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCatsGashapon\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95814082
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "fa361ad78b90e3458c72cb67395a00f646a35716f4ac3383b59d637c15d4c2ec": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fa361ad78b90e3458c72cb67395a00f646a35716f4ac3383b59d637c15d4c2ec",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MonoCatsGashapon NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCatsGashapon\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n            let collection <- MonoCatMysteryBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n        }\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MonoCatMysteryBoxCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MonoCatMysteryBoxCollection)\n            .borrow<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MonoCatMysteryBox.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMonoCatMysteryBox": {
          "MonoCatMysteryBox": {
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95814037
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95814040
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95814045
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95814046
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95814047
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95814052
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "4ce3de22f218a491526db8005a1c1ae090d4bd4566854016bb25831be645556b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4ce3de22f218a491526db8005a1c1ae090d4bd4566854016bb25831be645556b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MonoCatsGashapon NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MonoCatsGashapon\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n            let collection <- MonoCatMysteryBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n            }\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MonoCatMysteryBoxCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMonoCatMysteryBox": {
          "MonoCatMysteryBox": {
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95814062
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95814066
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95814071
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95814071
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95814072
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95814077
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "14105e31ee41106931a9f96134673d510ca3f0703219c03b9f79cab65608b89c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "14105e31ee41106931a9f96134673d510ca3f0703219c03b9f79cab65608b89c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MonoCatsGashapon NFTs"
          }
        }
      },
      "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MonoCatsGashapon\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n      let collection <- MonoCatMysteryBox.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n    }\n    if (signer.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n      signer.unlink(/public/MonoCatMysteryBoxCollection)\n      signer.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMonoCatMysteryBox": {
          "MonoCatMysteryBox": {
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95814017
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95814021
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95814026
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "bff98d8794baa59ce47eb93525bcb2657f5fcdeb7b7b2371170a3fae266b225a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "bff98d8794baa59ce47eb93525bcb2657f5fcdeb7b7b2371170a3fae266b225a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MonoCatsGachapon NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCatsGachapon\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501562
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799376
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "25f115e87092b67e3b0c435159d73fc95df5d5ce4e7a348b587a16bdb1894ba6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "25f115e87092b67e3b0c435159d73fc95df5d5ce4e7a348b587a16bdb1894ba6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MonoCatsGachapon NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCatsGachapon\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n            let collection <- MonoCatMysteryBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n        }\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MonoCatMysteryBoxCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MonoCatMysteryBoxCollection)\n            .borrow<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MonoCatMysteryBox.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMonoCatMysteryBox": {
          "MonoCatMysteryBox": {
            "mainnet": {
              "address": "0x8529aaf64c168952",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0x8529aaf64c168952.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47501482
            },
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95799287
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501493
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799294
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501501
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799303
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501507
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95799305
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501509
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799307
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501513
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799317
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "7436fc259e80beca62f7496fe272924eaf34fbf51146b46a02bd327ae92e772f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7436fc259e80beca62f7496fe272924eaf34fbf51146b46a02bd327ae92e772f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MonoCatsGachapon NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MonoCatsGachapon\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n            let collection <- MonoCatMysteryBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n            }\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n\n        if (acct.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatMysteryBoxCollection)\n            acct.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MonoCatMysteryBoxCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMonoCatMysteryBox": {
          "MonoCatMysteryBox": {
            "mainnet": {
              "address": "0x8529aaf64c168952",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0x8529aaf64c168952.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47501525
            },
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95799336
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501537
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799343
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501544
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799353
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501548
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95799355
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501548
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799356
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501554
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799366
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "9e3e66dabc4e7e3a32b5a9933c2aa3d44f9225e5a12cea2c13614440c39764d7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9e3e66dabc4e7e3a32b5a9933c2aa3d44f9225e5a12cea2c13614440c39764d7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MonoCatsGachapon NFTs"
          }
        }
      },
      "cadence": "import MonoCatMysteryBox from 0xMonoCatMysteryBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MonoCatsGachapon\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MonoCatMysteryBox.Collection>(from: /storage/MonoCatMysteryBoxCollection) == nil {\n      let collection <- MonoCatMysteryBox.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MonoCatMysteryBoxCollection)\n    }\n    if (signer.getCapability<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection).borrow() == nil) {\n      signer.unlink(/public/MonoCatMysteryBoxCollection)\n      signer.link<&MonoCatMysteryBox.Collection{MonoCatMysteryBox.MonoCatMysteryBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatMysteryBoxCollection, target: /storage/MonoCatMysteryBoxCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMonoCatMysteryBox": {
          "MonoCatMysteryBox": {
            "mainnet": {
              "address": "0x8529aaf64c168952",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0x8529aaf64c168952.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47501452
            },
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCatMysteryBox",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCatMysteryBox",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95799251
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501464
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799259
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501470
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799268
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "2b44c36f0d3b4891ad3e97d8df2cccd50cb4f7eb2ee2c695570168337fa94d50": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2b44c36f0d3b4891ad3e97d8df2cccd50cb4f7eb2ee2c695570168337fa94d50",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Momentables NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Momentables\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508833
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808012
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "0088fc9ef4ab5af1d0d280f80cf00b2aff856c5ca950cd77bf47c69a600bb0e8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0088fc9ef4ab5af1d0d280f80cf00b2aff856c5ca950cd77bf47c69a600bb0e8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Momentables NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Momentables\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n            let collection <- Momentables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentablesCollection)\n        }\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n            acct.unlink(/public/MomentablesCollection)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n        }\n\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/MomentablesCollectionProvider)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider, target: /storage/MomentablesCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MomentablesCollectionProvider)!\n        let collectionRef = acct\n            .getCapability(/public/MomentablesCollection)\n            .borrow<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Momentables.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMomentables": {
          "Momentables": {
            "mainnet": {
              "address": "0x9d21537544d9123d",
              "contract": "Momentables",
              "fq_address": "A.0x9d21537544d9123d.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508752
            },
            "testnet": {
              "address": "0x9f2eb43b6df02730",
              "contract": "Momentables",
              "fq_address": "A.0x9f2eb43b6df02730.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95807921
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508762
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807928
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508771
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807938
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508775
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95807940
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508777
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807941
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508781
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807951
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "88984e1873c28dc8f0300fdd134ac1b01df307aca14f138a1962f164d5b5368c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "88984e1873c28dc8f0300fdd134ac1b01df307aca14f138a1962f164d5b5368c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Momentables NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Momentables\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n            let collection <- Momentables.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MomentablesCollection)\n            }\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n            acct.unlink(/public/MomentablesCollection)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n        }\n\n        if (acct.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/MomentablesCollectionProvider)\n            acct.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MomentablesCollectionProvider, target: /storage/MomentablesCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MomentablesCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMomentables": {
          "Momentables": {
            "mainnet": {
              "address": "0x9d21537544d9123d",
              "contract": "Momentables",
              "fq_address": "A.0x9d21537544d9123d.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508794
            },
            "testnet": {
              "address": "0x9f2eb43b6df02730",
              "contract": "Momentables",
              "fq_address": "A.0x9f2eb43b6df02730.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95807970
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508804
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807977
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508812
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807987
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508816
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95807990
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508817
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807991
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508823
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808001
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "639c9c5279c92f905efc43d1838461d16cfa73939c71ecbac7880bca005b095f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "639c9c5279c92f905efc43d1838461d16cfa73939c71ecbac7880bca005b095f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Momentables NFTs"
          }
        }
      },
      "cadence": "import Momentables from 0xMomentables\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Momentables\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Momentables.Collection>(from: /storage/MomentablesCollection) == nil {\n      let collection <- Momentables.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MomentablesCollection)\n    }\n    if (signer.getCapability<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection).borrow() == nil) {\n      signer.unlink(/public/MomentablesCollection)\n      signer.link<&Momentables.Collection{Momentables.MomentablesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MomentablesCollection, target: /storage/MomentablesCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMomentables": {
          "Momentables": {
            "mainnet": {
              "address": "0x9d21537544d9123d",
              "contract": "Momentables",
              "fq_address": "A.0x9d21537544d9123d.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508722
            },
            "testnet": {
              "address": "0x9f2eb43b6df02730",
              "contract": "Momentables",
              "fq_address": "A.0x9f2eb43b6df02730.Momentables",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95807883
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508732
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95807890
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508739
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807900
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "b0421b4c632a40e38c1fc910534e7b8d83af76de7dafcfb90b57703588c4f725": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b0421b4c632a40e38c1fc910534e7b8d83af76de7dafcfb90b57703588c4f725",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MonoCats NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCats\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499699
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797154
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "47d4499101de5ccdbd9b8018c0103008e320c100c8da36f6fba984297f12d7f7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "47d4499101de5ccdbd9b8018c0103008e320c100c8da36f6fba984297f12d7f7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MonoCats NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MonoCat from 0xMonoCat\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MonoCats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCat.Collection>(from: /storage/MonoCatCollection) == nil {\n            let collection <- MonoCat.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatCollection)\n        }\n        if (acct.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatCollection)\n            acct.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection, target: /storage/MonoCatCollection)\n        }\n\n        if (acct.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatCollection)\n            acct.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatCollection, target: /storage/MonoCatCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MonoCatCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MonoCatCollection)\n            .borrow<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MonoCat.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMonoCat": {
          "MonoCat": {
            "mainnet": {
              "address": "0x8529aaf64c168952",
              "contract": "MonoCat",
              "fq_address": "A.0x8529aaf64c168952.MonoCat",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499619
            },
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCat",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCat",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797064
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499631
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797071
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499639
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797080
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499643
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95797083
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499643
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797084
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499649
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797093
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "8b1f803d29a113307911860eca44ff98ff46179e05e27c09a2a9eaa8eb1ca323": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8b1f803d29a113307911860eca44ff98ff46179e05e27c09a2a9eaa8eb1ca323",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MonoCats NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MonoCat from 0xMonoCat\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MonoCats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MonoCat.Collection>(from: /storage/MonoCatCollection) == nil {\n            let collection <- MonoCat.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MonoCatCollection)\n            }\n        if (acct.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection).borrow() == nil) {\n            acct.unlink(/public/MonoCatCollection)\n            acct.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection, target: /storage/MonoCatCollection)\n        }\n\n        if (acct.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatCollection).borrow() == nil) {\n            acct.unlink(/private/MonoCatCollection)\n            acct.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MonoCatCollection, target: /storage/MonoCatCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MonoCatCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMonoCat": {
          "MonoCat": {
            "mainnet": {
              "address": "0x8529aaf64c168952",
              "contract": "MonoCat",
              "fq_address": "A.0x8529aaf64c168952.MonoCat",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499660
            },
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCat",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCat",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797114
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499671
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797121
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499680
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797130
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499684
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95797133
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499686
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797134
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499691
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797143
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "4076d0693fcc859a3048c151cacc54c17fe4d7665da832ec2830a85735fd1a57": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4076d0693fcc859a3048c151cacc54c17fe4d7665da832ec2830a85735fd1a57",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MonoCats NFTs"
          }
        }
      },
      "cadence": "import MonoCat from 0xMonoCat\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MonoCats\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MonoCat.Collection>(from: /storage/MonoCatCollection) == nil {\n      let collection <- MonoCat.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MonoCatCollection)\n    }\n    if (signer.getCapability<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection).borrow() == nil) {\n      signer.unlink(/public/MonoCatCollection)\n      signer.link<&MonoCat.Collection{MonoCat.MonoCatCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MonoCatCollection, target: /storage/MonoCatCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMonoCat": {
          "MonoCat": {
            "mainnet": {
              "address": "0x8529aaf64c168952",
              "contract": "MonoCat",
              "fq_address": "A.0x8529aaf64c168952.MonoCat",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499586
            },
            "testnet": {
              "address": "0xa01dd6e82b7352be",
              "contract": "MonoCat",
              "fq_address": "A.0xa01dd6e82b7352be.MonoCat",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797028
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499599
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797035
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499607
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797044
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "a51ded3148b5365237fe0c419548bcbd98774c473e9d29833f61ff03ecef011b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a51ded3148b5365237fe0c419548bcbd98774c473e9d29833f61ff03ecef011b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Mindtrix NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Mindtrix\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510007
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809401
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6b5b5f783a3afe5dec1a621fabd4c76656a8dc4a5f4f765b1bb04297674d11c0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6b5b5f783a3afe5dec1a621fabd4c76656a8dc4a5f4f765b1bb04297674d11c0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Mindtrix NFTs"
          }
        }
      },
      "cadence": "import Mindtrix from 0xMindtrix\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Mindtrix\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Mindtrix.Collection>(from: /storage/MindtrixNFTCollection) == nil {\n      let collection <- Mindtrix.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MindtrixNFTCollection)\n    }\n    if (signer.getCapability<&Mindtrix.Collection{Mindtrix.MindtrixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MindtrixNFTCollection).borrow() == nil) {\n      signer.unlink(/public/MindtrixNFTCollection)\n      signer.link<&Mindtrix.Collection{Mindtrix.MindtrixCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MindtrixNFTCollection, target: /storage/MindtrixNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMindtrix": {
          "Mindtrix": {
            "mainnet": {
              "address": "0x74266bc086680e5e",
              "contract": "Mindtrix",
              "fq_address": "A.0x74266bc086680e5e.Mindtrix",
              "pin": "ff354108762eba4ffce22fe6a264fe6840d4b0c45f52157d9d1c98540f4b8469",
              "pin_block_height": 47509776
            },
            "testnet": {
              "address": "0xd162b02676d63c36",
              "contract": "Mindtrix",
              "fq_address": "A.0xd162b02676d63c36.Mindtrix",
              "pin": "ff354108762eba4ffce22fe6a264fe6840d4b0c45f52157d9d1c98540f4b8469",
              "pin_block_height": 95809165
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509811
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809173
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509819
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809182
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "3c9548e5f5c2f33fa934d8ed8a3f76db927212f3950151a87bb8948cecc61379": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3c9548e5f5c2f33fa934d8ed8a3f76db927212f3950151a87bb8948cecc61379",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MintStoreItem NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MintStoreItem\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510027
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809422
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ab8901c6b240d607e18e046cc111bcff01da1b4b0728f3c18d361fe4faade4f7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ab8901c6b240d607e18e046cc111bcff01da1b4b0728f3c18d361fe4faade4f7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MetaPanda NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MetaPanda\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507291
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "a9a3768c4352c4ab2a8c0971906eacc1659a287a74a80d45d97d5cbce4a229ad": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a9a3768c4352c4ab2a8c0971906eacc1659a287a74a80d45d97d5cbce4a229ad",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MetaPanda NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MetaPanda from 0xMetaPanda\nimport AnchainUtils from 0xAnchainUtils\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MetaPanda\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MetaPanda.Collection>(from: /storage/MetaPandaCollection) == nil {\n            let collection <- MetaPanda.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MetaPandaCollection)\n        }\n        if (acct.getCapability<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetaPandaCollection).borrow() == nil) {\n            acct.unlink(/public/MetaPandaCollection)\n            acct.link<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetaPandaCollection, target: /storage/MetaPandaCollection)\n        }\n\n        if (acct.getCapability<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MetaPandaCollection).borrow() == nil) {\n            acct.unlink(/private/MetaPandaCollection)\n            acct.link<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MetaPandaCollection, target: /storage/MetaPandaCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MetaPandaCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MetaPandaCollection)\n            .borrow<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MetaPanda.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMetaPanda": {
          "MetaPanda": {
            "mainnet": {
              "address": "0xf2af175e411dfff8",
              "contract": "MetaPanda",
              "fq_address": "A.0xf2af175e411dfff8.MetaPanda",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47507238
            }
          }
        },
        "0xAnchainUtils": {
          "AnchainUtils": {
            "mainnet": {
              "address": "0x7ba45bdcac17806a",
              "contract": "AnchainUtils",
              "fq_address": "A.0x7ba45bdcac17806a.AnchainUtils",
              "pin": "ec7be5050256b8b9ab2a6f5550a42b6a64627fa7e684a88de5dd767864f0471a",
              "pin_block_height": 47507242
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507246
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507250
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507251
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507251
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507257
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "31e460816170eaf8fe7a96cbf2f3f006ba35062ac077feeeee25d1ef67ce520c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "31e460816170eaf8fe7a96cbf2f3f006ba35062ac077feeeee25d1ef67ce520c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MetaPanda NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MetaPanda from 0xMetaPanda\nimport AnchainUtils from 0xAnchainUtils\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MetaPanda\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MetaPanda.Collection>(from: /storage/MetaPandaCollection) == nil {\n            let collection <- MetaPanda.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MetaPandaCollection)\n            }\n        if (acct.getCapability<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetaPandaCollection).borrow() == nil) {\n            acct.unlink(/public/MetaPandaCollection)\n            acct.link<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetaPandaCollection, target: /storage/MetaPandaCollection)\n        }\n\n        if (acct.getCapability<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MetaPandaCollection).borrow() == nil) {\n            acct.unlink(/private/MetaPandaCollection)\n            acct.link<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/MetaPandaCollection, target: /storage/MetaPandaCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MetaPandaCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMetaPanda": {
          "MetaPanda": {
            "mainnet": {
              "address": "0xf2af175e411dfff8",
              "contract": "MetaPanda",
              "fq_address": "A.0xf2af175e411dfff8.MetaPanda",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47507269
            }
          }
        },
        "0xAnchainUtils": {
          "AnchainUtils": {
            "mainnet": {
              "address": "0x7ba45bdcac17806a",
              "contract": "AnchainUtils",
              "fq_address": "A.0x7ba45bdcac17806a.AnchainUtils",
              "pin": "ec7be5050256b8b9ab2a6f5550a42b6a64627fa7e684a88de5dd767864f0471a",
              "pin_block_height": 47507273
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507276
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507280
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507280
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507281
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507285
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "9dfef1eaf5ec0b01f6c2ebfe632891601bb4806e8ae3f9d5327dbd49706ad963": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9dfef1eaf5ec0b01f6c2ebfe632891601bb4806e8ae3f9d5327dbd49706ad963",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MetaPanda NFTs"
          }
        }
      },
      "cadence": "import MetaPanda from 0xMetaPanda\nimport AnchainUtils from 0xAnchainUtils\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MetaPanda\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MetaPanda.Collection>(from: /storage/MetaPandaCollection) == nil {\n      let collection <- MetaPanda.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MetaPandaCollection)\n    }\n    if (signer.getCapability<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetaPandaCollection).borrow() == nil) {\n      signer.unlink(/public/MetaPandaCollection)\n      signer.link<&MetaPanda.Collection{AnchainUtils.ResolverCollection,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetaPandaCollection, target: /storage/MetaPandaCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMetaPanda": {
          "MetaPanda": {
            "mainnet": {
              "address": "0xf2af175e411dfff8",
              "contract": "MetaPanda",
              "fq_address": "A.0xf2af175e411dfff8.MetaPanda",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47507213
            }
          }
        },
        "0xAnchainUtils": {
          "AnchainUtils": {
            "mainnet": {
              "address": "0x7ba45bdcac17806a",
              "contract": "AnchainUtils",
              "fq_address": "A.0x7ba45bdcac17806a.AnchainUtils",
              "pin": "ec7be5050256b8b9ab2a6f5550a42b6a64627fa7e684a88de5dd767864f0471a",
              "pin_block_height": 47507217
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507220
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507225
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "ac1f924b1c37dd8c9d6ef95080fb32dc80aefb7ef2d40f225a55df51dc35790c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ac1f924b1c37dd8c9d6ef95080fb32dc80aefb7ef2d40f225a55df51dc35790c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Metabilia NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Metabilia\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813634
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "f030b11093b1b92f93c0c84ace648826dd2d2f1bc964ff2a8981bde21bb5b910": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f030b11093b1b92f93c0c84ace648826dd2d2f1bc964ff2a8981bde21bb5b910",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Metabilia NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MetabiliaNFT from 0xMetabiliaNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Metabilia\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MetabiliaNFT.Collection>(from: /storage/MetabiliaNFTCollection) == nil {\n            let collection <- MetabiliaNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MetabiliaNFTCollection)\n        }\n        if (acct.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection).borrow() == nil) {\n            acct.unlink(/public/MetabiliaNFTCollection)\n            acct.link<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n        }\n\n        if (acct.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MetabiliaNFTCollection).borrow() == nil) {\n            acct.unlink(/private/MetabiliaNFTCollection)\n            acct.link<&MetabiliaNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MetabiliaNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MetabiliaNFTCollection)\n            .borrow<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MetabiliaNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMetabiliaNFT": {
          "MetabiliaNFT": {
            "testnet": {
              "address": "0x5bfb52a5bf7d2da5",
              "contract": "MetabiliaNFT",
              "fq_address": "A.0x5bfb52a5bf7d2da5.MetabiliaNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95813588
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813592
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813597
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813598
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813599
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813603
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "1d881512b121d6f6c62cbaaa8bad35985f8ada8ad679f4502c54d2e2a2b71580": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1d881512b121d6f6c62cbaaa8bad35985f8ada8ad679f4502c54d2e2a2b71580",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Metabilia NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MetabiliaNFT from 0xMetabiliaNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Metabilia\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MetabiliaNFT.Collection>(from: /storage/MetabiliaNFTCollection) == nil {\n            let collection <- MetabiliaNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MetabiliaNFTCollection)\n            }\n        if (acct.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection).borrow() == nil) {\n            acct.unlink(/public/MetabiliaNFTCollection)\n            acct.link<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n        }\n\n        if (acct.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MetabiliaNFTCollection).borrow() == nil) {\n            acct.unlink(/private/MetabiliaNFTCollection)\n            acct.link<&MetabiliaNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/MetabiliaNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMetabiliaNFT": {
          "MetabiliaNFT": {
            "testnet": {
              "address": "0x5bfb52a5bf7d2da5",
              "contract": "MetabiliaNFT",
              "fq_address": "A.0x5bfb52a5bf7d2da5.MetabiliaNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95813613
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813617
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813622
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813623
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813623
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813628
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "cd709b9b6e84e0c3e1e06d9f9a9fe9157d15378012aa449a367aaf64305041e7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cd709b9b6e84e0c3e1e06d9f9a9fe9157d15378012aa449a367aaf64305041e7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Metabilia NFTs"
          }
        }
      },
      "cadence": "import MetabiliaNFT from 0xMetabiliaNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Metabilia\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MetabiliaNFT.Collection>(from: /storage/MetabiliaNFTCollection) == nil {\n      let collection <- MetabiliaNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MetabiliaNFTCollection)\n    }\n    if (signer.getCapability<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection).borrow() == nil) {\n      signer.unlink(/public/MetabiliaNFTCollection)\n      signer.link<&MetabiliaNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/MetabiliaNFTCollection, target: /storage/MetabiliaNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMetabiliaNFT": {
          "MetabiliaNFT": {
            "testnet": {
              "address": "0x5bfb52a5bf7d2da5",
              "contract": "MetabiliaNFT",
              "fq_address": "A.0x5bfb52a5bf7d2da5.MetabiliaNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95813570
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813574
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813578
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "6e24caac7010b4b0c0cd96ff352ed29fc03c0ef9c4e53d4015cfae7b48ff9db2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6e24caac7010b4b0c0cd96ff352ed29fc03c0ef9c4e53d4015cfae7b48ff9db2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MFLPacks NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MFLPacks\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512352
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "d6f059c65a555ba3e4f66c043b997c30804072f592b4d1516a2999123c4c9dcd": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d6f059c65a555ba3e4f66c043b997c30804072f592b4d1516a2999123c4c9dcd",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MFLPacks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MFLPacks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n            let collection <- MFLPack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLPackCollection)\n        }\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/public/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/private/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MFLPackCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MFLPackCollection)\n            .borrow<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MFLPack.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMFLPack": {
          "MFLPack": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLPack",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLPack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47512304
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512308
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512311
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512313
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512313
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512318
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b5f14a6d54f172c2b2ec3abaa1134228a7aee1ef9842496c2ff98bc1416dce8d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b5f14a6d54f172c2b2ec3abaa1134228a7aee1ef9842496c2ff98bc1416dce8d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MFLPacks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MFLPacks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n            let collection <- MFLPack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLPackCollection)\n            }\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/public/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/private/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MFLPackCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMFLPack": {
          "MFLPack": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLPack",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLPack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47512334
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512337
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512340
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512342
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512342
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512346
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "8e8e3c06b1b9f285a7d8aeb275f247e3c372aa73a812a1411a91bdc344ef9cfe": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8e8e3c06b1b9f285a7d8aeb275f247e3c372aa73a812a1411a91bdc344ef9cfe",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MFLPacks NFTs"
          }
        }
      },
      "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MFLPacks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n      let collection <- MFLPack.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MFLPackCollection)\n    }\n    if (signer.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n      signer.unlink(/public/MFLPackCollection)\n      signer.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMFLPack": {
          "MFLPack": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLPack",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLPack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47512284
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512286
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512291
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "9651d41b76c26afb26feeafe72103711b4610b50cca471b958d40b107976c88a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9651d41b76c26afb26feeafe72103711b4610b50cca471b958d40b107976c88a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MFLPlayers NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MFLPlayers\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492718
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "3a76563e4a4ee33026d4054c24ee25d83714aade6614d6349f358fbe47447c74": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3a76563e4a4ee33026d4054c24ee25d83714aade6614d6349f358fbe47447c74",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MFLPlayers NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MFLPlayer from 0xMFLPlayer\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MFLPlayers\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLPlayer.Collection>(from: /storage/MFLPlayerCollection) == nil {\n            let collection <- MFLPlayer.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLPlayerCollection)\n        }\n        if (acct.getCapability<&MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPlayerCollection).borrow() == nil) {\n            acct.unlink(/public/MFLPlayerCollection)\n            acct.link<&MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPlayerCollection, target: /storage/MFLPlayerCollection)\n        }\n\n        if (acct.getCapability<&MFLPlayer.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPlayerCollection).borrow() == nil) {\n            acct.unlink(/private/MFLPlayerCollection)\n            acct.link<&MFLPlayer.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPlayerCollection, target: /storage/MFLPlayerCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MFLPlayerCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MFLPlayerCollection)\n            .borrow<&MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MFLPlayer.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMFLPlayer": {
          "MFLPlayer": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLPlayer",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLPlayer",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47492673
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492676
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492680
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492681
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492682
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492687
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "f1c853ae6854f72147cc3b2806427427ce8984cadbf58a953e62699519ec26f3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f1c853ae6854f72147cc3b2806427427ce8984cadbf58a953e62699519ec26f3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MFLPlayers NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MFLPlayer from 0xMFLPlayer\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MFLPlayers\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLPlayer.Collection>(from: /storage/MFLPlayerCollection) == nil {\n            let collection <- MFLPlayer.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLPlayerCollection)\n            }\n        if (acct.getCapability<&MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPlayerCollection).borrow() == nil) {\n            acct.unlink(/public/MFLPlayerCollection)\n            acct.link<&MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPlayerCollection, target: /storage/MFLPlayerCollection)\n        }\n\n        if (acct.getCapability<&MFLPlayer.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPlayerCollection).borrow() == nil) {\n            acct.unlink(/private/MFLPlayerCollection)\n            acct.link<&MFLPlayer.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPlayerCollection, target: /storage/MFLPlayerCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MFLPlayerCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMFLPlayer": {
          "MFLPlayer": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLPlayer",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLPlayer",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47492699
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492703
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492707
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492708
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492709
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492714
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "52f769e905cadc39f8e86fbf7dfbba4efd1207ce35d8dbe904d5a47a671049a2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "52f769e905cadc39f8e86fbf7dfbba4efd1207ce35d8dbe904d5a47a671049a2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MFLPlayers NFTs"
          }
        }
      },
      "cadence": "import MFLPlayer from 0xMFLPlayer\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MFLPlayers\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MFLPlayer.Collection>(from: /storage/MFLPlayerCollection) == nil {\n      let collection <- MFLPlayer.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MFLPlayerCollection)\n    }\n    if (signer.getCapability<&MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPlayerCollection).borrow() == nil) {\n      signer.unlink(/public/MFLPlayerCollection)\n      signer.link<&MFLPlayer.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPlayerCollection, target: /storage/MFLPlayerCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMFLPlayer": {
          "MFLPlayer": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLPlayer",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLPlayer",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47492501
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492504
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492506
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "7a680f2508d01b22491d3358cf5e53cd09a26a0ec4a8c2618e8bb56c214c4d6f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7a680f2508d01b22491d3358cf5e53cd09a26a0ec4a8c2618e8bb56c214c4d6f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MFLPackCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MFLPackCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813560
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "be56510943b2a3b893a6b5c069844a0f030c5f741aba06b0171c5b6ff41addbb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "be56510943b2a3b893a6b5c069844a0f030c5f741aba06b0171c5b6ff41addbb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MFLPackCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MFLPackCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n            let collection <- MFLPack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLPackCollection)\n        }\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/public/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/private/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MFLPackCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MFLPackCollection)\n            .borrow<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MFLPack.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMFLPack": {
          "MFLPack": {
            "testnet": {
              "address": "0x683564e46977788a",
              "contract": "MFLPack",
              "fq_address": "A.0x683564e46977788a.MFLPack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95813510
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813514
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813518
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813519
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813520
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813525
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "44811b552c08310fe45d7b2fe6ae2a441a261e33e7b5855cd15646f1b1c44253": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "44811b552c08310fe45d7b2fe6ae2a441a261e33e7b5855cd15646f1b1c44253",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MFLPackCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MFLPackCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n            let collection <- MFLPack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLPackCollection)\n            }\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/public/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n\n        if (acct.getCapability<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection).borrow() == nil) {\n            acct.unlink(/private/MFLPackCollection)\n            acct.link<&MFLPack.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLPackCollection, target: /storage/MFLPackCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MFLPackCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMFLPack": {
          "MFLPack": {
            "testnet": {
              "address": "0x683564e46977788a",
              "contract": "MFLPack",
              "fq_address": "A.0x683564e46977788a.MFLPack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95813541
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813544
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813548
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813549
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813550
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813554
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "d63b8d3546d364f8f5c05471062c82ac31d75ec477de0b17b55f3852aa0fcad1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d63b8d3546d364f8f5c05471062c82ac31d75ec477de0b17b55f3852aa0fcad1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MFLPackCollection NFTs"
          }
        }
      },
      "cadence": "import MFLPack from 0xMFLPack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MFLPackCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MFLPack.Collection>(from: /storage/MFLPackCollection) == nil {\n      let collection <- MFLPack.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MFLPackCollection)\n    }\n    if (signer.getCapability<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection).borrow() == nil) {\n      signer.unlink(/public/MFLPackCollection)\n      signer.link<&MFLPack.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLPackCollection, target: /storage/MFLPackCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMFLPack": {
          "MFLPack": {
            "testnet": {
              "address": "0x683564e46977788a",
              "contract": "MFLPack",
              "fq_address": "A.0x683564e46977788a.MFLPack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95813486
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813490
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813495
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "63b533db74dc5f8a2d514a92cb41e264302af9f3e468c3ac20b6f25c52d6f816": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "63b533db74dc5f8a2d514a92cb41e264302af9f3e468c3ac20b6f25c52d6f816",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a MFLClubs NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: MFLClubs\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509102
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "7eec6fb762560228f168cb09b0f1e2b688c4c547f0ff1e74ad8d27c3b1ec86ba": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7eec6fb762560228f168cb09b0f1e2b688c4c547f0ff1e74ad8d27c3b1ec86ba",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a MFLClubs NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MFLClub from 0xMFLClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: MFLClubs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLClub.Collection>(from: /storage/MFLClubCollection) == nil {\n            let collection <- MFLClub.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLClubCollection)\n        }\n        if (acct.getCapability<&MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLClubCollection).borrow() == nil) {\n            acct.unlink(/public/MFLClubCollection)\n            acct.link<&MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLClubCollection, target: /storage/MFLClubCollection)\n        }\n\n        if (acct.getCapability<&MFLClub.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLClubCollection).borrow() == nil) {\n            acct.unlink(/private/MFLClubCollection)\n            acct.link<&MFLClub.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLClubCollection, target: /storage/MFLClubCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/MFLClubCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MFLClubCollection)\n            .borrow<&MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@MFLClub.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xMFLClub": {
          "MFLClub": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLClub",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509065
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509067
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509072
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509072
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509073
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509078
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "252b7a451bc4e5460e8df2a8cf098b4f3012b73ab1b4f13e58f1ba446b55d411": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "252b7a451bc4e5460e8df2a8cf098b4f3012b73ab1b4f13e58f1ba446b55d411",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed MFLClubs NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import MFLClub from 0xMFLClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: MFLClubs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&MFLClub.Collection>(from: /storage/MFLClubCollection) == nil {\n            let collection <- MFLClub.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MFLClubCollection)\n            }\n        if (acct.getCapability<&MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLClubCollection).borrow() == nil) {\n            acct.unlink(/public/MFLClubCollection)\n            acct.link<&MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLClubCollection, target: /storage/MFLClubCollection)\n        }\n\n        if (acct.getCapability<&MFLClub.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLClubCollection).borrow() == nil) {\n            acct.unlink(/private/MFLClubCollection)\n            acct.link<&MFLClub.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/MFLClubCollection, target: /storage/MFLClubCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MFLClubCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xMFLClub": {
          "MFLClub": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLClub",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509085
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509089
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509092
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509093
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509094
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509099
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "329ce30d9926042989980b1fd23e18a40ccb2c5da1171c1773717a48a6d36054": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "329ce30d9926042989980b1fd23e18a40ccb2c5da1171c1773717a48a6d36054",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support MFLClubs NFTs"
          }
        }
      },
      "cadence": "import MFLClub from 0xMFLClub\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: MFLClubs\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&MFLClub.Collection>(from: /storage/MFLClubCollection) == nil {\n      let collection <- MFLClub.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MFLClubCollection)\n    }\n    if (signer.getCapability<&MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLClubCollection).borrow() == nil) {\n      signer.unlink(/public/MFLClubCollection)\n      signer.link<&MFLClub.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/MFLClubCollection, target: /storage/MFLClubCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xMFLClub": {
          "MFLClub": {
            "mainnet": {
              "address": "0x8ebcbfd516b1da27",
              "contract": "MFLClub",
              "fq_address": "A.0x8ebcbfd516b1da27.MFLClub",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509050
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509052
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509057
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "075958f95ac195eef1bc3d95f21b520999790d82e6e3ded75ba7aa9768ac5997": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "075958f95ac195eef1bc3d95f21b520999790d82e6e3ded75ba7aa9768ac5997",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a LufthausStore NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: LufthausStore\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508396
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "e137a27b51e73281902a83bea6d7453e63ed6fec4a38f94841ce8a50ad4a316a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e137a27b51e73281902a83bea6d7453e63ed6fec4a38f94841ce8a50ad4a316a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a LufthausStore NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import LufthausNFT from 0xLufthausNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: LufthausStore\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&LufthausNFT.Collection>(from: /storage/LufthausNFTCollection) == nil {\n            let collection <- LufthausNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/LufthausNFTCollection)\n        }\n        if (acct.getCapability<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/LufthausNFTCollection).borrow() == nil) {\n            acct.unlink(/public/LufthausNFTCollection)\n            acct.link<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/LufthausNFTCollection, target: /storage/LufthausNFTCollection)\n        }\n\n        if (acct.getCapability<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/LufthausNFTCollection).borrow() == nil) {\n            acct.unlink(/private/LufthausNFTCollection)\n            acct.link<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/LufthausNFTCollection, target: /storage/LufthausNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/LufthausNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/LufthausNFTCollection)\n            .borrow<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@LufthausNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xLufthausNFT": {
          "LufthausNFT": {
            "mainnet": {
              "address": "0xa4e9020ad21eb30b",
              "contract": "LufthausNFT",
              "fq_address": "A.0xa4e9020ad21eb30b.LufthausNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508356
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508359
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508363
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508363
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508365
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508368
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b49ea48e9cc6e4fca23b20ccddcdcb1ba9e7a3e4899672e443c29ac210beae91": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b49ea48e9cc6e4fca23b20ccddcdcb1ba9e7a3e4899672e443c29ac210beae91",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed LufthausStore NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import LufthausNFT from 0xLufthausNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: LufthausStore\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&LufthausNFT.Collection>(from: /storage/LufthausNFTCollection) == nil {\n            let collection <- LufthausNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/LufthausNFTCollection)\n            }\n        if (acct.getCapability<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/LufthausNFTCollection).borrow() == nil) {\n            acct.unlink(/public/LufthausNFTCollection)\n            acct.link<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/LufthausNFTCollection, target: /storage/LufthausNFTCollection)\n        }\n\n        if (acct.getCapability<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/LufthausNFTCollection).borrow() == nil) {\n            acct.unlink(/private/LufthausNFTCollection)\n            acct.link<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/LufthausNFTCollection, target: /storage/LufthausNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/LufthausNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xLufthausNFT": {
          "LufthausNFT": {
            "mainnet": {
              "address": "0xa4e9020ad21eb30b",
              "contract": "LufthausNFT",
              "fq_address": "A.0xa4e9020ad21eb30b.LufthausNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508377
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508381
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508385
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508385
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508385
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508390
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "9df6f73024e80910ee03040ff0fd33d2a738badeacca9ca207cb6f2b5b8906d1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9df6f73024e80910ee03040ff0fd33d2a738badeacca9ca207cb6f2b5b8906d1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support LufthausStore NFTs"
          }
        }
      },
      "cadence": "import LufthausNFT from 0xLufthausNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: LufthausStore\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&LufthausNFT.Collection>(from: /storage/LufthausNFTCollection) == nil {\n      let collection <- LufthausNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/LufthausNFTCollection)\n    }\n    if (signer.getCapability<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/LufthausNFTCollection).borrow() == nil) {\n      signer.unlink(/public/LufthausNFTCollection)\n      signer.link<&LufthausNFT.Collection{LufthausNFT.LufthausNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/LufthausNFTCollection, target: /storage/LufthausNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xLufthausNFT": {
          "LufthausNFT": {
            "mainnet": {
              "address": "0xa4e9020ad21eb30b",
              "contract": "LufthausNFT",
              "fq_address": "A.0xa4e9020ad21eb30b.LufthausNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508340
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508343
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508346
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "1f726c7ade99ad682d8397ec5ec040e4095452ea7d0092602e9ff798ca00f61e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1f726c7ade99ad682d8397ec5ec040e4095452ea7d0092602e9ff798ca00f61e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a LOSTiNTurismo NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: LOSTiNTurismo\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508708
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95807862
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "c86d99042a66db91b78c2a8660fbe27f1c42c3344cf93e24194b063775ea9e20": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c86d99042a66db91b78c2a8660fbe27f1c42c3344cf93e24194b063775ea9e20",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a LaligaGolazos NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: LaligaGolazos\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507597
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806550
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "03c79a8c2ca57a86d9864af9fd0fd205f0f046f7d91524890db206f56ce2fba6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "03c79a8c2ca57a86d9864af9fd0fd205f0f046f7d91524890db206f56ce2fba6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a LaligaGolazos NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Golazos from 0xGolazos\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: LaligaGolazos\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Golazos.Collection>(from: /storage/GolazosNFTCollection) == nil {\n            let collection <- Golazos.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GolazosNFTCollection)\n        }\n        if (acct.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection).borrow() == nil) {\n            acct.unlink(/public/GolazosNFTCollection)\n            acct.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection, target: /storage/GolazosNFTCollection)\n        }\n\n        if (acct.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dapperSportCollection).borrow() == nil) {\n            acct.unlink(/private/dapperSportCollection)\n            acct.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dapperSportCollection, target: /storage/GolazosNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/dapperSportCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GolazosNFTCollection)\n            .borrow<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Golazos.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xGolazos": {
          "Golazos": {
            "mainnet": {
              "address": "0x87ca73a41bb50ad5",
              "contract": "Golazos",
              "fq_address": "A.0x87ca73a41bb50ad5.Golazos",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507516
            },
            "testnet": {
              "address": "0x1271da8a94edb0ff",
              "contract": "Golazos",
              "fq_address": "A.0x1271da8a94edb0ff.Golazos",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95806461
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507528
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806467
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507537
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806476
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507541
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95806479
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507541
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806480
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507545
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806489
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "46fe37e59e85e80f0a83d92e16c3e0f631e3fc5584d4a48b342c7605d5e6a8e7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "46fe37e59e85e80f0a83d92e16c3e0f631e3fc5584d4a48b342c7605d5e6a8e7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed LaligaGolazos NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Golazos from 0xGolazos\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: LaligaGolazos\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Golazos.Collection>(from: /storage/GolazosNFTCollection) == nil {\n            let collection <- Golazos.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GolazosNFTCollection)\n            }\n        if (acct.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection).borrow() == nil) {\n            acct.unlink(/public/GolazosNFTCollection)\n            acct.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection, target: /storage/GolazosNFTCollection)\n        }\n\n        if (acct.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dapperSportCollection).borrow() == nil) {\n            acct.unlink(/private/dapperSportCollection)\n            acct.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dapperSportCollection, target: /storage/GolazosNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/GolazosNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xGolazos": {
          "Golazos": {
            "mainnet": {
              "address": "0x87ca73a41bb50ad5",
              "contract": "Golazos",
              "fq_address": "A.0x87ca73a41bb50ad5.Golazos",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507560
            },
            "testnet": {
              "address": "0x1271da8a94edb0ff",
              "contract": "Golazos",
              "fq_address": "A.0x1271da8a94edb0ff.Golazos",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95806510
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507571
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806516
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507578
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806526
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507583
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95806528
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507586
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806529
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507589
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806540
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "9f441aeb0c523a95d60968352be09229a9421a6ab0ade24a128d12a80a520f00": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9f441aeb0c523a95d60968352be09229a9421a6ab0ade24a128d12a80a520f00",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support LaligaGolazos NFTs"
          }
        }
      },
      "cadence": "import Golazos from 0xGolazos\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: LaligaGolazos\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Golazos.Collection>(from: /storage/GolazosNFTCollection) == nil {\n      let collection <- Golazos.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GolazosNFTCollection)\n    }\n    if (signer.getCapability<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection).borrow() == nil) {\n      signer.unlink(/public/GolazosNFTCollection)\n      signer.link<&Golazos.Collection{Golazos.MomentNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GolazosNFTCollection, target: /storage/GolazosNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xGolazos": {
          "Golazos": {
            "mainnet": {
              "address": "0x87ca73a41bb50ad5",
              "contract": "Golazos",
              "fq_address": "A.0x87ca73a41bb50ad5.Golazos",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47507483
            },
            "testnet": {
              "address": "0x1271da8a94edb0ff",
              "contract": "Golazos",
              "fq_address": "A.0x1271da8a94edb0ff.Golazos",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95806425
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507496
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806431
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507503
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806441
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "9b7eff24ee2a96f64ecdab0765f82fd3e58dfb46a0047ba918164f5af537b009": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9b7eff24ee2a96f64ecdab0765f82fd3e58dfb46a0047ba918164f5af537b009",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Lufthaus NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Lufthaus\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499335
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796722
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "c6d57f0161781eeb9090dccbfb7aa1e3774cffe84a14779104f471971425fc08": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c6d57f0161781eeb9090dccbfb7aa1e3774cffe84a14779104f471971425fc08",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a KlktnVoucher NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: KlktnVoucher\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813705
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "407fba5a79f20fc934c0c574bb0db1c82f520b60f0d95eaa035f9c51fcb33d41": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "407fba5a79f20fc934c0c574bb0db1c82f520b60f0d95eaa035f9c51fcb33d41",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a KlktnVoucher NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import KlktnVoucher from 0xKlktnVoucher\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: KlktnVoucher\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&KlktnVoucher.Collection>(from: /storage/KlktnVoucherCollection) == nil {\n            let collection <- KlktnVoucher.createEmptyCollection()\n            acct.save(<-collection, to: /storage/KlktnVoucherCollection)\n        }\n        if (acct.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection).borrow() == nil) {\n            acct.unlink(/public/KlktnVoucherCollection)\n            acct.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection, target: /storage/KlktnVoucherCollection)\n        }\n\n        if (acct.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KlktnVoucherPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/KlktnVoucherPrivateProvider)\n            acct.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KlktnVoucherPrivateProvider, target: /storage/KlktnVoucherCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/KlktnVoucherPrivateProvider)!\n        let collectionRef = acct\n            .getCapability(/public/KlktnVoucherCollection)\n            .borrow<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@KlktnVoucher.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xKlktnVoucher": {
          "KlktnVoucher": {
            "testnet": {
              "address": "0x21344d9b7e93ade6",
              "contract": "KlktnVoucher",
              "fq_address": "A.0x21344d9b7e93ade6.KlktnVoucher",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813661
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813665
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813669
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813670
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813671
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813676
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "50aeed3774085d8939c7e36d004375ea14947a9507bbfc30c11c180e1f6201b2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "50aeed3774085d8939c7e36d004375ea14947a9507bbfc30c11c180e1f6201b2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed KlktnVoucher NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import KlktnVoucher from 0xKlktnVoucher\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: KlktnVoucher\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&KlktnVoucher.Collection>(from: /storage/KlktnVoucherCollection) == nil {\n            let collection <- KlktnVoucher.createEmptyCollection()\n            acct.save(<-collection, to: /storage/KlktnVoucherCollection)\n            }\n        if (acct.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection).borrow() == nil) {\n            acct.unlink(/public/KlktnVoucherCollection)\n            acct.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection, target: /storage/KlktnVoucherCollection)\n        }\n\n        if (acct.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KlktnVoucherPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/KlktnVoucherPrivateProvider)\n            acct.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/KlktnVoucherPrivateProvider, target: /storage/KlktnVoucherCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/KlktnVoucherCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xKlktnVoucher": {
          "KlktnVoucher": {
            "testnet": {
              "address": "0x21344d9b7e93ade6",
              "contract": "KlktnVoucher",
              "fq_address": "A.0x21344d9b7e93ade6.KlktnVoucher",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813686
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813689
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813694
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813695
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813695
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813700
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "95987f8a699d615a651506ad8f5095816a4c3f8b27006963a3b9a5ccc61d1cdc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "95987f8a699d615a651506ad8f5095816a4c3f8b27006963a3b9a5ccc61d1cdc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support KlktnVoucher NFTs"
          }
        }
      },
      "cadence": "import KlktnVoucher from 0xKlktnVoucher\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: KlktnVoucher\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&KlktnVoucher.Collection>(from: /storage/KlktnVoucherCollection) == nil {\n      let collection <- KlktnVoucher.createEmptyCollection()\n      signer.save(<-collection, to: /storage/KlktnVoucherCollection)\n    }\n    if (signer.getCapability<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection).borrow() == nil) {\n      signer.unlink(/public/KlktnVoucherCollection)\n      signer.link<&KlktnVoucher.Collection{NonFungibleToken.CollectionPublic,KlktnVoucher.KlktnVoucherCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/KlktnVoucherCollection, target: /storage/KlktnVoucherCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xKlktnVoucher": {
          "KlktnVoucher": {
            "testnet": {
              "address": "0x21344d9b7e93ade6",
              "contract": "KlktnVoucher",
              "fq_address": "A.0x21344d9b7e93ade6.KlktnVoucher",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95813643
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813647
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813652
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "c098417deab4a1a144f6f3b42f9614fcbde0347241a0a2aba182c3dd3e190fd2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c098417deab4a1a144f6f3b42f9614fcbde0347241a0a2aba182c3dd3e190fd2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a JukeFrames NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: JukeFrames\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493374
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "4130294571b25d8ddca455a26ba6bfad7c658e336e4396c69af51148fc6e4bd5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4130294571b25d8ddca455a26ba6bfad7c658e336e4396c69af51148fc6e4bd5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a JukeFrames NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Frames from 0xFrames\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: JukeFrames\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Frames.Collection>(from: /storage/FramesCollection) == nil {\n            let collection <- Frames.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FramesCollection)\n        }\n        if (acct.getCapability<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FramesCollection).borrow() == nil) {\n            acct.unlink(/public/FramesCollection)\n            acct.link<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FramesCollection, target: /storage/FramesCollection)\n        }\n\n        if (acct.getCapability<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FramesCollection).borrow() == nil) {\n            acct.unlink(/private/FramesCollection)\n            acct.link<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FramesCollection, target: /storage/FramesCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FramesCollection)!\n        let collectionRef = acct\n            .getCapability(/public/FramesCollection)\n            .borrow<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Frames.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xFrames": {
          "Frames": {
            "mainnet": {
              "address": "0xe23c123e8c93c9eb",
              "contract": "Frames",
              "fq_address": "A.0xe23c123e8c93c9eb.Frames",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493336
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493339
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493342
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493344
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493344
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493347
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "8c4b0c0896bd779cd50fdae8f7383cfd2f59937fd9014ac68d0b038b0268b516": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8c4b0c0896bd779cd50fdae8f7383cfd2f59937fd9014ac68d0b038b0268b516",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed JukeFrames NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Frames from 0xFrames\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: JukeFrames\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Frames.Collection>(from: /storage/FramesCollection) == nil {\n            let collection <- Frames.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FramesCollection)\n            }\n        if (acct.getCapability<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FramesCollection).borrow() == nil) {\n            acct.unlink(/public/FramesCollection)\n            acct.link<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FramesCollection, target: /storage/FramesCollection)\n        }\n\n        if (acct.getCapability<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FramesCollection).borrow() == nil) {\n            acct.unlink(/private/FramesCollection)\n            acct.link<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FramesCollection, target: /storage/FramesCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/FramesCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xFrames": {
          "Frames": {
            "mainnet": {
              "address": "0xe23c123e8c93c9eb",
              "contract": "Frames",
              "fq_address": "A.0xe23c123e8c93c9eb.Frames",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493356
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493359
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493363
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493363
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493365
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493369
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "12791f45405a53a569753866370a17d7abda9cbc6e2058ffd501e3f71b39e917": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "12791f45405a53a569753866370a17d7abda9cbc6e2058ffd501e3f71b39e917",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support JukeFrames NFTs"
          }
        }
      },
      "cadence": "import Frames from 0xFrames\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: JukeFrames\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Frames.Collection>(from: /storage/FramesCollection) == nil {\n      let collection <- Frames.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FramesCollection)\n    }\n    if (signer.getCapability<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FramesCollection).borrow() == nil) {\n      signer.unlink(/public/FramesCollection)\n      signer.link<&Frames.Collection{Frames.FramesCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FramesCollection, target: /storage/FramesCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xFrames": {
          "Frames": {
            "mainnet": {
              "address": "0xe23c123e8c93c9eb",
              "contract": "Frames",
              "fq_address": "A.0xe23c123e8c93c9eb.Frames",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493319
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493323
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493326
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "6f50f16780e3b9b5235ac24b55feabaec91b2feca9c8062a2e2c5831bf91c3c8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6f50f16780e3b9b5235ac24b55feabaec91b2feca9c8062a2e2c5831bf91c3c8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a JollyJokers NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: JollyJokers\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506826
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805643
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "0779a76f27ee9aa655f9f5c0856d3344c3cbd4117af20d453d35234d42f46bb5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0779a76f27ee9aa655f9f5c0856d3344c3cbd4117af20d453d35234d42f46bb5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a JollyJokers NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import JollyJokers from 0xJollyJokers\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: JollyJokers\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&JollyJokers.Collection>(from: /storage/JollyJokersCollection) == nil {\n            let collection <- JollyJokers.createEmptyCollection()\n            acct.save(<-collection, to: /storage/JollyJokersCollection)\n        }\n        if (acct.getCapability<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection).borrow() == nil) {\n            acct.unlink(/public/JollyJokersCollection)\n            acct.link<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection, target: /storage/JollyJokersCollection)\n        }\n\n        if (acct.getCapability<&JollyJokers.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection).borrow() == nil) {\n            acct.unlink(/private/findCharityCollection)\n            acct.link<&JollyJokers.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection, target: /storage/JollyJokersCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/findCharityCollection)!\n        let collectionRef = acct\n            .getCapability(/public/JollyJokersCollection)\n            .borrow<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@JollyJokers.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xJollyJokers": {
          "JollyJokers": {
            "mainnet": {
              "address": "0x699bf284101a76f1",
              "contract": "JollyJokers",
              "fq_address": "A.0x699bf284101a76f1.JollyJokers",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506748
            },
            "testnet": {
              "address": "0xe9760069d688ef5e",
              "contract": "JollyJokers",
              "fq_address": "A.0xe9760069d688ef5e.JollyJokers",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95805554
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506759
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805561
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506766
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805571
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506772
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95805573
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506772
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805574
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506778
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805584
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "db57a7ad6c8de429f6f3bcc6daa4c0040a91432066bdd06948d25ca9625922c8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "db57a7ad6c8de429f6f3bcc6daa4c0040a91432066bdd06948d25ca9625922c8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed JollyJokers NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import JollyJokers from 0xJollyJokers\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: JollyJokers\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&JollyJokers.Collection>(from: /storage/JollyJokersCollection) == nil {\n            let collection <- JollyJokers.createEmptyCollection()\n            acct.save(<-collection, to: /storage/JollyJokersCollection)\n            }\n        if (acct.getCapability<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection).borrow() == nil) {\n            acct.unlink(/public/JollyJokersCollection)\n            acct.link<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection, target: /storage/JollyJokersCollection)\n        }\n\n        if (acct.getCapability<&JollyJokers.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection).borrow() == nil) {\n            acct.unlink(/private/findCharityCollection)\n            acct.link<&JollyJokers.Collection{NonFungibleToken.Provider,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/private/findCharityCollection, target: /storage/JollyJokersCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/JollyJokersCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xJollyJokers": {
          "JollyJokers": {
            "mainnet": {
              "address": "0x699bf284101a76f1",
              "contract": "JollyJokers",
              "fq_address": "A.0x699bf284101a76f1.JollyJokers",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506789
            },
            "testnet": {
              "address": "0xe9760069d688ef5e",
              "contract": "JollyJokers",
              "fq_address": "A.0xe9760069d688ef5e.JollyJokers",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95805604
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506800
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805611
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506808
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805620
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506813
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95805623
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506814
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805624
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506819
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805633
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "2219c917eb9e3c9671deea0bf9c014aaeac082c5eb416e80238aaa52d303603c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2219c917eb9e3c9671deea0bf9c014aaeac082c5eb416e80238aaa52d303603c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support JollyJokers NFTs"
          }
        }
      },
      "cadence": "import JollyJokers from 0xJollyJokers\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: JollyJokers\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&JollyJokers.Collection>(from: /storage/JollyJokersCollection) == nil {\n      let collection <- JollyJokers.createEmptyCollection()\n      signer.save(<-collection, to: /storage/JollyJokersCollection)\n    }\n    if (signer.getCapability<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection).borrow() == nil) {\n      signer.unlink(/public/JollyJokersCollection)\n      signer.link<&JollyJokers.Collection{NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,JollyJokers.JollyJokersCollectionPublic,MetadataViews.ResolverCollection}>(/public/JollyJokersCollection, target: /storage/JollyJokersCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xJollyJokers": {
          "JollyJokers": {
            "mainnet": {
              "address": "0x699bf284101a76f1",
              "contract": "JollyJokers",
              "fq_address": "A.0x699bf284101a76f1.JollyJokers",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506718
            },
            "testnet": {
              "address": "0xe9760069d688ef5e",
              "contract": "JollyJokers",
              "fq_address": "A.0xe9760069d688ef5e.JollyJokers",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95805517
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506730
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95805525
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506735
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805534
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "c5461f3ca9af52b642bdbfa1413b8a791a97fd0c146beb43466e0c315d982400": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c5461f3ca9af52b642bdbfa1413b8a791a97fd0c146beb43466e0c315d982400",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a JukeReels NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: JukeReels\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509558
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "fe299af09b0da9536a83844b76afb976ed8052d270c421fc1ed7fc4f60d47aa3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fe299af09b0da9536a83844b76afb976ed8052d270c421fc1ed7fc4f60d47aa3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a JukeReels NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Reels from 0xReels\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: JukeReels\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Reels.Collection>(from: /storage/ReelsCollection) == nil {\n            let collection <- Reels.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ReelsCollection)\n        }\n        if (acct.getCapability<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ReelsCollection).borrow() == nil) {\n            acct.unlink(/public/ReelsCollection)\n            acct.link<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ReelsCollection, target: /storage/ReelsCollection)\n        }\n\n        if (acct.getCapability<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ReelsCollection).borrow() == nil) {\n            acct.unlink(/private/ReelsCollection)\n            acct.link<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ReelsCollection, target: /storage/ReelsCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/ReelsCollection)!\n        let collectionRef = acct\n            .getCapability(/public/ReelsCollection)\n            .borrow<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Reels.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xReels": {
          "Reels": {
            "mainnet": {
              "address": "0xe23c123e8c93c9eb",
              "contract": "Reels",
              "fq_address": "A.0xe23c123e8c93c9eb.Reels",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509516
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509521
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509524
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509525
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509525
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509530
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b6ce0e66a9fce3b91952b264aafb46fbe7844da3931ba42f1a97107fb9296f80": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b6ce0e66a9fce3b91952b264aafb46fbe7844da3931ba42f1a97107fb9296f80",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed JukeReels NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Reels from 0xReels\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: JukeReels\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Reels.Collection>(from: /storage/ReelsCollection) == nil {\n            let collection <- Reels.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ReelsCollection)\n            }\n        if (acct.getCapability<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ReelsCollection).borrow() == nil) {\n            acct.unlink(/public/ReelsCollection)\n            acct.link<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ReelsCollection, target: /storage/ReelsCollection)\n        }\n\n        if (acct.getCapability<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ReelsCollection).borrow() == nil) {\n            acct.unlink(/private/ReelsCollection)\n            acct.link<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ReelsCollection, target: /storage/ReelsCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/ReelsCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xReels": {
          "Reels": {
            "mainnet": {
              "address": "0xe23c123e8c93c9eb",
              "contract": "Reels",
              "fq_address": "A.0xe23c123e8c93c9eb.Reels",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509539
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509543
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509548
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509549
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509550
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509554
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "44b00ce52733b543684625c169084df6377a8e228ccbae0c177d682c74b93bbc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "44b00ce52733b543684625c169084df6377a8e228ccbae0c177d682c74b93bbc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support JukeReels NFTs"
          }
        }
      },
      "cadence": "import Reels from 0xReels\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: JukeReels\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Reels.Collection>(from: /storage/ReelsCollection) == nil {\n      let collection <- Reels.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ReelsCollection)\n    }\n    if (signer.getCapability<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ReelsCollection).borrow() == nil) {\n      signer.unlink(/public/ReelsCollection)\n      signer.link<&Reels.Collection{Reels.ReelsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ReelsCollection, target: /storage/ReelsCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xReels": {
          "Reels": {
            "mainnet": {
              "address": "0xe23c123e8c93c9eb",
              "contract": "Reels",
              "fq_address": "A.0xe23c123e8c93c9eb.Reels",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47509500
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509503
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509508
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "6df4d42fd1c83fd760c947469a8aa6b4428f12064a4e5be21f5d44e911c7b578": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6df4d42fd1c83fd760c947469a8aa6b4428f12064a4e5be21f5d44e911c7b578",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a InceptionBlackBox NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: InceptionBlackBox\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500017
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "f99adb335c9c23a8ea5b2195c71494615f672d9344a17ea102233d03abb05bcf": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f99adb335c9c23a8ea5b2195c71494615f672d9344a17ea102233d03abb05bcf",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a InceptionBlackBox NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import InceptionBlackBox from 0xInceptionBlackBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: InceptionBlackBox\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&InceptionBlackBox.Collection>(from: /storage/InceptionBlackBoxCollection) == nil {\n            let collection <- InceptionBlackBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/InceptionBlackBoxCollection)\n        }\n        if (acct.getCapability<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionBlackBoxCollection).borrow() == nil) {\n            acct.unlink(/public/InceptionBlackBoxCollection)\n            acct.link<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionBlackBoxCollection, target: /storage/InceptionBlackBoxCollection)\n        }\n\n        if (acct.getCapability<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/InceptionAvatarCollection).borrow() == nil) {\n            acct.unlink(/private/InceptionAvatarCollection)\n            acct.link<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/InceptionAvatarCollection, target: /storage/InceptionBlackBoxCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/InceptionAvatarCollection)!\n        let collectionRef = acct\n            .getCapability(/public/InceptionBlackBoxCollection)\n            .borrow<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@InceptionBlackBox.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xInceptionBlackBox": {
          "InceptionBlackBox": {
            "mainnet": {
              "address": "0x83ed64a1d4f3833f",
              "contract": "InceptionBlackBox",
              "fq_address": "A.0x83ed64a1d4f3833f.InceptionBlackBox",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47499978
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499981
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499984
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499985
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499985
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499990
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b4c000b911b966b5628058a925550ee7f454f96cf08a20f94a05254837bf00c0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b4c000b911b966b5628058a925550ee7f454f96cf08a20f94a05254837bf00c0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed InceptionBlackBox NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import InceptionBlackBox from 0xInceptionBlackBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: InceptionBlackBox\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&InceptionBlackBox.Collection>(from: /storage/InceptionBlackBoxCollection) == nil {\n            let collection <- InceptionBlackBox.createEmptyCollection()\n            acct.save(<-collection, to: /storage/InceptionBlackBoxCollection)\n            }\n        if (acct.getCapability<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionBlackBoxCollection).borrow() == nil) {\n            acct.unlink(/public/InceptionBlackBoxCollection)\n            acct.link<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionBlackBoxCollection, target: /storage/InceptionBlackBoxCollection)\n        }\n\n        if (acct.getCapability<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/InceptionAvatarCollection).borrow() == nil) {\n            acct.unlink(/private/InceptionAvatarCollection)\n            acct.link<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/InceptionAvatarCollection, target: /storage/InceptionBlackBoxCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/InceptionBlackBoxCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xInceptionBlackBox": {
          "InceptionBlackBox": {
            "mainnet": {
              "address": "0x83ed64a1d4f3833f",
              "contract": "InceptionBlackBox",
              "fq_address": "A.0x83ed64a1d4f3833f.InceptionBlackBox",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47500000
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500003
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500008
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47500008
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500009
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500012
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e1a3b7f6bc52648e05d15a33984b4024dbe2b056745ddd49137237e2df3f2b37": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e1a3b7f6bc52648e05d15a33984b4024dbe2b056745ddd49137237e2df3f2b37",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support InceptionBlackBox NFTs"
          }
        }
      },
      "cadence": "import InceptionBlackBox from 0xInceptionBlackBox\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: InceptionBlackBox\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&InceptionBlackBox.Collection>(from: /storage/InceptionBlackBoxCollection) == nil {\n      let collection <- InceptionBlackBox.createEmptyCollection()\n      signer.save(<-collection, to: /storage/InceptionBlackBoxCollection)\n    }\n    if (signer.getCapability<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionBlackBoxCollection).borrow() == nil) {\n      signer.unlink(/public/InceptionBlackBoxCollection)\n      signer.link<&InceptionBlackBox.Collection{InceptionBlackBox.InceptionBlackBoxCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionBlackBoxCollection, target: /storage/InceptionBlackBoxCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xInceptionBlackBox": {
          "InceptionBlackBox": {
            "mainnet": {
              "address": "0x83ed64a1d4f3833f",
              "contract": "InceptionBlackBox",
              "fq_address": "A.0x83ed64a1d4f3833f.InceptionBlackBox",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47499962
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499966
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499970
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "2b85a47528173c083bd712e6156bbaf57ef4e999b8cf1e75677852450393c33e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2b85a47528173c083bd712e6156bbaf57ef4e999b8cf1e75677852450393c33e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a InceptionAvatar NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: InceptionAvatar\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500079
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "8010fd2e65e6169e9f8051c3a96a7974fe601ed3c25f19d33e92f1d35c11cd2b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8010fd2e65e6169e9f8051c3a96a7974fe601ed3c25f19d33e92f1d35c11cd2b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a InceptionAvatar NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import InceptionAvatar from 0xInceptionAvatar\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: InceptionAvatar\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&InceptionAvatar.Collection>(from: /storage/InceptionAvatarCollection) == nil {\n            let collection <- InceptionAvatar.createEmptyCollection()\n            acct.save(<-collection, to: /storage/InceptionAvatarCollection)\n        }\n        if (acct.getCapability<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionAvatarCollection).borrow() == nil) {\n            acct.unlink(/public/InceptionAvatarCollection)\n            acct.link<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionAvatarCollection, target: /storage/InceptionAvatarCollection)\n        }\n\n        if (acct.getCapability<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/InceptionAvatarCollection).borrow() == nil) {\n            acct.unlink(/private/InceptionAvatarCollection)\n            acct.link<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/InceptionAvatarCollection, target: /storage/InceptionAvatarCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/InceptionAvatarCollection)!\n        let collectionRef = acct\n            .getCapability(/public/InceptionAvatarCollection)\n            .borrow<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@InceptionAvatar.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xInceptionAvatar": {
          "InceptionAvatar": {
            "mainnet": {
              "address": "0x83ed64a1d4f3833f",
              "contract": "InceptionAvatar",
              "fq_address": "A.0x83ed64a1d4f3833f.InceptionAvatar",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47500042
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500045
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500048
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47500050
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500050
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500053
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "3c9dbde9dfafcfd62091163f0c3c13fb770e3510d217c4a670147f0d018f6992": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3c9dbde9dfafcfd62091163f0c3c13fb770e3510d217c4a670147f0d018f6992",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed InceptionAvatar NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import InceptionAvatar from 0xInceptionAvatar\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: InceptionAvatar\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&InceptionAvatar.Collection>(from: /storage/InceptionAvatarCollection) == nil {\n            let collection <- InceptionAvatar.createEmptyCollection()\n            acct.save(<-collection, to: /storage/InceptionAvatarCollection)\n            }\n        if (acct.getCapability<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionAvatarCollection).borrow() == nil) {\n            acct.unlink(/public/InceptionAvatarCollection)\n            acct.link<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionAvatarCollection, target: /storage/InceptionAvatarCollection)\n        }\n\n        if (acct.getCapability<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/InceptionAvatarCollection).borrow() == nil) {\n            acct.unlink(/private/InceptionAvatarCollection)\n            acct.link<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/InceptionAvatarCollection, target: /storage/InceptionAvatarCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/InceptionAvatarCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xInceptionAvatar": {
          "InceptionAvatar": {
            "mainnet": {
              "address": "0x83ed64a1d4f3833f",
              "contract": "InceptionAvatar",
              "fq_address": "A.0x83ed64a1d4f3833f.InceptionAvatar",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47500062
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500065
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500069
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47500071
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500071
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500074
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f0ced7377a3097645f361219e70c0fe20ea0288f6b6b90b0aa48acd615859ab9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f0ced7377a3097645f361219e70c0fe20ea0288f6b6b90b0aa48acd615859ab9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support InceptionAvatar NFTs"
          }
        }
      },
      "cadence": "import InceptionAvatar from 0xInceptionAvatar\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: InceptionAvatar\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&InceptionAvatar.Collection>(from: /storage/InceptionAvatarCollection) == nil {\n      let collection <- InceptionAvatar.createEmptyCollection()\n      signer.save(<-collection, to: /storage/InceptionAvatarCollection)\n    }\n    if (signer.getCapability<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionAvatarCollection).borrow() == nil) {\n      signer.unlink(/public/InceptionAvatarCollection)\n      signer.link<&InceptionAvatar.Collection{InceptionAvatar.InceptionAvatarCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/InceptionAvatarCollection, target: /storage/InceptionAvatarCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xInceptionAvatar": {
          "InceptionAvatar": {
            "mainnet": {
              "address": "0x83ed64a1d4f3833f",
              "contract": "InceptionAvatar",
              "fq_address": "A.0x83ed64a1d4f3833f.InceptionAvatar",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47500025
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47500030
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47500033
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "316f14c6aa089d1f700bb92effeb76d72c7fdab94ffcc9741b5ab8a855fc1a9d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "316f14c6aa089d1f700bb92effeb76d72c7fdab94ffcc9741b5ab8a855fc1a9d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Hoodlums NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Hoodlums\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496940
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "775cda12715593faf6d98c7f60df090513b2ec0b49f3b45437ca7887a92366fc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "775cda12715593faf6d98c7f60df090513b2ec0b49f3b45437ca7887a92366fc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Hoodlums NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SturdyItems from 0xSturdyItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Hoodlums\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SturdyItems.Collection>(from: /storage/SturdyItemsCollection) == nil {\n            let collection <- SturdyItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SturdyItemsCollection)\n        }\n        if (acct.getCapability<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyItemsCollection).borrow() == nil) {\n            acct.unlink(/public/SturdyItemsCollection)\n            acct.link<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyItemsCollection, target: /storage/SturdyItemsCollection)\n        }\n\n        if (acct.getCapability<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SturdyItemsCollection).borrow() == nil) {\n            acct.unlink(/private/SturdyItemsCollection)\n            acct.link<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SturdyItemsCollection, target: /storage/SturdyItemsCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/SturdyItemsCollection)!\n        let collectionRef = acct\n            .getCapability(/public/SturdyItemsCollection)\n            .borrow<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@SturdyItems.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xSturdyItems": {
          "SturdyItems": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "SturdyItems",
              "fq_address": "A.0x427ceada271aa0b1.SturdyItems",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47496903
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496908
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496911
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47496912
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496912
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496915
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "2277a05ced2582a85bafeb3bc31c408d4b8a201f650e346673db439952dd5cae": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2277a05ced2582a85bafeb3bc31c408d4b8a201f650e346673db439952dd5cae",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Hoodlums NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import SturdyItems from 0xSturdyItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Hoodlums\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&SturdyItems.Collection>(from: /storage/SturdyItemsCollection) == nil {\n            let collection <- SturdyItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/SturdyItemsCollection)\n            }\n        if (acct.getCapability<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyItemsCollection).borrow() == nil) {\n            acct.unlink(/public/SturdyItemsCollection)\n            acct.link<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyItemsCollection, target: /storage/SturdyItemsCollection)\n        }\n\n        if (acct.getCapability<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SturdyItemsCollection).borrow() == nil) {\n            acct.unlink(/private/SturdyItemsCollection)\n            acct.link<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/SturdyItemsCollection, target: /storage/SturdyItemsCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/SturdyItemsCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xSturdyItems": {
          "SturdyItems": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "SturdyItems",
              "fq_address": "A.0x427ceada271aa0b1.SturdyItems",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47496924
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496927
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496931
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47496932
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496933
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496936
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e6b3ab01c668a975559d058fa3ee3ca7f2a3474c8108be8da475c976e63c7720": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e6b3ab01c668a975559d058fa3ee3ca7f2a3474c8108be8da475c976e63c7720",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Hoodlums NFTs"
          }
        }
      },
      "cadence": "import SturdyItems from 0xSturdyItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Hoodlums\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&SturdyItems.Collection>(from: /storage/SturdyItemsCollection) == nil {\n      let collection <- SturdyItems.createEmptyCollection()\n      signer.save(<-collection, to: /storage/SturdyItemsCollection)\n    }\n    if (signer.getCapability<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyItemsCollection).borrow() == nil) {\n      signer.unlink(/public/SturdyItemsCollection)\n      signer.link<&SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/SturdyItemsCollection, target: /storage/SturdyItemsCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xSturdyItems": {
          "SturdyItems": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "SturdyItems",
              "fq_address": "A.0x427ceada271aa0b1.SturdyItems",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47496879
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496883
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496889
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "05603d0dfed4d9990df5b29b40aebbb32965ead37f3f5f4865e9a38924d2b089": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "05603d0dfed4d9990df5b29b40aebbb32965ead37f3f5f4865e9a38924d2b089",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a IceTraeDiamondHands NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: IceTraeDiamondHands\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509429
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "122f91e96389b4e12be533a270a463e10340de54c98758ce1c749255344fa0fb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "122f91e96389b4e12be533a270a463e10340de54c98758ce1c749255344fa0fb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a IceTraeDiamondHands NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import IceTraeDiamondHands from 0xIceTraeDiamondHands\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: IceTraeDiamondHands\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&IceTraeDiamondHands.Collection>(from: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256) == nil {\n            let collection <- IceTraeDiamondHands.createEmptyCollection()\n            acct.save(<-collection, to: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n        }\n        if (acct.getCapability<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256).borrow() == nil) {\n            acct.unlink(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n            acct.link<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256, target: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n        }\n\n        if (acct.getCapability<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/IceTraeDiamondHandsCollection_0xbb39f0dae1547256).borrow() == nil) {\n            acct.unlink(/private/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n            acct.link<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/IceTraeDiamondHandsCollection_0xbb39f0dae1547256, target: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)!\n        let collectionRef = acct\n            .getCapability(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n            .borrow<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@IceTraeDiamondHands.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xIceTraeDiamondHands": {
          "IceTraeDiamondHands": {
            "mainnet": {
              "address": "0xbb39f0dae1547256",
              "contract": "IceTraeDiamondHands",
              "fq_address": "A.0xbb39f0dae1547256.IceTraeDiamondHands",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47509359
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509363
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509367
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509367
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509368
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509373
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "09f5fe781c2956f016f0e62741d7f3a549ad8d3640aaf18d05a834a143538cde": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "09f5fe781c2956f016f0e62741d7f3a549ad8d3640aaf18d05a834a143538cde",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed IceTraeDiamondHands NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import IceTraeDiamondHands from 0xIceTraeDiamondHands\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: IceTraeDiamondHands\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&IceTraeDiamondHands.Collection>(from: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256) == nil {\n            let collection <- IceTraeDiamondHands.createEmptyCollection()\n            acct.save(<-collection, to: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n            }\n        if (acct.getCapability<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256).borrow() == nil) {\n            acct.unlink(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n            acct.link<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256, target: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n        }\n\n        if (acct.getCapability<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/IceTraeDiamondHandsCollection_0xbb39f0dae1547256).borrow() == nil) {\n            acct.unlink(/private/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n            acct.link<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/IceTraeDiamondHandsCollection_0xbb39f0dae1547256, target: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xIceTraeDiamondHands": {
          "IceTraeDiamondHands": {
            "mainnet": {
              "address": "0xbb39f0dae1547256",
              "contract": "IceTraeDiamondHands",
              "fq_address": "A.0xbb39f0dae1547256.IceTraeDiamondHands",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47509409
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509414
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509417
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509418
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509420
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509423
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "d76d8981368c1e690471f2e33bb9a3460f834d29856de1c0cedd0443f2177ef7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d76d8981368c1e690471f2e33bb9a3460f834d29856de1c0cedd0443f2177ef7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support IceTraeDiamondHands NFTs"
          }
        }
      },
      "cadence": "import IceTraeDiamondHands from 0xIceTraeDiamondHands\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: IceTraeDiamondHands\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&IceTraeDiamondHands.Collection>(from: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256) == nil {\n      let collection <- IceTraeDiamondHands.createEmptyCollection()\n      signer.save(<-collection, to: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n    }\n    if (signer.getCapability<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256).borrow() == nil) {\n      signer.unlink(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n      signer.link<&IceTraeDiamondHands.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/IceTraeDiamondHandsCollection_0xbb39f0dae1547256, target: /storage/IceTraeDiamondHandsCollection_0xbb39f0dae1547256)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xIceTraeDiamondHands": {
          "IceTraeDiamondHands": {
            "mainnet": {
              "address": "0xbb39f0dae1547256",
              "contract": "IceTraeDiamondHands",
              "fq_address": "A.0xbb39f0dae1547256.IceTraeDiamondHands",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47509317
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509320
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509324
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "1c633ef6d855fd516e662db9d31eda6ea873d81d8142371963c50a32d32ffe82": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1c633ef6d855fd516e662db9d31eda6ea873d81d8142371963c50a32d32ffe82",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a HelixAuto NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: HelixAuto\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497349
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794353
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "f0f430284f2dedf3a210f37964895d2e5e0f67870c371068d08c586719819e66": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f0f430284f2dedf3a210f37964895d2e5e0f67870c371068d08c586719819e66",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a HelixAuto NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import HelixAuto from 0xHelixAuto\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: HelixAuto\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&HelixAuto.Collection>(from: /storage/HelixAutoStorageV3) == nil {\n            let collection <- HelixAuto.createEmptyCollection()\n            acct.save(<-collection, to: /storage/HelixAutoStorageV3)\n        }\n        if (acct.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3).borrow() == nil) {\n            acct.unlink(/public/HelixAutoCollectionV3)\n            acct.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3, target: /storage/HelixAutoStorageV3)\n        }\n\n        if (acct.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/HelixAutoCollection).borrow() == nil) {\n            acct.unlink(/private/HelixAutoCollection)\n            acct.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/HelixAutoCollection, target: /storage/HelixAutoStorageV3)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/HelixAutoCollection)!\n        let collectionRef = acct\n            .getCapability(/public/HelixAutoCollectionV3)\n            .borrow<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@HelixAuto.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xHelixAuto": {
          "HelixAuto": {
            "mainnet": {
              "address": "0x92afad4cdc909ff8",
              "contract": "HelixAuto",
              "fq_address": "A.0x92afad4cdc909ff8.HelixAuto",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497268
            },
            "testnet": {
              "address": "0x3a3e01a9123f82e3",
              "contract": "HelixAuto",
              "fq_address": "A.0x3a3e01a9123f82e3.HelixAuto",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95794262
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497279
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794269
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497287
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794279
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497292
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95794281
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497294
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794282
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497299
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794292
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "a7c160458e6d8711b1f6c4c3cca87c31a2921e208843885247e66be4e811106b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a7c160458e6d8711b1f6c4c3cca87c31a2921e208843885247e66be4e811106b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed HelixAuto NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import HelixAuto from 0xHelixAuto\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: HelixAuto\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&HelixAuto.Collection>(from: /storage/HelixAutoStorageV3) == nil {\n            let collection <- HelixAuto.createEmptyCollection()\n            acct.save(<-collection, to: /storage/HelixAutoStorageV3)\n            }\n        if (acct.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3).borrow() == nil) {\n            acct.unlink(/public/HelixAutoCollectionV3)\n            acct.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3, target: /storage/HelixAutoStorageV3)\n        }\n\n        if (acct.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/HelixAutoCollection).borrow() == nil) {\n            acct.unlink(/private/HelixAutoCollection)\n            acct.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/HelixAutoCollection, target: /storage/HelixAutoStorageV3)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/HelixAutoStorageV3\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xHelixAuto": {
          "HelixAuto": {
            "mainnet": {
              "address": "0x92afad4cdc909ff8",
              "contract": "HelixAuto",
              "fq_address": "A.0x92afad4cdc909ff8.HelixAuto",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497312
            },
            "testnet": {
              "address": "0x3a3e01a9123f82e3",
              "contract": "HelixAuto",
              "fq_address": "A.0x3a3e01a9123f82e3.HelixAuto",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95794312
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497323
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794320
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497329
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794329
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497334
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95794331
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497335
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794333
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497339
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794343
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "51b1c121da67e7cde870e2d164c26fcb250c595e1e20d23340f529f3dd731f41": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "51b1c121da67e7cde870e2d164c26fcb250c595e1e20d23340f529f3dd731f41",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support HelixAuto NFTs"
          }
        }
      },
      "cadence": "import HelixAuto from 0xHelixAuto\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: HelixAuto\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&HelixAuto.Collection>(from: /storage/HelixAutoStorageV3) == nil {\n      let collection <- HelixAuto.createEmptyCollection()\n      signer.save(<-collection, to: /storage/HelixAutoStorageV3)\n    }\n    if (signer.getCapability<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3).borrow() == nil) {\n      signer.unlink(/public/HelixAutoCollectionV3)\n      signer.link<&HelixAuto.Collection{HelixAuto.HelixAutoCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/HelixAutoCollectionV3, target: /storage/HelixAutoStorageV3)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xHelixAuto": {
          "HelixAuto": {
            "mainnet": {
              "address": "0x92afad4cdc909ff8",
              "contract": "HelixAuto",
              "fq_address": "A.0x92afad4cdc909ff8.HelixAuto",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497236
            },
            "testnet": {
              "address": "0x3a3e01a9123f82e3",
              "contract": "HelixAuto",
              "fq_address": "A.0x3a3e01a9123f82e3.HelixAuto",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95794225
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497247
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794232
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497254
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794242
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "3d32d575ce0605cc6b8abe9e93d3361a5cb14d5c182be9f336143d4153eae074": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3d32d575ce0605cc6b8abe9e93d3361a5cb14d5c182be9f336143d4153eae074",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a GoatedGoatsTraits NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: GoatedGoatsTraits\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493306
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789554
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6d333bddf66461484b7c37767128dc652f21ad8698d2a2b3d80d5e7249175cd3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6d333bddf66461484b7c37767128dc652f21ad8698d2a2b3d80d5e7249175cd3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a GoatedGoatsTraits NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GoatedGoatsTrait from 0xGoatedGoatsTrait\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: GoatedGoatsTraits\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GoatedGoatsTrait.Collection>(from: /storage/GoatTraitCollection) == nil {\n            let collection <- GoatedGoatsTrait.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GoatTraitCollection)\n        }\n        if (acct.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection).borrow() == nil) {\n            acct.unlink(/public/GoatTraitCollection)\n            acct.link<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection, target: /storage/GoatTraitCollection)\n        }\n\n        if (acct.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatTraitCollection).borrow() == nil) {\n            acct.unlink(/private/GoatTraitCollection)\n            acct.link<&GoatedGoatsTrait.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatTraitCollection, target: /storage/GoatTraitCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/GoatTraitCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GoatTraitCollection)\n            .borrow<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@GoatedGoatsTrait.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xGoatedGoatsTrait": {
          "GoatedGoatsTrait": {
            "mainnet": {
              "address": "0x2068315349bdfce5",
              "contract": "GoatedGoatsTrait",
              "fq_address": "A.0x2068315349bdfce5.GoatedGoatsTrait",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493231
            },
            "testnet": {
              "address": "0x386817f360a5c8df",
              "contract": "GoatedGoatsTrait",
              "fq_address": "A.0x386817f360a5c8df.GoatedGoatsTrait",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95789463
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493243
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95789470
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493250
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789480
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493254
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95789483
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493256
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95789484
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493261
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789494
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "acc32e7101cd21151c9b967ac51a913ebfb26912d3e8e5ab9cb99d7c751d2e75": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "acc32e7101cd21151c9b967ac51a913ebfb26912d3e8e5ab9cb99d7c751d2e75",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed GoatedGoatsTraits NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GoatedGoatsTrait from 0xGoatedGoatsTrait\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: GoatedGoatsTraits\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GoatedGoatsTrait.Collection>(from: /storage/GoatTraitCollection) == nil {\n            let collection <- GoatedGoatsTrait.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GoatTraitCollection)\n            }\n        if (acct.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection).borrow() == nil) {\n            acct.unlink(/public/GoatTraitCollection)\n            acct.link<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection, target: /storage/GoatTraitCollection)\n        }\n\n        if (acct.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatTraitCollection).borrow() == nil) {\n            acct.unlink(/private/GoatTraitCollection)\n            acct.link<&GoatedGoatsTrait.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatTraitCollection, target: /storage/GoatTraitCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/GoatTraitCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xGoatedGoatsTrait": {
          "GoatedGoatsTrait": {
            "mainnet": {
              "address": "0x2068315349bdfce5",
              "contract": "GoatedGoatsTrait",
              "fq_address": "A.0x2068315349bdfce5.GoatedGoatsTrait",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493273
            },
            "testnet": {
              "address": "0x386817f360a5c8df",
              "contract": "GoatedGoatsTrait",
              "fq_address": "A.0x386817f360a5c8df.GoatedGoatsTrait",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95789514
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493285
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95789521
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493290
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789530
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47493295
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95789533
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493296
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95789534
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493297
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789544
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e51febd52c5ae906f6a054a4e7cb61f8c75e602639a11249ef4f20aa4bc624e3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e51febd52c5ae906f6a054a4e7cb61f8c75e602639a11249ef4f20aa4bc624e3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support GoatedGoatsTraits NFTs"
          }
        }
      },
      "cadence": "import GoatedGoatsTrait from 0xGoatedGoatsTrait\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: GoatedGoatsTraits\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&GoatedGoatsTrait.Collection>(from: /storage/GoatTraitCollection) == nil {\n      let collection <- GoatedGoatsTrait.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GoatTraitCollection)\n    }\n    if (signer.getCapability<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection).borrow() == nil) {\n      signer.unlink(/public/GoatTraitCollection)\n      signer.link<&GoatedGoatsTrait.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoatsTrait.TraitCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatTraitCollection, target: /storage/GoatTraitCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xGoatedGoatsTrait": {
          "GoatedGoatsTrait": {
            "mainnet": {
              "address": "0x2068315349bdfce5",
              "contract": "GoatedGoatsTrait",
              "fq_address": "A.0x2068315349bdfce5.GoatedGoatsTrait",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47493200
            },
            "testnet": {
              "address": "0x386817f360a5c8df",
              "contract": "GoatedGoatsTrait",
              "fq_address": "A.0x386817f360a5c8df.GoatedGoatsTrait",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95789426
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47493212
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95789433
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47493218
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95789443
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "d70ef3d316be2dadf5c498d937b1e0b28756c65d7fbb0cb9c8b09c57f3e84ed5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d70ef3d316be2dadf5c498d937b1e0b28756c65d7fbb0cb9c8b09c57f3e84ed5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Genies NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Genies\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506486
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "adfc3615fea84653177f41ef31d99aee171bb9a53a1ba6ac44427aa50aa91d82": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "adfc3615fea84653177f41ef31d99aee171bb9a53a1ba6ac44427aa50aa91d82",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Genies NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Genies from 0xGenies\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Genies\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Genies.Collection>(from: /storage/GeniesNFTCollection) == nil {\n            let collection <- Genies.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GeniesNFTCollection)\n        }\n        if (acct.getCapability<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GeniesNFTCollection).borrow() == nil) {\n            acct.unlink(/public/GeniesNFTCollection)\n            acct.link<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GeniesNFTCollection, target: /storage/GeniesNFTCollection)\n        }\n\n        if (acct.getCapability<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/GeniesNFTCollection).borrow() == nil) {\n            acct.unlink(/private/GeniesNFTCollection)\n            acct.link<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/GeniesNFTCollection, target: /storage/GeniesNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/GeniesNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GeniesNFTCollection)\n            .borrow<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Genies.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xGenies": {
          "Genies": {
            "mainnet": {
              "address": "0x12450e4bb3b7666e",
              "contract": "Genies",
              "fq_address": "A.0x12450e4bb3b7666e.Genies",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506447
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506450
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506453
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506454
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506455
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506459
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "47d981ee122d3e9650dbb560bdab2941a98aaf84940ff88b3f9dff7c93cbfa1f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "47d981ee122d3e9650dbb560bdab2941a98aaf84940ff88b3f9dff7c93cbfa1f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Genies NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Genies from 0xGenies\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Genies\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Genies.Collection>(from: /storage/GeniesNFTCollection) == nil {\n            let collection <- Genies.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GeniesNFTCollection)\n            }\n        if (acct.getCapability<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GeniesNFTCollection).borrow() == nil) {\n            acct.unlink(/public/GeniesNFTCollection)\n            acct.link<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GeniesNFTCollection, target: /storage/GeniesNFTCollection)\n        }\n\n        if (acct.getCapability<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/GeniesNFTCollection).borrow() == nil) {\n            acct.unlink(/private/GeniesNFTCollection)\n            acct.link<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/GeniesNFTCollection, target: /storage/GeniesNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/GeniesNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xGenies": {
          "Genies": {
            "mainnet": {
              "address": "0x12450e4bb3b7666e",
              "contract": "Genies",
              "fq_address": "A.0x12450e4bb3b7666e.Genies",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506469
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506471
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506476
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506476
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506476
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506480
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f347d24ce56775f5806570b6360c928842676a628baa364ebf313784571b303c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f347d24ce56775f5806570b6360c928842676a628baa364ebf313784571b303c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Genies NFTs"
          }
        }
      },
      "cadence": "import Genies from 0xGenies\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Genies\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Genies.Collection>(from: /storage/GeniesNFTCollection) == nil {\n      let collection <- Genies.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GeniesNFTCollection)\n    }\n    if (signer.getCapability<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GeniesNFTCollection).borrow() == nil) {\n      signer.unlink(/public/GeniesNFTCollection)\n      signer.link<&Genies.Collection{Genies.GeniesNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GeniesNFTCollection, target: /storage/GeniesNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xGenies": {
          "Genies": {
            "mainnet": {
              "address": "0x12450e4bb3b7666e",
              "contract": "Genies",
              "fq_address": "A.0x12450e4bb3b7666e.Genies",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506431
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506435
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506439
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "947a52bcecb7c7cc3830c02c12123134683e9114d3ec293f4d5ff1b1b4920918": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "947a52bcecb7c7cc3830c02c12123134683e9114d3ec293f4d5ff1b1b4920918",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a GoatedGoats NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: GoatedGoats\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507869
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806868
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "e2b7644888badded7d3e37d5bf40381303ae643d94e79b8092c712e5456d39cc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e2b7644888badded7d3e37d5bf40381303ae643d94e79b8092c712e5456d39cc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a GoatedGoats NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GoatedGoats from 0xGoatedGoats\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: GoatedGoats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GoatedGoats.Collection>(from: /storage/GoatCollection) == nil {\n            let collection <- GoatedGoats.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GoatCollection)\n        }\n        if (acct.getCapability<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection).borrow() == nil) {\n            acct.unlink(/public/GoatCollection)\n            acct.link<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection, target: /storage/GoatCollection)\n        }\n\n        if (acct.getCapability<&GoatedGoats.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatCollection).borrow() == nil) {\n            acct.unlink(/private/GoatCollection)\n            acct.link<&GoatedGoats.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatCollection, target: /storage/GoatCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/GoatCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GoatCollection)\n            .borrow<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@GoatedGoats.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xGoatedGoats": {
          "GoatedGoats": {
            "mainnet": {
              "address": "0x2068315349bdfce5",
              "contract": "GoatedGoats",
              "fq_address": "A.0x2068315349bdfce5.GoatedGoats",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47507769
            },
            "testnet": {
              "address": "0x386817f360a5c8df",
              "contract": "GoatedGoats",
              "fq_address": "A.0x386817f360a5c8df.GoatedGoats",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95806759
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507787
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806766
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507794
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806776
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507799
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95806778
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507801
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806779
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507806
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806789
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "cc424b077227fc24ab3e75f9c0055af4a62ba62a148b8000258594c65b2dbd36": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cc424b077227fc24ab3e75f9c0055af4a62ba62a148b8000258594c65b2dbd36",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed GoatedGoats NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GoatedGoats from 0xGoatedGoats\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: GoatedGoats\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GoatedGoats.Collection>(from: /storage/GoatCollection) == nil {\n            let collection <- GoatedGoats.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GoatCollection)\n            }\n        if (acct.getCapability<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection).borrow() == nil) {\n            acct.unlink(/public/GoatCollection)\n            acct.link<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection, target: /storage/GoatCollection)\n        }\n\n        if (acct.getCapability<&GoatedGoats.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatCollection).borrow() == nil) {\n            acct.unlink(/private/GoatCollection)\n            acct.link<&GoatedGoats.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/private/GoatCollection, target: /storage/GoatCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/GoatCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xGoatedGoats": {
          "GoatedGoats": {
            "mainnet": {
              "address": "0x2068315349bdfce5",
              "contract": "GoatedGoats",
              "fq_address": "A.0x2068315349bdfce5.GoatedGoats",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47507826
            },
            "testnet": {
              "address": "0x386817f360a5c8df",
              "contract": "GoatedGoats",
              "fq_address": "A.0x386817f360a5c8df.GoatedGoats",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95806828
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507843
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806836
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507850
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806845
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47507855
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95806847
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507857
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806848
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507861
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806858
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "40dcbea5bc522ae788fac496b74ebb5cecb752283a35a3a074cf64ade97bb847": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "40dcbea5bc522ae788fac496b74ebb5cecb752283a35a3a074cf64ade97bb847",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support GoatedGoats NFTs"
          }
        }
      },
      "cadence": "import GoatedGoats from 0xGoatedGoats\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: GoatedGoats\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&GoatedGoats.Collection>(from: /storage/GoatCollection) == nil {\n      let collection <- GoatedGoats.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GoatCollection)\n    }\n    if (signer.getCapability<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection).borrow() == nil) {\n      signer.unlink(/public/GoatCollection)\n      signer.link<&GoatedGoats.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,GoatedGoats.GoatCollectionPublic,MetadataViews.ResolverCollection}>(/public/GoatCollection, target: /storage/GoatCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xGoatedGoats": {
          "GoatedGoats": {
            "mainnet": {
              "address": "0x2068315349bdfce5",
              "contract": "GoatedGoats",
              "fq_address": "A.0x2068315349bdfce5.GoatedGoats",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 47507717
            },
            "testnet": {
              "address": "0x386817f360a5c8df",
              "contract": "GoatedGoats",
              "fq_address": "A.0x386817f360a5c8df.GoatedGoats",
              "pin": "36de04e524c1ae3d1ff6f87448f31576e302f6402d9505aed5ef3c9ca295b0de",
              "pin_block_height": 95806704
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47507740
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95806711
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507745
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95806721
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "0538d11be9703b8d7faab5d1d8817b249fbbc622eba5559f5ec5ad7c5305ca28": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0538d11be9703b8d7faab5d1d8817b249fbbc622eba5559f5ec5ad7c5305ca28",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a GaiaPackNFT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: GaiaPackNFT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492783
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "b2b50e674ba719bbba6ab8f12839a0b9bf41bfc690c788de555098d993a9a55a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b2b50e674ba719bbba6ab8f12839a0b9bf41bfc690c788de555098d993a9a55a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a GaiaPackNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GaiaPackNFT from 0xGaiaPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: GaiaPackNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GaiaPackNFT.Collection>(from: /storage/GaiaPackNFTCollection002) == nil {\n            let collection <- GaiaPackNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GaiaPackNFTCollection002)\n        }\n        if (acct.getCapability<&GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaPackNFTCollection002).borrow() == nil) {\n            acct.unlink(/public/GaiaPackNFTCollection002)\n            acct.link<&GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaPackNFTCollection002, target: /storage/GaiaPackNFTCollection002)\n        }\n\n        if (acct.getCapability<&GaiaPackNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/GaiaPackNFTCollection002).borrow() == nil) {\n            acct.unlink(/private/GaiaPackNFTCollection002)\n            acct.link<&GaiaPackNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/GaiaPackNFTCollection002, target: /storage/GaiaPackNFTCollection002)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/GaiaPackNFTCollection002)!\n        let collectionRef = acct\n            .getCapability(/public/GaiaPackNFTCollection002)\n            .borrow<&GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@GaiaPackNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xGaiaPackNFT": {
          "GaiaPackNFT": {
            "mainnet": {
              "address": "0xfdae91e14e960079",
              "contract": "GaiaPackNFT",
              "fq_address": "A.0xfdae91e14e960079.GaiaPackNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492742
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492744
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492749
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492750
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492750
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492755
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "25c14659a30cdffcd1f4e9f00dd31d787b7468e42f1678c82b4ec9fc1954ba7d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "25c14659a30cdffcd1f4e9f00dd31d787b7468e42f1678c82b4ec9fc1954ba7d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed GaiaPackNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GaiaPackNFT from 0xGaiaPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: GaiaPackNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GaiaPackNFT.Collection>(from: /storage/GaiaPackNFTCollection002) == nil {\n            let collection <- GaiaPackNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GaiaPackNFTCollection002)\n            }\n        if (acct.getCapability<&GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaPackNFTCollection002).borrow() == nil) {\n            acct.unlink(/public/GaiaPackNFTCollection002)\n            acct.link<&GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaPackNFTCollection002, target: /storage/GaiaPackNFTCollection002)\n        }\n\n        if (acct.getCapability<&GaiaPackNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/GaiaPackNFTCollection002).borrow() == nil) {\n            acct.unlink(/private/GaiaPackNFTCollection002)\n            acct.link<&GaiaPackNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/GaiaPackNFTCollection002, target: /storage/GaiaPackNFTCollection002)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/GaiaPackNFTCollection002\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xGaiaPackNFT": {
          "GaiaPackNFT": {
            "mainnet": {
              "address": "0xfdae91e14e960079",
              "contract": "GaiaPackNFT",
              "fq_address": "A.0xfdae91e14e960079.GaiaPackNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492764
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492767
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492774
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492774
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492774
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492777
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "fec0b468545627414153a551ced67d4f8f3497aa6f9bc1628297b3a761d30411": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fec0b468545627414153a551ced67d4f8f3497aa6f9bc1628297b3a761d30411",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support GaiaPackNFT NFTs"
          }
        }
      },
      "cadence": "import GaiaPackNFT from 0xGaiaPackNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: GaiaPackNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&GaiaPackNFT.Collection>(from: /storage/GaiaPackNFTCollection002) == nil {\n      let collection <- GaiaPackNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GaiaPackNFTCollection002)\n    }\n    if (signer.getCapability<&GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaPackNFTCollection002).borrow() == nil) {\n      signer.unlink(/public/GaiaPackNFTCollection002)\n      signer.link<&GaiaPackNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaPackNFTCollection002, target: /storage/GaiaPackNFTCollection002)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xGaiaPackNFT": {
          "GaiaPackNFT": {
            "mainnet": {
              "address": "0xfdae91e14e960079",
              "contract": "GaiaPackNFT",
              "fq_address": "A.0xfdae91e14e960079.GaiaPackNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492728
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492731
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492733
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "cb8c393f8e93647e355e5366d858ea0c50dd61e738b39df33e5f37cbc75b4dcb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cb8c393f8e93647e355e5366d858ea0c50dd61e738b39df33e5f37cbc75b4dcb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Frightclub NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Frightclub\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510347
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "0aa19f219dd68521b09c269a03f3dc9acbb50ef0edd8b1aa55a1ed54f8887518": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0aa19f219dd68521b09c269a03f3dc9acbb50ef0edd8b1aa55a1ed54f8887518",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Frightclub NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Beam from 0xBeam\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Frightclub\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Beam.Collection>(from: /storage/BeamCollection001) == nil {\n            let collection <- Beam.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BeamCollection001)\n        }\n        if (acct.getCapability<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BeamCollection001).borrow() == nil) {\n            acct.unlink(/public/BeamCollection001)\n            acct.link<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BeamCollection001, target: /storage/BeamCollection001)\n        }\n\n        if (acct.getCapability<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BeamCollection001).borrow() == nil) {\n            acct.unlink(/private/BeamCollection001)\n            acct.link<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BeamCollection001, target: /storage/BeamCollection001)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/BeamCollection001)!\n        let collectionRef = acct\n            .getCapability(/public/BeamCollection001)\n            .borrow<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Beam.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xBeam": {
          "Beam": {
            "mainnet": {
              "address": "0x86b4a0010a71cfc3",
              "contract": "Beam",
              "fq_address": "A.0x86b4a0010a71cfc3.Beam",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47510305
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510307
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510310
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47510312
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510312
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510316
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "be4b518e4e0414986147b5bd6b6a5fb3c80d5921e9e68c66500a25e89cdf797d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "be4b518e4e0414986147b5bd6b6a5fb3c80d5921e9e68c66500a25e89cdf797d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Frightclub NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Beam from 0xBeam\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Frightclub\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Beam.Collection>(from: /storage/BeamCollection001) == nil {\n            let collection <- Beam.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BeamCollection001)\n            }\n        if (acct.getCapability<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BeamCollection001).borrow() == nil) {\n            acct.unlink(/public/BeamCollection001)\n            acct.link<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BeamCollection001, target: /storage/BeamCollection001)\n        }\n\n        if (acct.getCapability<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BeamCollection001).borrow() == nil) {\n            acct.unlink(/private/BeamCollection001)\n            acct.link<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BeamCollection001, target: /storage/BeamCollection001)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BeamCollection001\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xBeam": {
          "Beam": {
            "mainnet": {
              "address": "0x86b4a0010a71cfc3",
              "contract": "Beam",
              "fq_address": "A.0x86b4a0010a71cfc3.Beam",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47510327
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510331
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510335
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47510336
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510337
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510342
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "cb209835507d2beb1c061db548ba3ff73a92f0681d79b06fabea4c2199b41244": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cb209835507d2beb1c061db548ba3ff73a92f0681d79b06fabea4c2199b41244",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Frightclub NFTs"
          }
        }
      },
      "cadence": "import Beam from 0xBeam\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Frightclub\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Beam.Collection>(from: /storage/BeamCollection001) == nil {\n      let collection <- Beam.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BeamCollection001)\n    }\n    if (signer.getCapability<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BeamCollection001).borrow() == nil) {\n      signer.unlink(/public/BeamCollection001)\n      signer.link<&Beam.Collection{Beam.BeamCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BeamCollection001, target: /storage/BeamCollection001)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xBeam": {
          "Beam": {
            "mainnet": {
              "address": "0x86b4a0010a71cfc3",
              "contract": "Beam",
              "fq_address": "A.0x86b4a0010a71cfc3.Beam",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47510287
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510290
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510294
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "5a23fc624dde73197bfcd1d721fc486eadca85939b8d5ac908e0b7341682427a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5a23fc624dde73197bfcd1d721fc486eadca85939b8d5ac908e0b7341682427a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a GaiaElementNFT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: GaiaElementNFT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508519
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "25240fc5632a114cf0a831e827376834fe00229dfc5b55f15a5411a681eecfa6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "25240fc5632a114cf0a831e827376834fe00229dfc5b55f15a5411a681eecfa6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a GaiaElementNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GaiaElementNFT from 0xGaiaElementNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: GaiaElementNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GaiaElementNFT.Collection>(from: /storage/GaiaElementNFTCollection002) == nil {\n            let collection <- GaiaElementNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GaiaElementNFTCollection002)\n        }\n        if (acct.getCapability<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaElementNFTCollection002).borrow() == nil) {\n            acct.unlink(/public/GaiaElementNFTCollection002)\n            acct.link<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaElementNFTCollection002, target: /storage/GaiaElementNFTCollection002)\n        }\n\n        if (acct.getCapability<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/exampleNFTCollection).borrow() == nil) {\n            acct.unlink(/private/exampleNFTCollection)\n            acct.link<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/exampleNFTCollection, target: /storage/GaiaElementNFTCollection002)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/exampleNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/GaiaElementNFTCollection002)\n            .borrow<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@GaiaElementNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xGaiaElementNFT": {
          "GaiaElementNFT": {
            "mainnet": {
              "address": "0xebfaf4d2d7920a18",
              "contract": "GaiaElementNFT",
              "fq_address": "A.0xebfaf4d2d7920a18.GaiaElementNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508479
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508482
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508486
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508487
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508488
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508492
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "978d7b645e0a8d70912810966b012e26a53807652655c0c5884a702ac9bdaa19": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "978d7b645e0a8d70912810966b012e26a53807652655c0c5884a702ac9bdaa19",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed GaiaElementNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import GaiaElementNFT from 0xGaiaElementNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: GaiaElementNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&GaiaElementNFT.Collection>(from: /storage/GaiaElementNFTCollection002) == nil {\n            let collection <- GaiaElementNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/GaiaElementNFTCollection002)\n            }\n        if (acct.getCapability<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaElementNFTCollection002).borrow() == nil) {\n            acct.unlink(/public/GaiaElementNFTCollection002)\n            acct.link<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaElementNFTCollection002, target: /storage/GaiaElementNFTCollection002)\n        }\n\n        if (acct.getCapability<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/exampleNFTCollection).borrow() == nil) {\n            acct.unlink(/private/exampleNFTCollection)\n            acct.link<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/exampleNFTCollection, target: /storage/GaiaElementNFTCollection002)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/GaiaElementNFTCollection002\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xGaiaElementNFT": {
          "GaiaElementNFT": {
            "mainnet": {
              "address": "0xebfaf4d2d7920a18",
              "contract": "GaiaElementNFT",
              "fq_address": "A.0xebfaf4d2d7920a18.GaiaElementNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508501
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508505
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508508
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508509
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508509
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508513
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "93c4e85b69a89f9fe41ae8efe7c0ed763f9e827bfe0bbf03969b1d60f7c6ea18": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "93c4e85b69a89f9fe41ae8efe7c0ed763f9e827bfe0bbf03969b1d60f7c6ea18",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support GaiaElementNFT NFTs"
          }
        }
      },
      "cadence": "import GaiaElementNFT from 0xGaiaElementNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: GaiaElementNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&GaiaElementNFT.Collection>(from: /storage/GaiaElementNFTCollection002) == nil {\n      let collection <- GaiaElementNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/GaiaElementNFTCollection002)\n    }\n    if (signer.getCapability<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaElementNFTCollection002).borrow() == nil) {\n      signer.unlink(/public/GaiaElementNFTCollection002)\n      signer.link<&GaiaElementNFT.Collection{GaiaElementNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/GaiaElementNFTCollection002, target: /storage/GaiaElementNFTCollection002)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xGaiaElementNFT": {
          "GaiaElementNFT": {
            "mainnet": {
              "address": "0xebfaf4d2d7920a18",
              "contract": "GaiaElementNFT",
              "fq_address": "A.0xebfaf4d2d7920a18.GaiaElementNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47508463
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508466
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508471
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "a1e3d8e199e65083f180f97a50b35cb5613b0a212698677145167e73325f3aa0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a1e3d8e199e65083f180f97a50b35cb5613b0a212698677145167e73325f3aa0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Fuchibola NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Fuchibola\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497416
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "72cf046bc807538b9a1aaf20819ad3adb285a5392c351552a034ee40597dee36": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "72cf046bc807538b9a1aaf20819ad3adb285a5392c351552a034ee40597dee36",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Fuchibola NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Fuchibola_NFT from 0xFuchibola_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Fuchibola\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Fuchibola_NFT.Collection>(from: /storage/Fuchibola_NFTCollection) == nil {\n            let collection <- Fuchibola_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/Fuchibola_NFTCollection)\n        }\n        if (acct.getCapability<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Fuchibola_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/Fuchibola_NFTCollection)\n            acct.link<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Fuchibola_NFTCollection, target: /storage/Fuchibola_NFTCollection)\n        }\n\n        if (acct.getCapability<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Fuchibola_NFT).borrow() == nil) {\n            acct.unlink(/private/Fuchibola_NFT)\n            acct.link<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Fuchibola_NFT, target: /storage/Fuchibola_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/Fuchibola_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/Fuchibola_NFTCollection)\n            .borrow<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Fuchibola_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xFuchibola_NFT": {
          "Fuchibola_NFT": {
            "mainnet": {
              "address": "0xf3ee684cd0259fed",
              "contract": "Fuchibola_NFT",
              "fq_address": "A.0xf3ee684cd0259fed.Fuchibola_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497377
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497380
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497384
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497385
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497386
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497389
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "143246dc79579b6d111162ce2d25e85c4e57df2f2c2b40d3a657802143887df6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "143246dc79579b6d111162ce2d25e85c4e57df2f2c2b40d3a657802143887df6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Fuchibola NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Fuchibola_NFT from 0xFuchibola_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Fuchibola\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Fuchibola_NFT.Collection>(from: /storage/Fuchibola_NFTCollection) == nil {\n            let collection <- Fuchibola_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/Fuchibola_NFTCollection)\n            }\n        if (acct.getCapability<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Fuchibola_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/Fuchibola_NFTCollection)\n            acct.link<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Fuchibola_NFTCollection, target: /storage/Fuchibola_NFTCollection)\n        }\n\n        if (acct.getCapability<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Fuchibola_NFT).borrow() == nil) {\n            acct.unlink(/private/Fuchibola_NFT)\n            acct.link<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Fuchibola_NFT, target: /storage/Fuchibola_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/Fuchibola_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xFuchibola_NFT": {
          "Fuchibola_NFT": {
            "mainnet": {
              "address": "0xf3ee684cd0259fed",
              "contract": "Fuchibola_NFT",
              "fq_address": "A.0xf3ee684cd0259fed.Fuchibola_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497400
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497403
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497407
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497408
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497408
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497413
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f82735cf20e7a6336f022e849aa5ed577c97d7cb9905969db0302d018ad6dab2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f82735cf20e7a6336f022e849aa5ed577c97d7cb9905969db0302d018ad6dab2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Fuchibola NFTs"
          }
        }
      },
      "cadence": "import Fuchibola_NFT from 0xFuchibola_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Fuchibola\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Fuchibola_NFT.Collection>(from: /storage/Fuchibola_NFTCollection) == nil {\n      let collection <- Fuchibola_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/Fuchibola_NFTCollection)\n    }\n    if (signer.getCapability<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Fuchibola_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/Fuchibola_NFTCollection)\n      signer.link<&Fuchibola_NFT.Collection{Fuchibola_NFT.Fuchibola_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Fuchibola_NFTCollection, target: /storage/Fuchibola_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xFuchibola_NFT": {
          "Fuchibola_NFT": {
            "mainnet": {
              "address": "0xf3ee684cd0259fed",
              "contract": "Fuchibola_NFT",
              "fq_address": "A.0xf3ee684cd0259fed.Fuchibola_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497362
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497365
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497369
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "4efe289117ec71b2a376a374793b9ad8fcf5941ccbbbd69297f898009b48e7c5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4efe289117ec71b2a376a374793b9ad8fcf5941ccbbbd69297f898009b48e7c5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a FridgeMagnet NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: FridgeMagnet\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506422
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "2fdff871cbabd487d70a41fee1ae38f6acee50585979196a49118f181169fc6e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2fdff871cbabd487d70a41fee1ae38f6acee50585979196a49118f181169fc6e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a FridgeMagnet NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FridgeMagnet from 0xFridgeMagnet\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FridgeMagnet\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FridgeMagnet.Collection>(from: /storage/FridgeMagnetCollection) == nil {\n            let collection <- FridgeMagnet.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FridgeMagnetCollection)\n        }\n        if (acct.getCapability<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FridgeMagnetCollection).borrow() == nil) {\n            acct.unlink(/public/FridgeMagnetCollection)\n            acct.link<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FridgeMagnetCollection, target: /storage/FridgeMagnetCollection)\n        }\n\n        if (acct.getCapability<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/CollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/CollectionPrivatePath)\n            acct.link<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/CollectionPrivatePath, target: /storage/FridgeMagnetCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CollectionPrivatePath)!\n        let collectionRef = acct\n            .getCapability(/public/FridgeMagnetCollection)\n            .borrow<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FridgeMagnet.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xFridgeMagnet": {
          "FridgeMagnet": {
            "mainnet": {
              "address": "0x4e7213d003a3a38a",
              "contract": "FridgeMagnet",
              "fq_address": "A.0x4e7213d003a3a38a.FridgeMagnet",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506382
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506384
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506389
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506390
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506390
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506393
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "f23cd1048bbc53216a8a9a2545adfc5316dde3639b25cb739342aae53f3c5388": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f23cd1048bbc53216a8a9a2545adfc5316dde3639b25cb739342aae53f3c5388",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed FridgeMagnet NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FridgeMagnet from 0xFridgeMagnet\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FridgeMagnet\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FridgeMagnet.Collection>(from: /storage/FridgeMagnetCollection) == nil {\n            let collection <- FridgeMagnet.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FridgeMagnetCollection)\n            }\n        if (acct.getCapability<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FridgeMagnetCollection).borrow() == nil) {\n            acct.unlink(/public/FridgeMagnetCollection)\n            acct.link<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FridgeMagnetCollection, target: /storage/FridgeMagnetCollection)\n        }\n\n        if (acct.getCapability<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/CollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/CollectionPrivatePath)\n            acct.link<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/CollectionPrivatePath, target: /storage/FridgeMagnetCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/FridgeMagnetCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xFridgeMagnet": {
          "FridgeMagnet": {
            "mainnet": {
              "address": "0x4e7213d003a3a38a",
              "contract": "FridgeMagnet",
              "fq_address": "A.0x4e7213d003a3a38a.FridgeMagnet",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506404
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506406
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506410
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506411
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506411
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506417
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e73e06c4fefe5ee2b6b02f175b53612aafa258d0edfdf85a08ca3713459807fc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e73e06c4fefe5ee2b6b02f175b53612aafa258d0edfdf85a08ca3713459807fc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support FridgeMagnet NFTs"
          }
        }
      },
      "cadence": "import FridgeMagnet from 0xFridgeMagnet\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FridgeMagnet\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FridgeMagnet.Collection>(from: /storage/FridgeMagnetCollection) == nil {\n      let collection <- FridgeMagnet.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FridgeMagnetCollection)\n    }\n    if (signer.getCapability<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FridgeMagnetCollection).borrow() == nil) {\n      signer.unlink(/public/FridgeMagnetCollection)\n      signer.link<&FridgeMagnet.Collection{FridgeMagnet.NFTCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FridgeMagnetCollection, target: /storage/FridgeMagnetCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xFridgeMagnet": {
          "FridgeMagnet": {
            "mainnet": {
              "address": "0x4e7213d003a3a38a",
              "contract": "FridgeMagnet",
              "fq_address": "A.0x4e7213d003a3a38a.FridgeMagnet",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47506366
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506369
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506372
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "a6d6929ada908458cafda9a209a6e3390b34c922e55a43f21921606eda10f30e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a6d6929ada908458cafda9a209a6e3390b34c922e55a43f21921606eda10f30e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a FlowverseSocks NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseSocks\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488632
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784037
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "a907880128877fe0b6b3aa7e78f8077dc6b740ae98a314f3704e27b5345890a4": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a907880128877fe0b6b3aa7e78f8077dc6b740ae98a314f3704e27b5345890a4",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a FlowverseSocks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FlowverseSocks01 from 0xFlowverseSocks01\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseSocks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseSocks01.Collection>(from: /storage/MatrixMarketFlowverseSocks01Collection) == nil {\n            let collection <- FlowverseSocks01.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n        if (acct.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection).borrow() == nil) {\n            acct.unlink(/public/MatrixMarketFlowverseSocks01Collection)\n            acct.link<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n\n        if (acct.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocks01Collection).borrow() == nil) {\n            acct.unlink(/private/FlowverseSocks01Collection)\n            acct.link<&FlowverseSocks01.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlowverseSocks01Collection)!\n        let collectionRef = acct\n            .getCapability(/public/MatrixMarketFlowverseSocks01Collection)\n            .borrow<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FlowverseSocks01.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783951
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783956
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95783957
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783958
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783962
            }
          }
        },
        "0xFlowverseSocks01": {
          "FlowverseSocks01": {
            "testnet": {
              "address": "0x7f3812b53dd4de20",
              "contract": "FlowverseSocks01",
              "fq_address": "A.0x7f3812b53dd4de20.FlowverseSocks01",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95783973
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "874c8584c12cbceb4518a2c6dc6ae8b37c5a78a7b78b9a0d5851f3da38b232ef": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "874c8584c12cbceb4518a2c6dc6ae8b37c5a78a7b78b9a0d5851f3da38b232ef",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a FlowverseSocks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FlowverseSocks from 0xFlowverseSocks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseSocks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseSocks.Collection>(from: /storage/MatrixMarketFlowverseSocksCollection) == nil {\n            let collection <- FlowverseSocks.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MatrixMarketFlowverseSocksCollection)\n        }\n        if (acct.getCapability<&FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocksCollection).borrow() == nil) {\n            acct.unlink(/public/MatrixMarketFlowverseSocksCollection)\n            acct.link<&FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocksCollection, target: /storage/MatrixMarketFlowverseSocksCollection)\n        }\n\n        if (acct.getCapability<&FlowverseSocks.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocksCollection).borrow() == nil) {\n            acct.unlink(/private/FlowverseSocksCollection)\n            acct.link<&FlowverseSocks.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocksCollection, target: /storage/MatrixMarketFlowverseSocksCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlowverseSocksCollection)!\n        let collectionRef = acct\n            .getCapability(/public/MatrixMarketFlowverseSocksCollection)\n            .borrow<&FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FlowverseSocks.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xFlowverseSocks": {
          "FlowverseSocks": {
            "mainnet": {
              "address": "0xce4c02539d1fabe8",
              "contract": "FlowverseSocks",
              "fq_address": "A.0xce4c02539d1fabe8.FlowverseSocks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47488545
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488548
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488554
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488554
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488554
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488559
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "d3357810579ec9dc5dcad55d660f501bcffa0daa8b0e4c43e9d82fe17adcc437": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d3357810579ec9dc5dcad55d660f501bcffa0daa8b0e4c43e9d82fe17adcc437",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed FlowverseSocks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FlowverseSocks01 from 0xFlowverseSocks01\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FlowverseSocks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseSocks01.Collection>(from: /storage/MatrixMarketFlowverseSocks01Collection) == nil {\n            let collection <- FlowverseSocks01.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MatrixMarketFlowverseSocks01Collection)\n            }\n        if (acct.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection).borrow() == nil) {\n            acct.unlink(/public/MatrixMarketFlowverseSocks01Collection)\n            acct.link<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n\n        if (acct.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocks01Collection).borrow() == nil) {\n            acct.unlink(/private/FlowverseSocks01Collection)\n            acct.link<&FlowverseSocks01.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MatrixMarketFlowverseSocks01Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784004
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784009
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95784010
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95784011
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95784016
            }
          }
        },
        "0xFlowverseSocks01": {
          "FlowverseSocks01": {
            "testnet": {
              "address": "0x7f3812b53dd4de20",
              "contract": "FlowverseSocks01",
              "fq_address": "A.0x7f3812b53dd4de20.FlowverseSocks01",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95784025
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "a31566284ea508e71f780dc05960dfa1e82f180a75c238c27b3253691b2ba725": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a31566284ea508e71f780dc05960dfa1e82f180a75c238c27b3253691b2ba725",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed FlowverseSocks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FlowverseSocks from 0xFlowverseSocks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FlowverseSocks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseSocks.Collection>(from: /storage/MatrixMarketFlowverseSocksCollection) == nil {\n            let collection <- FlowverseSocks.createEmptyCollection()\n            acct.save(<-collection, to: /storage/MatrixMarketFlowverseSocksCollection)\n            }\n        if (acct.getCapability<&FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocksCollection).borrow() == nil) {\n            acct.unlink(/public/MatrixMarketFlowverseSocksCollection)\n            acct.link<&FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocksCollection, target: /storage/MatrixMarketFlowverseSocksCollection)\n        }\n\n        if (acct.getCapability<&FlowverseSocks.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocksCollection).borrow() == nil) {\n            acct.unlink(/private/FlowverseSocksCollection)\n            acct.link<&FlowverseSocks.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/private/FlowverseSocksCollection, target: /storage/MatrixMarketFlowverseSocksCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/MatrixMarketFlowverseSocksCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xFlowverseSocks": {
          "FlowverseSocks": {
            "mainnet": {
              "address": "0xce4c02539d1fabe8",
              "contract": "FlowverseSocks",
              "fq_address": "A.0xce4c02539d1fabe8.FlowverseSocks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47488589
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488593
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488598
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488600
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488600
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488604
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "30347fcd18c1531ee1fa54c12822a55ce62011cf27a3e5c042fafc127c4b3ac9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "30347fcd18c1531ee1fa54c12822a55ce62011cf27a3e5c042fafc127c4b3ac9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support FlowverseSocks NFTs"
          }
        }
      },
      "cadence": "import FlowverseSocks01 from 0xFlowverseSocks01\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FlowverseSocks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FlowverseSocks01.Collection>(from: /storage/MatrixMarketFlowverseSocks01Collection) == nil {\n      let collection <- FlowverseSocks01.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MatrixMarketFlowverseSocks01Collection)\n    }\n    if (signer.getCapability<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection).borrow() == nil) {\n      signer.unlink(/public/MatrixMarketFlowverseSocks01Collection)\n      signer.link<&FlowverseSocks01.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks01.FlowverseSocks01CollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocks01Collection, target: /storage/MatrixMarketFlowverseSocks01Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95783908
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95783913
            }
          }
        },
        "0xFlowverseSocks01": {
          "FlowverseSocks01": {
            "testnet": {
              "address": "0x7f3812b53dd4de20",
              "contract": "FlowverseSocks01",
              "fq_address": "A.0x7f3812b53dd4de20.FlowverseSocks01",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95783922
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "3b859036cad72cf18dd961d09efc942cc03e9fb816c61bdc8f7044d566d1fc56": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3b859036cad72cf18dd961d09efc942cc03e9fb816c61bdc8f7044d566d1fc56",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support FlowverseSocks NFTs"
          }
        }
      },
      "cadence": "import FlowverseSocks from 0xFlowverseSocks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FlowverseSocks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FlowverseSocks.Collection>(from: /storage/MatrixMarketFlowverseSocksCollection) == nil {\n      let collection <- FlowverseSocks.createEmptyCollection()\n      signer.save(<-collection, to: /storage/MatrixMarketFlowverseSocksCollection)\n    }\n    if (signer.getCapability<&FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocksCollection).borrow() == nil) {\n      signer.unlink(/public/MatrixMarketFlowverseSocksCollection)\n      signer.link<&FlowverseSocks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseSocks.FlowverseSocksCollectionPublic,MetadataViews.ResolverCollection}>(/public/MatrixMarketFlowverseSocksCollection, target: /storage/MatrixMarketFlowverseSocksCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xFlowverseSocks": {
          "FlowverseSocks": {
            "mainnet": {
              "address": "0xce4c02539d1fabe8",
              "contract": "FlowverseSocks",
              "fq_address": "A.0xce4c02539d1fabe8.FlowverseSocks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47488514
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488516
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488520
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "8e2300fd03714ecb70a5f2bf93579beda67c40ccc0b080ee96312e5681c5326c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8e2300fd03714ecb70a5f2bf93579beda67c40ccc0b080ee96312e5681c5326c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Flunks NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Flunks\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510276
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809717
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "bd4c4df0bdf921d4b375dcd7098f41386c32b8de8ac6e7a309df89355659f0a7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "bd4c4df0bdf921d4b375dcd7098f41386c32b8de8ac6e7a309df89355659f0a7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Flunks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Flunks from 0xFlunks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Flunks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Flunks.Collection>(from: /storage/FlunksCollection) == nil {\n            let collection <- Flunks.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlunksCollection)\n        }\n        if (acct.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection).borrow() == nil) {\n            acct.unlink(/public/FlunksCollection)\n            acct.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection, target: /storage/FlunksCollection)\n        }\n\n        if (acct.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FlunksPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/FlunksPrivateProvider)\n            acct.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FlunksPrivateProvider, target: /storage/FlunksCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlunksPrivateProvider)!\n        let collectionRef = acct\n            .getCapability(/public/FlunksCollection)\n            .borrow<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Flunks.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xFlunks": {
          "Flunks": {
            "mainnet": {
              "address": "0x807c3d470888cc48",
              "contract": "Flunks",
              "fq_address": "A.0x807c3d470888cc48.Flunks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510193
            },
            "testnet": {
              "address": "0xe666c53e1758dec6",
              "contract": "Flunks",
              "fq_address": "A.0xe666c53e1758dec6.Flunks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809627
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510203
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809635
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510210
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809644
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47510215
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95809646
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510218
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809648
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510221
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809657
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "33925d730e78ad3e2d6a8773fca98466ba2287211f3be7318db91bb75df9f493": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "33925d730e78ad3e2d6a8773fca98466ba2287211f3be7318db91bb75df9f493",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Flunks NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Flunks from 0xFlunks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Flunks\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Flunks.Collection>(from: /storage/FlunksCollection) == nil {\n            let collection <- Flunks.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlunksCollection)\n            }\n        if (acct.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection).borrow() == nil) {\n            acct.unlink(/public/FlunksCollection)\n            acct.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection, target: /storage/FlunksCollection)\n        }\n\n        if (acct.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FlunksPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/FlunksPrivateProvider)\n            acct.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FlunksPrivateProvider, target: /storage/FlunksCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/FlunksCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xFlunks": {
          "Flunks": {
            "mainnet": {
              "address": "0x807c3d470888cc48",
              "contract": "Flunks",
              "fq_address": "A.0x807c3d470888cc48.Flunks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510235
            },
            "testnet": {
              "address": "0xe666c53e1758dec6",
              "contract": "Flunks",
              "fq_address": "A.0xe666c53e1758dec6.Flunks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809677
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510245
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809684
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510253
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809694
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47510259
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95809696
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510259
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809697
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510264
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809706
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "de0854e19d6ede95460f69d6af49208780b7d0b6bd5cbe2a1f62d1584368158b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "de0854e19d6ede95460f69d6af49208780b7d0b6bd5cbe2a1f62d1584368158b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Flunks NFTs"
          }
        }
      },
      "cadence": "import Flunks from 0xFlunks\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Flunks\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Flunks.Collection>(from: /storage/FlunksCollection) == nil {\n      let collection <- Flunks.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FlunksCollection)\n    }\n    if (signer.getCapability<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection).borrow() == nil) {\n      signer.unlink(/public/FlunksCollection)\n      signer.link<&Flunks.Collection{NonFungibleToken.CollectionPublic,Flunks.FlunksCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FlunksCollection, target: /storage/FlunksCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xFlunks": {
          "Flunks": {
            "mainnet": {
              "address": "0x807c3d470888cc48",
              "contract": "Flunks",
              "fq_address": "A.0x807c3d470888cc48.Flunks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47510163
            },
            "testnet": {
              "address": "0xe666c53e1758dec6",
              "contract": "Flunks",
              "fq_address": "A.0xe666c53e1758dec6.Flunks",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95809591
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47510174
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95809598
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47510180
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95809607
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "d2f83bb0b254e5f91e999c13452b01404164b09af1fe77eedbd094a118c421d9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d2f83bb0b254e5f91e999c13452b01404164b09af1fe77eedbd094a118c421d9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a FlowverseTreasures NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseTreasures\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505589
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804159
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "634c244bfa429e093b188e519a0df3d7da08f75790e50c44621c83836149337d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "634c244bfa429e093b188e519a0df3d7da08f75790e50c44621c83836149337d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a FlowverseTreasures NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FlowverseTreasures from 0xFlowverseTreasures\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseTreasures\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseTreasures.Collection>(from: /storage/FlowverseTreasuresCollection) == nil {\n            let collection <- FlowverseTreasures.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlowverseTreasuresCollection)\n        }\n        if (acct.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection).borrow() == nil) {\n            acct.unlink(/public/FlowverseTreasuresCollection)\n            acct.link<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n        }\n\n        if (acct.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowverseTreasures.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowverseTreasuresCollection).borrow() == nil) {\n            acct.unlink(/private/FlowverseTreasuresCollection)\n            acct.link<&FlowverseTreasures.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowverseTreasures.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlowverseTreasuresCollection)!\n        let collectionRef = acct\n            .getCapability(/public/FlowverseTreasuresCollection)\n            .borrow<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FlowverseTreasures.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xFlowverseTreasures": {
          "FlowverseTreasures": {
            "mainnet": {
              "address": "0x9212a87501a8a6a2",
              "contract": "FlowverseTreasures",
              "fq_address": "A.0x9212a87501a8a6a2.FlowverseTreasures",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47505512
            },
            "testnet": {
              "address": "0xc7c122b5b811de8e",
              "contract": "FlowverseTreasures",
              "fq_address": "A.0xc7c122b5b811de8e.FlowverseTreasures",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95804067
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505523
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804074
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505530
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804085
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505535
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804087
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505537
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804088
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505540
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804097
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "09ee97cba9ba4ea3f464812d11d7a61aac3ed96862d86d4c478c4ab8a7c75f7c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "09ee97cba9ba4ea3f464812d11d7a61aac3ed96862d86d4c478c4ab8a7c75f7c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed FlowverseTreasures NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FlowverseTreasures from 0xFlowverseTreasures\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FlowverseTreasures\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowverseTreasures.Collection>(from: /storage/FlowverseTreasuresCollection) == nil {\n            let collection <- FlowverseTreasures.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlowverseTreasuresCollection)\n            }\n        if (acct.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection).borrow() == nil) {\n            acct.unlink(/public/FlowverseTreasuresCollection)\n            acct.link<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n        }\n\n        if (acct.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowverseTreasures.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowverseTreasuresCollection).borrow() == nil) {\n            acct.unlink(/private/FlowverseTreasuresCollection)\n            acct.link<&FlowverseTreasures.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowverseTreasures.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/FlowverseTreasuresCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xFlowverseTreasures": {
          "FlowverseTreasures": {
            "mainnet": {
              "address": "0x9212a87501a8a6a2",
              "contract": "FlowverseTreasures",
              "fq_address": "A.0x9212a87501a8a6a2.FlowverseTreasures",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47505553
            },
            "testnet": {
              "address": "0xc7c122b5b811de8e",
              "contract": "FlowverseTreasures",
              "fq_address": "A.0xc7c122b5b811de8e.FlowverseTreasures",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95804118
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505564
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804125
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505571
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804135
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505574
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804137
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505577
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804139
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505580
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804148
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "7d6b42156b3faf16657b842d7a59b146f66b7918f42e61c2913ce3e52e4d4a09": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7d6b42156b3faf16657b842d7a59b146f66b7918f42e61c2913ce3e52e4d4a09",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support FlowverseTreasures NFTs"
          }
        }
      },
      "cadence": "import FlowverseTreasures from 0xFlowverseTreasures\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FlowverseTreasures\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FlowverseTreasures.Collection>(from: /storage/FlowverseTreasuresCollection) == nil {\n      let collection <- FlowverseTreasures.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FlowverseTreasuresCollection)\n    }\n    if (signer.getCapability<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection).borrow() == nil) {\n      signer.unlink(/public/FlowverseTreasuresCollection)\n      signer.link<&FlowverseTreasures.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowverseTreasures.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowverseTreasuresCollection, target: /storage/FlowverseTreasuresCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xFlowverseTreasures": {
          "FlowverseTreasures": {
            "mainnet": {
              "address": "0x9212a87501a8a6a2",
              "contract": "FlowverseTreasures",
              "fq_address": "A.0x9212a87501a8a6a2.FlowverseTreasures",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47505482
            },
            "testnet": {
              "address": "0xc7c122b5b811de8e",
              "contract": "FlowverseTreasures",
              "fq_address": "A.0xc7c122b5b811de8e.FlowverseTreasures",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95804030
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505492
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804037
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505500
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804047
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "73516ebbe58e2f7a078337658109ca8fde595805e943793efdbef1fbb4c9a070": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "73516ebbe58e2f7a078337658109ca8fde595805e943793efdbef1fbb4c9a070",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a FlowverseMysteryPass NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseMysteryPass\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499951
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797445
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ca68ee659bd6e6c877dd084a06dd156c062c38ebdafd304d275dd6929d4fc006": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ca68ee659bd6e6c877dd084a06dd156c062c38ebdafd304d275dd6929d4fc006",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a FlowverseMysteryPass NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FlowversePass from 0xFlowversePass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FlowverseMysteryPass\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowversePass.Collection>(from: /storage/FlowversePassCollection) == nil {\n            let collection <- FlowversePass.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlowversePassCollection)\n        }\n        if (acct.getCapability<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection).borrow() == nil) {\n            acct.unlink(/public/FlowversePassCollection)\n            acct.link<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection, target: /storage/FlowversePassCollection)\n        }\n\n        if (acct.getCapability<&FlowversePass.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowversePass.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowversePassCollection).borrow() == nil) {\n            acct.unlink(/private/FlowversePassCollection)\n            acct.link<&FlowversePass.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowversePass.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowversePassCollection, target: /storage/FlowversePassCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlowversePassCollection)!\n        let collectionRef = acct\n            .getCapability(/public/FlowversePassCollection)\n            .borrow<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FlowversePass.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xFlowversePass": {
          "FlowversePass": {
            "mainnet": {
              "address": "0x9212a87501a8a6a2",
              "contract": "FlowversePass",
              "fq_address": "A.0x9212a87501a8a6a2.FlowversePass",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499869
            },
            "testnet": {
              "address": "0xc7c122b5b811de8e",
              "contract": "FlowversePass",
              "fq_address": "A.0xc7c122b5b811de8e.FlowversePass",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797356
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499882
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797362
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499888
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797372
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499894
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95797374
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499894
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797375
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499898
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797384
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "ba9554b7ec84493695b376f3fbe134c7811c43370cea44b00820efc58d71bfaa": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ba9554b7ec84493695b376f3fbe134c7811c43370cea44b00820efc58d71bfaa",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed FlowverseMysteryPass NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FlowversePass from 0xFlowversePass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FlowverseMysteryPass\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FlowversePass.Collection>(from: /storage/FlowversePassCollection) == nil {\n            let collection <- FlowversePass.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FlowversePassCollection)\n            }\n        if (acct.getCapability<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection).borrow() == nil) {\n            acct.unlink(/public/FlowversePassCollection)\n            acct.link<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection, target: /storage/FlowversePassCollection)\n        }\n\n        if (acct.getCapability<&FlowversePass.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowversePass.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowversePassCollection).borrow() == nil) {\n            acct.unlink(/private/FlowversePassCollection)\n            acct.link<&FlowversePass.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,FlowversePass.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlowversePassCollection, target: /storage/FlowversePassCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/FlowversePassCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xFlowversePass": {
          "FlowversePass": {
            "mainnet": {
              "address": "0x9212a87501a8a6a2",
              "contract": "FlowversePass",
              "fq_address": "A.0x9212a87501a8a6a2.FlowversePass",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499912
            },
            "testnet": {
              "address": "0xc7c122b5b811de8e",
              "contract": "FlowversePass",
              "fq_address": "A.0xc7c122b5b811de8e.FlowversePass",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797404
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499923
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797411
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499931
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797421
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499936
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95797424
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499938
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797425
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499943
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797434
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "11f09221a5c8404f4c9b6a4db75baee3e1d67d4033432e96fb2445791eaba3d7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "11f09221a5c8404f4c9b6a4db75baee3e1d67d4033432e96fb2445791eaba3d7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support FlowverseMysteryPass NFTs"
          }
        }
      },
      "cadence": "import FlowversePass from 0xFlowversePass\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FlowverseMysteryPass\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FlowversePass.Collection>(from: /storage/FlowversePassCollection) == nil {\n      let collection <- FlowversePass.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FlowversePassCollection)\n    }\n    if (signer.getCapability<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection).borrow() == nil) {\n      signer.unlink(/public/FlowversePassCollection)\n      signer.link<&FlowversePass.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,FlowversePass.CollectionPublic,MetadataViews.ResolverCollection}>(/public/FlowversePassCollection, target: /storage/FlowversePassCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xFlowversePass": {
          "FlowversePass": {
            "mainnet": {
              "address": "0x9212a87501a8a6a2",
              "contract": "FlowversePass",
              "fq_address": "A.0x9212a87501a8a6a2.FlowversePass",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499840
            },
            "testnet": {
              "address": "0xc7c122b5b811de8e",
              "contract": "FlowversePass",
              "fq_address": "A.0xc7c122b5b811de8e.FlowversePass",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797320
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499850
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797326
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499856
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797336
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "4cae5363d75924bd1fa8e8157a79ec170aa4d76e97edb7ae2d6f133e25203d59": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4cae5363d75924bd1fa8e8157a79ec170aa4d76e97edb7ae2d6f133e25203d59",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Flovatar NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Flovatar\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513152
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813107
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "642ea6991e4004091f30c25850ab41039f3f22191f9eb028728d1016ef4492a7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "642ea6991e4004091f30c25850ab41039f3f22191f9eb028728d1016ef4492a7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a FlownsDomainNameNFT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: FlownsDomainNameNFT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513222
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "25dd7df58477311d3263046ae68eabb26bb29dff4ae1b5b8b9a46d7e2910a9f5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "25dd7df58477311d3263046ae68eabb26bb29dff4ae1b5b8b9a46d7e2910a9f5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a FlownsDomainNameNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Domains from 0xDomains\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FlownsDomainNameNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Domains.Collection>(from: /storage/fnsDomainCollection) == nil {\n            let collection <- Domains.createEmptyCollection()\n            acct.save(<-collection, to: /storage/fnsDomainCollection)\n        }\n        if (acct.getCapability<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/fnsDomainCollection).borrow() == nil) {\n            acct.unlink(/public/fnsDomainCollection)\n            acct.link<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/fnsDomainCollection, target: /storage/fnsDomainCollection)\n        }\n\n        if (acct.getCapability<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/fnsDomainCollection).borrow() == nil) {\n            acct.unlink(/private/fnsDomainCollection)\n            acct.link<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/fnsDomainCollection, target: /storage/fnsDomainCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/fnsDomainCollection)!\n        let collectionRef = acct\n            .getCapability(/public/fnsDomainCollection)\n            .borrow<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Domains.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDomains": {
          "Domains": {
            "mainnet": {
              "address": "0x233eb012d34b0070",
              "contract": "Domains",
              "fq_address": "A.0x233eb012d34b0070.Domains",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47513184
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513187
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513192
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47513193
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513193
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513198
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "9f325c3361bd13a6b9400323aaa4912922c98c15b2b7f81f202103d675c40764": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9f325c3361bd13a6b9400323aaa4912922c98c15b2b7f81f202103d675c40764",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed FlownsDomainNameNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Domains from 0xDomains\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FlownsDomainNameNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Domains.Collection>(from: /storage/fnsDomainCollection) == nil {\n            let collection <- Domains.createEmptyCollection()\n            acct.save(<-collection, to: /storage/fnsDomainCollection)\n            }\n        if (acct.getCapability<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/fnsDomainCollection).borrow() == nil) {\n            acct.unlink(/public/fnsDomainCollection)\n            acct.link<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/fnsDomainCollection, target: /storage/fnsDomainCollection)\n        }\n\n        if (acct.getCapability<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/fnsDomainCollection).borrow() == nil) {\n            acct.unlink(/private/fnsDomainCollection)\n            acct.link<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/fnsDomainCollection, target: /storage/fnsDomainCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/fnsDomainCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDomains": {
          "Domains": {
            "mainnet": {
              "address": "0x233eb012d34b0070",
              "contract": "Domains",
              "fq_address": "A.0x233eb012d34b0070.Domains",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47513205
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513208
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513213
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47513213
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513214
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513217
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "b3ae4ef1cacbba29acd88ce9acc15ac44fd766f0df8deb62fb532af962e3bd88": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b3ae4ef1cacbba29acd88ce9acc15ac44fd766f0df8deb62fb532af962e3bd88",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support FlownsDomainNameNFT NFTs"
          }
        }
      },
      "cadence": "import Domains from 0xDomains\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FlownsDomainNameNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Domains.Collection>(from: /storage/fnsDomainCollection) == nil {\n      let collection <- Domains.createEmptyCollection()\n      signer.save(<-collection, to: /storage/fnsDomainCollection)\n    }\n    if (signer.getCapability<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/fnsDomainCollection).borrow() == nil) {\n      signer.unlink(/public/fnsDomainCollection)\n      signer.link<&Domains.Collection{Domains.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/fnsDomainCollection, target: /storage/fnsDomainCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDomains": {
          "Domains": {
            "mainnet": {
              "address": "0x233eb012d34b0070",
              "contract": "Domains",
              "fq_address": "A.0x233eb012d34b0070.Domains",
              "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
              "pin_block_height": 47513166
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47513169
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47513174
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "2dd46c9c3e2948d383d4c32897757f499ed785a467ec442c92e6c711ac4e0290": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2dd46c9c3e2948d383d4c32897757f499ed785a467ec442c92e6c711ac4e0290",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a FlovatarComponent NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: FlovatarComponent\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501918
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799792
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "110ea76566de11f2f868e8feb26af2ba0574f34b3a0d558148ddb6e87814d59f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "110ea76566de11f2f868e8feb26af2ba0574f34b3a0d558148ddb6e87814d59f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Flobot NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Flobot\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47507057
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95805916
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "d4a28e2eb1267ce1da5ed265356b909b4bdd0a84e62ad8116b1f8f50aec49bbf": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d4a28e2eb1267ce1da5ed265356b909b4bdd0a84e62ad8116b1f8f50aec49bbf",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Emeralds NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Emeralds\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502576
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "488f307fb2e3e1b105055e3bbde23d1f08aa2614f5c16e37304d018fb6c0f15c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "488f307fb2e3e1b105055e3bbde23d1f08aa2614f5c16e37304d018fb6c0f15c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Emeralds NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Emeralds from 0xEmeralds\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Emeralds\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Emeralds.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Emeralds.Collection>(from: /storage/EmeraldsCollection_0x5643fd47a29770e7) == nil {\n            let collection <- Emeralds.createEmptyCollection()\n            acct.save(<-collection, to: /storage/EmeraldsCollection_0x5643fd47a29770e7)\n            }\n        if (acct.getCapability<&Emeralds.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/EmeraldsCollection_0x5643fd47a29770e7).borrow() == nil) {\n            acct.unlink(/public/EmeraldsCollection_0x5643fd47a29770e7)\n            acct.link<&Emeralds.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/EmeraldsCollection_0x5643fd47a29770e7, target: /storage/EmeraldsCollection_0x5643fd47a29770e7)\n        }\n\n        if (acct.getCapability<&Emeralds.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/EmeraldsCollection_0x5643fd47a29770e7).borrow() == nil) {\n            acct.unlink(/private/EmeraldsCollection_0x5643fd47a29770e7)\n            acct.link<&Emeralds.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,NonFungibleToken.Provider}>(/private/EmeraldsCollection_0x5643fd47a29770e7, target: /storage/EmeraldsCollection_0x5643fd47a29770e7)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Emeralds.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/EmeraldsCollection_0x5643fd47a29770e7\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xEmeralds": {
          "Emeralds": {
            "mainnet": {
              "address": "0x5643fd47a29770e7",
              "contract": "Emeralds",
              "fq_address": "A.0x5643fd47a29770e7.Emeralds",
              "pin": "9e4c93fa6453b3a2b0f56a1e71ff3740398f59d4207815b15527748994ecd0f9",
              "pin_block_height": 47502559
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502561
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502567
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502567
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502567
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502572
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "7b9a28094dd09f36a6303b1c70499c1944ff488dd35a32469f4049daca844c3e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7b9a28094dd09f36a6303b1c70499c1944ff488dd35a32469f4049daca844c3e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Eternal NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Eternal\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487848
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "f90a65fc390f1f31f7c4cd7fdd9a9ce122b9e6dd232c7c700d96ac6991e3c5eb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f90a65fc390f1f31f7c4cd7fdd9a9ce122b9e6dd232c7c700d96ac6991e3c5eb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Eternal NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Eternal from 0xEternal\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Eternal\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Eternal.Collection>(from: /storage/EternalMomentCollection) == nil {\n            let collection <- Eternal.createEmptyCollection()\n            acct.save(<-collection, to: /storage/EternalMomentCollection)\n        }\n        if (acct.getCapability<&Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/EternalMomentCollection).borrow() == nil) {\n            acct.unlink(/public/EternalMomentCollection)\n            acct.link<&Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/EternalMomentCollection, target: /storage/EternalMomentCollection)\n        }\n\n        if (acct.getCapability<&Eternal.Collection{NonFungibleToken.Provider,Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/EternalMomentCollection).borrow() == nil) {\n            acct.unlink(/private/EternalMomentCollection)\n            acct.link<&Eternal.Collection{NonFungibleToken.Provider,Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/EternalMomentCollection, target: /storage/EternalMomentCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/EternalMomentCollection)!\n        let collectionRef = acct\n            .getCapability(/public/EternalMomentCollection)\n            .borrow<&Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Eternal.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xEternal": {
          "Eternal": {
            "mainnet": {
              "address": "0xc38aea683c0c4d38",
              "contract": "Eternal",
              "fq_address": "A.0xc38aea683c0c4d38.Eternal",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47492569
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492571
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492575
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492576
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492576
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492583
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "03a8e054818d98470d45702b0e40ebd842851ab33361bf3bf5fa0c66cecd5ff9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "03a8e054818d98470d45702b0e40ebd842851ab33361bf3bf5fa0c66cecd5ff9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Eternal NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Eternal from 0xEternal\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Eternal\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Eternal.Collection>(from: /storage/EternalMomentCollection) == nil {\n            let collection <- Eternal.createEmptyCollection()\n            acct.save(<-collection, to: /storage/EternalMomentCollection)\n            }\n        if (acct.getCapability<&Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/EternalMomentCollection).borrow() == nil) {\n            acct.unlink(/public/EternalMomentCollection)\n            acct.link<&Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/EternalMomentCollection, target: /storage/EternalMomentCollection)\n        }\n\n        if (acct.getCapability<&Eternal.Collection{NonFungibleToken.Provider,Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/EternalMomentCollection).borrow() == nil) {\n            acct.unlink(/private/EternalMomentCollection)\n            acct.link<&Eternal.Collection{NonFungibleToken.Provider,Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/EternalMomentCollection, target: /storage/EternalMomentCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(\n            from: /storage/EternalMomentCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xEternal": {
          "Eternal": {
            "mainnet": {
              "address": "0xc38aea683c0c4d38",
              "contract": "Eternal",
              "fq_address": "A.0xc38aea683c0c4d38.Eternal",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47492590
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492593
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492597
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492599
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492599
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492603
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "874c9192d2c548a612101e81acdf8946db391728aa8054addc6ae26c3921d64c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "874c9192d2c548a612101e81acdf8946db391728aa8054addc6ae26c3921d64c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Eternal NFTs"
          }
        }
      },
      "cadence": "import Eternal from 0xEternal\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Eternal\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Eternal.Collection>(from: /storage/EternalMomentCollection) == nil {\n      let collection <- Eternal.createEmptyCollection()\n      signer.save(<-collection, to: /storage/EternalMomentCollection)\n    }\n    if (signer.getCapability<&Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/EternalMomentCollection).borrow() == nil) {\n      signer.unlink(/public/EternalMomentCollection)\n      signer.link<&Eternal.Collection{Eternal.MomentCollectionPublic,NonFungibleToken.Receiver,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/public/EternalMomentCollection, target: /storage/EternalMomentCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xEternal": {
          "Eternal": {
            "mainnet": {
              "address": "0xc38aea683c0c4d38",
              "contract": "Eternal",
              "fq_address": "A.0xc38aea683c0c4d38.Eternal",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47492551
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492555
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492560
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "34de2c0f56fcd82be64f9256507b0cd9556185fe8c10ca4fa4d470e92b13c29a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "34de2c0f56fcd82be64f9256507b0cd9556185fe8c10ca4fa4d470e92b13c29a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a FLOAT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: FLOAT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505945
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804594
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "dc3e231fc9374a163feecc6f588d03ddc0b998820ca2f438e8d6feea807b6e91": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "dc3e231fc9374a163feecc6f588d03ddc0b998820ca2f438e8d6feea807b6e91",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a FLOAT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FLOAT from 0xFLOAT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: FLOAT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FLOAT.Collection>(from: /storage/FLOATCollectionStoragePath) == nil {\n            let collection <- FLOAT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FLOATCollectionStoragePath)\n        }\n        if (acct.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/FLOATCollectionPublicPath)\n            acct.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath, target: /storage/FLOATCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FLOATCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/FLOATCollectionPrivatePath)\n            acct.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FLOATCollectionPrivatePath, target: /storage/FLOATCollectionStoragePath)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FLOATCollectionPrivatePath)!\n        let collectionRef = acct\n            .getCapability(/public/FLOATCollectionPublicPath)\n            .borrow<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@FLOAT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xFLOAT": {
          "FLOAT": {
            "mainnet": {
              "address": "0x2d4c3caffbeab845",
              "contract": "FLOAT",
              "fq_address": "A.0x2d4c3caffbeab845.FLOAT",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 47505841
            },
            "testnet": {
              "address": "0x0afe396ebc8eee65",
              "contract": "FLOAT",
              "fq_address": "A.0x0afe396ebc8eee65.FLOAT",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 95804481
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505864
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804488
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505870
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804497
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505874
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804499
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505876
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804500
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505880
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804510
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "8a590d97dd9f1fbd5c7c40054d0121a26149dac98ddf0dab327553646160111f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8a590d97dd9f1fbd5c7c40054d0121a26149dac98ddf0dab327553646160111f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed FLOAT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import FLOAT from 0xFLOAT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: FLOAT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&FLOAT.Collection>(from: /storage/FLOATCollectionStoragePath) == nil {\n            let collection <- FLOAT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/FLOATCollectionStoragePath)\n            }\n        if (acct.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/FLOATCollectionPublicPath)\n            acct.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath, target: /storage/FLOATCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FLOATCollectionPrivatePath).borrow() == nil) {\n            acct.unlink(/private/FLOATCollectionPrivatePath)\n            acct.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/FLOATCollectionPrivatePath, target: /storage/FLOATCollectionStoragePath)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/FLOATCollectionStoragePath\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xFLOAT": {
          "FLOAT": {
            "mainnet": {
              "address": "0x2d4c3caffbeab845",
              "contract": "FLOAT",
              "fq_address": "A.0x2d4c3caffbeab845.FLOAT",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 47505899
            },
            "testnet": {
              "address": "0x0afe396ebc8eee65",
              "contract": "FLOAT",
              "fq_address": "A.0x0afe396ebc8eee65.FLOAT",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 95804554
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505918
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804561
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505925
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804570
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505929
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804573
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505931
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804574
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505934
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804583
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "cfd0c25234b8993aa947b0407d04b977f65daeb7ea02e2d7064ef16c39f50f47": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cfd0c25234b8993aa947b0407d04b977f65daeb7ea02e2d7064ef16c39f50f47",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support FLOAT NFTs"
          }
        }
      },
      "cadence": "import FLOAT from 0xFLOAT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: FLOAT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FLOAT.Collection>(from: /storage/FLOATCollectionStoragePath) == nil {\n      let collection <- FLOAT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/FLOATCollectionStoragePath)\n    }\n    if (signer.getCapability<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath).borrow() == nil) {\n      signer.unlink(/public/FLOATCollectionPublicPath)\n      signer.link<&FLOAT.Collection{FLOAT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/FLOATCollectionPublicPath, target: /storage/FLOATCollectionStoragePath)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xFLOAT": {
          "FLOAT": {
            "mainnet": {
              "address": "0x2d4c3caffbeab845",
              "contract": "FLOAT",
              "fq_address": "A.0x2d4c3caffbeab845.FLOAT",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 47505792
            },
            "testnet": {
              "address": "0x0afe396ebc8eee65",
              "contract": "FLOAT",
              "fq_address": "A.0x0afe396ebc8eee65.FLOAT",
              "pin": "3dbc7704912d6332a8a5e935df3581b95d9be6585bc522b37e1496043beb427b",
              "pin_block_height": 95804421
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505811
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804428
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505820
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804438
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "af831d44e0d892cec023d1fce74f3d32ae1a6a28cdac8de92d76f44fb150a765": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "af831d44e0d892cec023d1fce74f3d32ae1a6a28cdac8de92d76f44fb150a765",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Driverz NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Driverz\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499826
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797300
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "8ebf160b72e542d5075548dac19fb26d1a7ffd446a255356bfbf792a51b0bd09": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8ebf160b72e542d5075548dac19fb26d1a7ffd446a255356bfbf792a51b0bd09",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Driverz NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DriverzNFT from 0xDriverzNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Driverz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DriverzNFT.Collection>(from: /storage/DriverzNFTCollection) == nil {\n            let collection <- DriverzNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DriverzNFTCollection)\n        }\n        if (acct.getCapability<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection).borrow() == nil) {\n            acct.unlink(/public/DriverzNFTCollection)\n            acct.link<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n        }\n\n        if (acct.getCapability<&DriverzNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DriverzNFTCollection).borrow() == nil) {\n            acct.unlink(/private/DriverzNFTCollection)\n            acct.link<&DriverzNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DriverzNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/DriverzNFTCollection)\n            .borrow<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DriverzNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDriverzNFT": {
          "DriverzNFT": {
            "mainnet": {
              "address": "0xa039bd7d55a96c0c",
              "contract": "DriverzNFT",
              "fq_address": "A.0xa039bd7d55a96c0c.DriverzNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499742
            },
            "testnet": {
              "address": "0xf44b704689c35798",
              "contract": "DriverzNFT",
              "fq_address": "A.0xf44b704689c35798.DriverzNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797210
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499754
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797217
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499762
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797226
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499767
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95797229
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499769
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797230
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499773
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797239
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "5f9fa3e9e2df8eb853bd234b3c4595afb8fd19a061997d4c3d770d956b7ebda2": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5f9fa3e9e2df8eb853bd234b3c4595afb8fd19a061997d4c3d770d956b7ebda2",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Driverz NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DriverzNFT from 0xDriverzNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Driverz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DriverzNFT.Collection>(from: /storage/DriverzNFTCollection) == nil {\n            let collection <- DriverzNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DriverzNFTCollection)\n            }\n        if (acct.getCapability<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection).borrow() == nil) {\n            acct.unlink(/public/DriverzNFTCollection)\n            acct.link<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n        }\n\n        if (acct.getCapability<&DriverzNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DriverzNFTCollection).borrow() == nil) {\n            acct.unlink(/private/DriverzNFTCollection)\n            acct.link<&DriverzNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,MetadataViews.ResolverCollection}>(/private/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DriverzNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDriverzNFT": {
          "DriverzNFT": {
            "mainnet": {
              "address": "0xa039bd7d55a96c0c",
              "contract": "DriverzNFT",
              "fq_address": "A.0xa039bd7d55a96c0c.DriverzNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499787
            },
            "testnet": {
              "address": "0xf44b704689c35798",
              "contract": "DriverzNFT",
              "fq_address": "A.0xf44b704689c35798.DriverzNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797259
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499799
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797266
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499806
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797276
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499810
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95797278
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499813
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797279
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499817
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797289
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "ed58b65fc9d5500c4aa8ad33f5685e32358ea674f2cb57b996afbd09c68f59d9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ed58b65fc9d5500c4aa8ad33f5685e32358ea674f2cb57b996afbd09c68f59d9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Driverz NFTs"
          }
        }
      },
      "cadence": "import DriverzNFT from 0xDriverzNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Driverz\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DriverzNFT.Collection>(from: /storage/DriverzNFTCollection) == nil {\n      let collection <- DriverzNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DriverzNFTCollection)\n    }\n    if (signer.getCapability<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection).borrow() == nil) {\n      signer.unlink(/public/DriverzNFTCollection)\n      signer.link<&DriverzNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DriverzNFTCollection, target: /storage/DriverzNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDriverzNFT": {
          "DriverzNFT": {
            "mainnet": {
              "address": "0xa039bd7d55a96c0c",
              "contract": "DriverzNFT",
              "fq_address": "A.0xa039bd7d55a96c0c.DriverzNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47499710
            },
            "testnet": {
              "address": "0xf44b704689c35798",
              "contract": "DriverzNFT",
              "fq_address": "A.0xf44b704689c35798.DriverzNFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95797175
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499724
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95797182
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499731
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95797191
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "8779e8f45adaa635b86830d6b00ceb562ca04b828fe5fabc5241ceb5cadea2fd": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8779e8f45adaa635b86830d6b00ceb562ca04b828fe5fabc5241ceb5cadea2fd",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a DisruptArt NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: DisruptArt\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508077
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "199e09666d4e5968aa433f74e22f1f5a080c2529b8732894d3d0747672d27dd6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "199e09666d4e5968aa433f74e22f1f5a080c2529b8732894d3d0747672d27dd6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a DisruptArt NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DisruptArt from 0xDisruptArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: DisruptArt\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DisruptArt.Collection>(from: /storage/DisruptArtNFTCollection) == nil {\n            let collection <- DisruptArt.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DisruptArtNFTCollection)\n        }\n        if (acct.getCapability<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DisruptArtNFTPublicCollection).borrow() == nil) {\n            acct.unlink(/public/DisruptArtNFTPublicCollection)\n            acct.link<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DisruptArtNFTPublicCollection, target: /storage/DisruptArtNFTCollection)\n        }\n\n        if (acct.getCapability<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DisruptArtNFTCollection).borrow() == nil) {\n            acct.unlink(/private/DisruptArtNFTCollection)\n            acct.link<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DisruptArtNFTCollection, target: /storage/DisruptArtNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DisruptArtNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/DisruptArtNFTPublicCollection)\n            .borrow<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DisruptArt.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDisruptArt": {
          "DisruptArt": {
            "mainnet": {
              "address": "0xcd946ef9b13804c6",
              "contract": "DisruptArt",
              "fq_address": "A.0xcd946ef9b13804c6.DisruptArt",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508039
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508041
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508047
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508047
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508047
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508051
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "5cdc223173e85994b760ddc2142666b56ecbab8286bf847321bf2e406e7d93dc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5cdc223173e85994b760ddc2142666b56ecbab8286bf847321bf2e406e7d93dc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed DisruptArt NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DisruptArt from 0xDisruptArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: DisruptArt\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DisruptArt.Collection>(from: /storage/DisruptArtNFTCollection) == nil {\n            let collection <- DisruptArt.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DisruptArtNFTCollection)\n            }\n        if (acct.getCapability<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DisruptArtNFTPublicCollection).borrow() == nil) {\n            acct.unlink(/public/DisruptArtNFTPublicCollection)\n            acct.link<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DisruptArtNFTPublicCollection, target: /storage/DisruptArtNFTCollection)\n        }\n\n        if (acct.getCapability<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DisruptArtNFTCollection).borrow() == nil) {\n            acct.unlink(/private/DisruptArtNFTCollection)\n            acct.link<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DisruptArtNFTCollection, target: /storage/DisruptArtNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DisruptArtNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDisruptArt": {
          "DisruptArt": {
            "mainnet": {
              "address": "0xcd946ef9b13804c6",
              "contract": "DisruptArt",
              "fq_address": "A.0xcd946ef9b13804c6.DisruptArt",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508060
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508064
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508068
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508068
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508068
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508074
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "ab453bc3bbbdbae4775b20475e66644aa828dc01fedf8e82d55ec6b0d1b59dc9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ab453bc3bbbdbae4775b20475e66644aa828dc01fedf8e82d55ec6b0d1b59dc9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support DisruptArt NFTs"
          }
        }
      },
      "cadence": "import DisruptArt from 0xDisruptArt\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: DisruptArt\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DisruptArt.Collection>(from: /storage/DisruptArtNFTCollection) == nil {\n      let collection <- DisruptArt.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DisruptArtNFTCollection)\n    }\n    if (signer.getCapability<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DisruptArtNFTPublicCollection).borrow() == nil) {\n      signer.unlink(/public/DisruptArtNFTPublicCollection)\n      signer.link<&DisruptArt.Collection{DisruptArt.DisruptArtCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DisruptArtNFTPublicCollection, target: /storage/DisruptArtNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDisruptArt": {
          "DisruptArt": {
            "mainnet": {
              "address": "0xcd946ef9b13804c6",
              "contract": "DisruptArt",
              "fq_address": "A.0xcd946ef9b13804c6.DisruptArt",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508023
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508026
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508031
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "23de556d3f6f01ec5c1f72443d2311b5d1447d71f29ea72e4d3149ed6dd618e1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "23de556d3f6f01ec5c1f72443d2311b5d1447d71f29ea72e4d3149ed6dd618e1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a DooverseItems NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: DooverseItems\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501383
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "cb32089a100e66efa7ebeb1210deaf80830b10bb19bd2d7589e89400e4febd5f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cb32089a100e66efa7ebeb1210deaf80830b10bb19bd2d7589e89400e4febd5f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a DooverseItems NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DooverseItems from 0xDooverseItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: DooverseItems\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DooverseItems.Collection>(from: /storage/DooverseItemsCollection) == nil {\n            let collection <- DooverseItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DooverseItemsCollection)\n        }\n        if (acct.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection).borrow() == nil) {\n            acct.unlink(/public/DooverseItemsCollection)\n            acct.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n        }\n\n        if (acct.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DooverseItemsCollection).borrow() == nil) {\n            acct.unlink(/private/DooverseItemsCollection)\n            acct.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DooverseItemsCollection)!\n        let collectionRef = acct\n            .getCapability(/public/DooverseItemsCollection)\n            .borrow<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DooverseItems.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDooverseItems": {
          "DooverseItems": {
            "mainnet": {
              "address": "0x66ad29c7d7465437",
              "contract": "DooverseItems",
              "fq_address": "A.0x66ad29c7d7465437.DooverseItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47501343
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501346
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501351
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501352
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501352
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501356
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "e984350b0fe1bacb718f95a01cd179648da6f3891b68d194ee2c5f41d979663a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e984350b0fe1bacb718f95a01cd179648da6f3891b68d194ee2c5f41d979663a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed DooverseItems NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DooverseItems from 0xDooverseItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: DooverseItems\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DooverseItems.Collection>(from: /storage/DooverseItemsCollection) == nil {\n            let collection <- DooverseItems.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DooverseItemsCollection)\n            }\n        if (acct.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection).borrow() == nil) {\n            acct.unlink(/public/DooverseItemsCollection)\n            acct.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n        }\n\n        if (acct.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DooverseItemsCollection).borrow() == nil) {\n            acct.unlink(/private/DooverseItemsCollection)\n            acct.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DooverseItemsCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDooverseItems": {
          "DooverseItems": {
            "mainnet": {
              "address": "0x66ad29c7d7465437",
              "contract": "DooverseItems",
              "fq_address": "A.0x66ad29c7d7465437.DooverseItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47501365
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501369
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501372
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501374
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501374
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501378
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f3fd493a0289c8de92501e8fe537b1ddf3687b89b81a27605a78fcfcc8104050": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f3fd493a0289c8de92501e8fe537b1ddf3687b89b81a27605a78fcfcc8104050",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support DooverseItems NFTs"
          }
        }
      },
      "cadence": "import DooverseItems from 0xDooverseItems\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: DooverseItems\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DooverseItems.Collection>(from: /storage/DooverseItemsCollection) == nil {\n      let collection <- DooverseItems.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DooverseItemsCollection)\n    }\n    if (signer.getCapability<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection).borrow() == nil) {\n      signer.unlink(/public/DooverseItemsCollection)\n      signer.link<&DooverseItems.Collection{DooverseItems.DooverseItemsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DooverseItemsCollection, target: /storage/DooverseItemsCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDooverseItems": {
          "DooverseItems": {
            "mainnet": {
              "address": "0x66ad29c7d7465437",
              "contract": "DooverseItems",
              "fq_address": "A.0x66ad29c7d7465437.DooverseItems",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47501329
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501332
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501337
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "ced272c524abea0bb3d067ce7232bd0e8adff1203862f36ee2f92d416c53bfe4": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ced272c524abea0bb3d067ce7232bd0e8adff1203862f36ee2f92d416c53bfe4",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a DaysOnFlow NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: DaysOnFlow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502736
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "5a2b783d86c7787c7e619b12d92cc6b6df890816634cd2af230f38c0719cd43e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5a2b783d86c7787c7e619b12d92cc6b6df890816634cd2af230f38c0719cd43e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a DaysOnFlow NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DaysOnFlow from 0xDaysOnFlow\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: DaysOnFlow\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DaysOnFlow.Collection>(from: /storage/DOFCollectionStoragePath) == nil {\n            let collection <- DaysOnFlow.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DOFCollectionStoragePath)\n        }\n        if (acct.getCapability<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DOFCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/DOFCollectionPublicPath)\n            acct.link<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DOFCollectionPublicPath, target: /storage/DOFCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DOFCollectionProviderPath).borrow() == nil) {\n            acct.unlink(/private/DOFCollectionProviderPath)\n            acct.link<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DOFCollectionProviderPath, target: /storage/DOFCollectionStoragePath)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DOFCollectionProviderPath)!\n        let collectionRef = acct\n            .getCapability(/public/DOFCollectionPublicPath)\n            .borrow<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DaysOnFlow.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDaysOnFlow": {
          "DaysOnFlow": {
            "mainnet": {
              "address": "0x799da0ef17f38104",
              "contract": "DaysOnFlow",
              "fq_address": "A.0x799da0ef17f38104.DaysOnFlow",
              "pin": "7c7ff03a10696b7639f235e42b57becdfbdbcee1bb6f99d01f922d4554fe51f0",
              "pin_block_height": 47502684
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502686
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502690
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502690
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502691
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502695
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "c2f26968a58b9ad34024a523bab2065aac547d735ec8b4e80be2ece47f05e0aa": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c2f26968a58b9ad34024a523bab2065aac547d735ec8b4e80be2ece47f05e0aa",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed DaysOnFlow NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DaysOnFlow from 0xDaysOnFlow\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: DaysOnFlow\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DaysOnFlow.Collection>(from: /storage/DOFCollectionStoragePath) == nil {\n            let collection <- DaysOnFlow.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DOFCollectionStoragePath)\n            }\n        if (acct.getCapability<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DOFCollectionPublicPath).borrow() == nil) {\n            acct.unlink(/public/DOFCollectionPublicPath)\n            acct.link<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DOFCollectionPublicPath, target: /storage/DOFCollectionStoragePath)\n        }\n\n        if (acct.getCapability<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DOFCollectionProviderPath).borrow() == nil) {\n            acct.unlink(/private/DOFCollectionProviderPath)\n            acct.link<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DOFCollectionProviderPath, target: /storage/DOFCollectionStoragePath)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DOFCollectionStoragePath\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDaysOnFlow": {
          "DaysOnFlow": {
            "mainnet": {
              "address": "0x799da0ef17f38104",
              "contract": "DaysOnFlow",
              "fq_address": "A.0x799da0ef17f38104.DaysOnFlow",
              "pin": "7c7ff03a10696b7639f235e42b57becdfbdbcee1bb6f99d01f922d4554fe51f0",
              "pin_block_height": 47502718
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502721
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502725
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47502725
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502726
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502731
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "d670de0f7f1cb5786189c2f42e61ace07e429cd5763e5a68e236a56325b829cc": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d670de0f7f1cb5786189c2f42e61ace07e429cd5763e5a68e236a56325b829cc",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support DaysOnFlow NFTs"
          }
        }
      },
      "cadence": "import DaysOnFlow from 0xDaysOnFlow\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: DaysOnFlow\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DaysOnFlow.Collection>(from: /storage/DOFCollectionStoragePath) == nil {\n      let collection <- DaysOnFlow.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DOFCollectionStoragePath)\n    }\n    if (signer.getCapability<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DOFCollectionPublicPath).borrow() == nil) {\n      signer.unlink(/public/DOFCollectionPublicPath)\n      signer.link<&DaysOnFlow.Collection{DaysOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DOFCollectionPublicPath, target: /storage/DOFCollectionStoragePath)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDaysOnFlow": {
          "DaysOnFlow": {
            "mainnet": {
              "address": "0x799da0ef17f38104",
              "contract": "DaysOnFlow",
              "fq_address": "A.0x799da0ef17f38104.DaysOnFlow",
              "pin": "7c7ff03a10696b7639f235e42b57becdfbdbcee1bb6f99d01f922d4554fe51f0",
              "pin_block_height": 47502658
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47502662
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47502665
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "c312fb4f8a28c2e1b32dd4208d20643e1c828079ae68b326477b5800446c0505": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c312fb4f8a28c2e1b32dd4208d20643e1c828079ae68b326477b5800446c0505",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a DimensionX NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: DimensionX\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505061
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "2dccee342033379e30c97494632ac1310b4d66e7c108a0060bdecba2a4e09a83": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2dccee342033379e30c97494632ac1310b4d66e7c108a0060bdecba2a4e09a83",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a DimensionX NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DimensionX from 0xDimensionX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: DimensionX\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DimensionX.Collection>(from: /storage/dmxCollection) == nil {\n            let collection <- DimensionX.createEmptyCollection()\n            acct.save(<-collection, to: /storage/dmxCollection)\n        }\n        if (acct.getCapability<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/dmxCollection).borrow() == nil) {\n            acct.unlink(/public/dmxCollection)\n            acct.link<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/dmxCollection, target: /storage/dmxCollection)\n        }\n\n        if (acct.getCapability<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dmxCollection).borrow() == nil) {\n            acct.unlink(/private/dmxCollection)\n            acct.link<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dmxCollection, target: /storage/dmxCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/dmxCollection)!\n        let collectionRef = acct\n            .getCapability(/public/dmxCollection)\n            .borrow<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DimensionX.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDimensionX": {
          "DimensionX": {
            "mainnet": {
              "address": "0xe3ad6030cbaff1c2",
              "contract": "DimensionX",
              "fq_address": "A.0xe3ad6030cbaff1c2.DimensionX",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47505023
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505026
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505031
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505032
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505032
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505037
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "773cb54aeab6f069320f6d524368e269d4470eff1194e7540627233c4838626e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "773cb54aeab6f069320f6d524368e269d4470eff1194e7540627233c4838626e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed DimensionX NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DimensionX from 0xDimensionX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: DimensionX\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DimensionX.Collection>(from: /storage/dmxCollection) == nil {\n            let collection <- DimensionX.createEmptyCollection()\n            acct.save(<-collection, to: /storage/dmxCollection)\n            }\n        if (acct.getCapability<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/dmxCollection).borrow() == nil) {\n            acct.unlink(/public/dmxCollection)\n            acct.link<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/dmxCollection, target: /storage/dmxCollection)\n        }\n\n        if (acct.getCapability<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dmxCollection).borrow() == nil) {\n            acct.unlink(/private/dmxCollection)\n            acct.link<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/dmxCollection, target: /storage/dmxCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/dmxCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDimensionX": {
          "DimensionX": {
            "mainnet": {
              "address": "0xe3ad6030cbaff1c2",
              "contract": "DimensionX",
              "fq_address": "A.0xe3ad6030cbaff1c2.DimensionX",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47505045
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505048
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505052
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47505053
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505053
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505057
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "be16088ec1e0da729d7b32b93203b7d03a7240db02fa69db810821db967820c8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "be16088ec1e0da729d7b32b93203b7d03a7240db02fa69db810821db967820c8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support DimensionX NFTs"
          }
        }
      },
      "cadence": "import DimensionX from 0xDimensionX\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: DimensionX\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DimensionX.Collection>(from: /storage/dmxCollection) == nil {\n      let collection <- DimensionX.createEmptyCollection()\n      signer.save(<-collection, to: /storage/dmxCollection)\n    }\n    if (signer.getCapability<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/dmxCollection).borrow() == nil) {\n      signer.unlink(/public/dmxCollection)\n      signer.link<&DimensionX.Collection{DimensionX.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/dmxCollection, target: /storage/dmxCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDimensionX": {
          "DimensionX": {
            "mainnet": {
              "address": "0xe3ad6030cbaff1c2",
              "contract": "DimensionX",
              "fq_address": "A.0xe3ad6030cbaff1c2.DimensionX",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47505007
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505009
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505014
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "577cfda1dbc7d9fe24f2dd73c24851736fba3088ab603218d45349f6cee76462": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "577cfda1dbc7d9fe24f2dd73c24851736fba3088ab603218d45349f6cee76462",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a DayNFT NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: DayNFT\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508903
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "b620315f726a013e2ac725a6dc77ca408e711fc31ee2e88766a04d7424ebba55": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b620315f726a013e2ac725a6dc77ca408e711fc31ee2e88766a04d7424ebba55",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a DayNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DayNFT from 0xDayNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: DayNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DayNFT.Collection>(from: /storage/DayNFTCollection) == nil {\n            let collection <- DayNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DayNFTCollection)\n        }\n        if (acct.getCapability<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DayNFTCollection).borrow() == nil) {\n            acct.unlink(/public/DayNFTCollection)\n            acct.link<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DayNFTCollection, target: /storage/DayNFTCollection)\n        }\n\n        if (acct.getCapability<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DayNFTCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/DayNFTCollectionProvider)\n            acct.link<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DayNFTCollectionProvider, target: /storage/DayNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DayNFTCollectionProvider)!\n        let collectionRef = acct\n            .getCapability(/public/DayNFTCollection)\n            .borrow<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DayNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDayNFT": {
          "DayNFT": {
            "mainnet": {
              "address": "0x1600b04bf033fb99",
              "contract": "DayNFT",
              "fq_address": "A.0x1600b04bf033fb99.DayNFT",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47508864
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508867
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508872
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508872
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508872
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508877
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "f650255b1d22d6c58cf954219b38a6af047302cc457952d540008f60b1f63372": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f650255b1d22d6c58cf954219b38a6af047302cc457952d540008f60b1f63372",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed DayNFT NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DayNFT from 0xDayNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: DayNFT\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DayNFT.Collection>(from: /storage/DayNFTCollection) == nil {\n            let collection <- DayNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DayNFTCollection)\n            }\n        if (acct.getCapability<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DayNFTCollection).borrow() == nil) {\n            acct.unlink(/public/DayNFTCollection)\n            acct.link<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DayNFTCollection, target: /storage/DayNFTCollection)\n        }\n\n        if (acct.getCapability<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DayNFTCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/DayNFTCollectionProvider)\n            acct.link<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DayNFTCollectionProvider, target: /storage/DayNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DayNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDayNFT": {
          "DayNFT": {
            "mainnet": {
              "address": "0x1600b04bf033fb99",
              "contract": "DayNFT",
              "fq_address": "A.0x1600b04bf033fb99.DayNFT",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47508888
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508889
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508895
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508895
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508895
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508898
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "2d4d16aaae3dcb6e7eecb3c5049480b8d6ff281079092ed6f51f1efb040393fe": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2d4d16aaae3dcb6e7eecb3c5049480b8d6ff281079092ed6f51f1efb040393fe",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support DayNFT NFTs"
          }
        }
      },
      "cadence": "import DayNFT from 0xDayNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: DayNFT\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DayNFT.Collection>(from: /storage/DayNFTCollection) == nil {\n      let collection <- DayNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DayNFTCollection)\n    }\n    if (signer.getCapability<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DayNFTCollection).borrow() == nil) {\n      signer.unlink(/public/DayNFTCollection)\n      signer.link<&DayNFT.Collection{DayNFT.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DayNFTCollection, target: /storage/DayNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDayNFT": {
          "DayNFT": {
            "mainnet": {
              "address": "0x1600b04bf033fb99",
              "contract": "DayNFT",
              "fq_address": "A.0x1600b04bf033fb99.DayNFT",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47508847
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508849
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508853
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "5e024c9945c2b1b9207647062bf917ef36707b400af1fe1c108fa42d08b75055": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5e024c9945c2b1b9207647062bf917ef36707b400af1fe1c108fa42d08b75055",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Dandy NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Dandy\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488860
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "9d654eb45385cbe72a23fc2935c033f3a0f1069e081a836b7442d182acc35727": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9d654eb45385cbe72a23fc2935c033f3a0f1069e081a836b7442d182acc35727",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Dandy NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Dandy from 0xDandy\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Dandy\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Dandy.Collection>(from: /storage/findDandy) == nil {\n            let collection <- Dandy.createEmptyCollection()\n            acct.save(<-collection, to: /storage/findDandy)\n        }\n        if (acct.getCapability<&Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/public/findDandy).borrow() == nil) {\n            acct.unlink(/public/findDandy)\n            acct.link<&Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/public/findDandy, target: /storage/findDandy)\n        }\n\n        if (acct.getCapability<&Dandy.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/private/findDandy).borrow() == nil) {\n            acct.unlink(/private/findDandy)\n            acct.link<&Dandy.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/private/findDandy, target: /storage/findDandy)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/findDandy)!\n        let collectionRef = acct\n            .getCapability(/public/findDandy)\n            .borrow<&Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Dandy.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDandy": {
          "Dandy": {
            "mainnet": {
              "address": "0x097bafa4e0b48eef",
              "contract": "Dandy",
              "fq_address": "A.0x097bafa4e0b48eef.Dandy",
              "pin": "a31620c5d89979711dca230d1b1b4ee0895195a179f56677fb588f5aa7180dc6",
              "pin_block_height": 47488768
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488772
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488775
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488776
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488776
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488782
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "e4ae2f6b276baac42bf7eb9db5717807e751bc58edd766be5934ca39156b25e4": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e4ae2f6b276baac42bf7eb9db5717807e751bc58edd766be5934ca39156b25e4",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Dandy NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Dandy from 0xDandy\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Dandy\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Dandy.Collection>(from: /storage/findDandy) == nil {\n            let collection <- Dandy.createEmptyCollection()\n            acct.save(<-collection, to: /storage/findDandy)\n            }\n        if (acct.getCapability<&Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/public/findDandy).borrow() == nil) {\n            acct.unlink(/public/findDandy)\n            acct.link<&Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/public/findDandy, target: /storage/findDandy)\n        }\n\n        if (acct.getCapability<&Dandy.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/private/findDandy).borrow() == nil) {\n            acct.unlink(/private/findDandy)\n            acct.link<&Dandy.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/private/findDandy, target: /storage/findDandy)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(\n            from: /storage/findDandy\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDandy": {
          "Dandy": {
            "mainnet": {
              "address": "0x097bafa4e0b48eef",
              "contract": "Dandy",
              "fq_address": "A.0x097bafa4e0b48eef.Dandy",
              "pin": "a31620c5d89979711dca230d1b1b4ee0895195a179f56677fb588f5aa7180dc6",
              "pin_block_height": 47488844
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488847
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488850
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488852
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488852
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488857
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "76af171becb04547c0176ab75e015383db5343b2f4188aee1567e51d5f1cf723": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "76af171becb04547c0176ab75e015383db5343b2f4188aee1567e51d5f1cf723",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Dandy NFTs"
          }
        }
      },
      "cadence": "import Dandy from 0xDandy\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Dandy\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Dandy.Collection>(from: /storage/findDandy) == nil {\n      let collection <- Dandy.createEmptyCollection()\n      signer.save(<-collection, to: /storage/findDandy)\n    }\n    if (signer.getCapability<&Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/public/findDandy).borrow() == nil) {\n      signer.unlink(/public/findDandy)\n      signer.link<&Dandy.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,Dandy.CollectionPublic}>(/public/findDandy, target: /storage/findDandy)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDandy": {
          "Dandy": {
            "mainnet": {
              "address": "0x097bafa4e0b48eef",
              "contract": "Dandy",
              "fq_address": "A.0x097bafa4e0b48eef.Dandy",
              "pin": "a31620c5d89979711dca230d1b1b4ee0895195a179f56677fb588f5aa7180dc6",
              "pin_block_height": 47488698
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488703
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488706
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "94fd10932e032823f5ce4009d866cf8454134e730eb415fab98b232d3dda0dde": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "94fd10932e032823f5ce4009d866cf8454134e730eb415fab98b232d3dda0dde",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a DalleOnFlow NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: DalleOnFlow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501870
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "28cc7a65eb89f32c78ca058bd8efd4a453a35b1ac6f052105c63e3b9dbe211f6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "28cc7a65eb89f32c78ca058bd8efd4a453a35b1ac6f052105c63e3b9dbe211f6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a DalleOnFlow NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DalleOnFlow from 0xDalleOnFlow\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: DalleOnFlow\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DalleOnFlow.Collection>(from: /storage/DalleOnFlowCollection) == nil {\n            let collection <- DalleOnFlow.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DalleOnFlowCollection)\n        }\n        if (acct.getCapability<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DalleOnFlowCollection).borrow() == nil) {\n            acct.unlink(/public/DalleOnFlowCollection)\n            acct.link<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DalleOnFlowCollection, target: /storage/DalleOnFlowCollection)\n        }\n\n        if (acct.getCapability<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DalleOnFlowCollection).borrow() == nil) {\n            acct.unlink(/private/DalleOnFlowCollection)\n            acct.link<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DalleOnFlowCollection, target: /storage/DalleOnFlowCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/DalleOnFlowCollection)!\n        let collectionRef = acct\n            .getCapability(/public/DalleOnFlowCollection)\n            .borrow<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@DalleOnFlow.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xDalleOnFlow": {
          "DalleOnFlow": {
            "mainnet": {
              "address": "0x58d08685febcfea5",
              "contract": "DalleOnFlow",
              "fq_address": "A.0x58d08685febcfea5.DalleOnFlow",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47501829
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501833
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501837
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501838
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501838
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501843
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "39055641b4a72c4032f96f2fb4ceefe78a9a82784c0cf9d73043f1a2d6932d0c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "39055641b4a72c4032f96f2fb4ceefe78a9a82784c0cf9d73043f1a2d6932d0c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed DalleOnFlow NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import DalleOnFlow from 0xDalleOnFlow\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: DalleOnFlow\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&DalleOnFlow.Collection>(from: /storage/DalleOnFlowCollection) == nil {\n            let collection <- DalleOnFlow.createEmptyCollection()\n            acct.save(<-collection, to: /storage/DalleOnFlowCollection)\n            }\n        if (acct.getCapability<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DalleOnFlowCollection).borrow() == nil) {\n            acct.unlink(/public/DalleOnFlowCollection)\n            acct.link<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DalleOnFlowCollection, target: /storage/DalleOnFlowCollection)\n        }\n\n        if (acct.getCapability<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DalleOnFlowCollection).borrow() == nil) {\n            acct.unlink(/private/DalleOnFlowCollection)\n            acct.link<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/DalleOnFlowCollection, target: /storage/DalleOnFlowCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/DalleOnFlowCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xDalleOnFlow": {
          "DalleOnFlow": {
            "mainnet": {
              "address": "0x58d08685febcfea5",
              "contract": "DalleOnFlow",
              "fq_address": "A.0x58d08685febcfea5.DalleOnFlow",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47501852
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501855
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501860
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501861
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501862
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501865
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "9b486be24a547c15331743affbfc5da78dabf138aef95b2373c9678e0fc41906": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9b486be24a547c15331743affbfc5da78dabf138aef95b2373c9678e0fc41906",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support DalleOnFlow NFTs"
          }
        }
      },
      "cadence": "import DalleOnFlow from 0xDalleOnFlow\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: DalleOnFlow\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&DalleOnFlow.Collection>(from: /storage/DalleOnFlowCollection) == nil {\n      let collection <- DalleOnFlow.createEmptyCollection()\n      signer.save(<-collection, to: /storage/DalleOnFlowCollection)\n    }\n    if (signer.getCapability<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DalleOnFlowCollection).borrow() == nil) {\n      signer.unlink(/public/DalleOnFlowCollection)\n      signer.link<&DalleOnFlow.Collection{DalleOnFlow.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/DalleOnFlowCollection, target: /storage/DalleOnFlowCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xDalleOnFlow": {
          "DalleOnFlow": {
            "mainnet": {
              "address": "0x58d08685febcfea5",
              "contract": "DalleOnFlow",
              "fq_address": "A.0x58d08685febcfea5.DalleOnFlow",
              "pin": "d00a96b60721e1606bb257a08b3c1d3fa16be292ed87d3e51941c875f673da0f",
              "pin_block_height": 47501812
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501814
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501820
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "60894d892bf257a701b01dfce61f62c6d574461865a8e119b8a3954e91d3bb49": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "60894d892bf257a701b01dfce61f62c6d574461865a8e119b8a3954e91d3bb49",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a CuveeCollectiveWine NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: CuveeCollectiveWine\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501302
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "fb0608cd6d14996746f486c42a8a73f2f1ca25578eec8bfac870bda36b146e6f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fb0608cd6d14996746f486c42a8a73f2f1ca25578eec8bfac870bda36b146e6f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a CuveeCollectiveWine NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Wine from 0xWine\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: CuveeCollectiveWine\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Wine.Collection>(from: /storage/WineCollection) == nil {\n            let collection <- Wine.createEmptyCollection()\n            acct.save(<-collection, to: /storage/WineCollection)\n        }\n        if (acct.getCapability<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/WineCollection).borrow() == nil) {\n            acct.unlink(/public/WineCollection)\n            acct.link<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/WineCollection, target: /storage/WineCollection)\n        }\n\n        if (acct.getCapability<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/WineCollection).borrow() == nil) {\n            acct.unlink(/private/WineCollection)\n            acct.link<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/WineCollection, target: /storage/WineCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/WineCollection)!\n        let collectionRef = acct\n            .getCapability(/public/WineCollection)\n            .borrow<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Wine.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xWine": {
          "Wine": {
            "mainnet": {
              "address": "0xfb27085fbb495d1d",
              "contract": "Wine",
              "fq_address": "A.0xfb27085fbb495d1d.Wine",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47501265
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501267
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501272
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501273
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501273
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501277
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "835665c0b884933ea76b85279cf2e885bde2ab0510b919fdaf058985e2cbac33": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "835665c0b884933ea76b85279cf2e885bde2ab0510b919fdaf058985e2cbac33",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed CuveeCollectiveWine NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Wine from 0xWine\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: CuveeCollectiveWine\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Wine.Collection>(from: /storage/WineCollection) == nil {\n            let collection <- Wine.createEmptyCollection()\n            acct.save(<-collection, to: /storage/WineCollection)\n            }\n        if (acct.getCapability<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/WineCollection).borrow() == nil) {\n            acct.unlink(/public/WineCollection)\n            acct.link<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/WineCollection, target: /storage/WineCollection)\n        }\n\n        if (acct.getCapability<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/WineCollection).borrow() == nil) {\n            acct.unlink(/private/WineCollection)\n            acct.link<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/WineCollection, target: /storage/WineCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/WineCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xWine": {
          "Wine": {
            "mainnet": {
              "address": "0xfb27085fbb495d1d",
              "contract": "Wine",
              "fq_address": "A.0xfb27085fbb495d1d.Wine",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47501286
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501287
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501294
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501295
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501295
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501299
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "16355a9615ca4339cc751394e1a10d10d0c8a582d287e410f6b8def9a27a9abb": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "16355a9615ca4339cc751394e1a10d10d0c8a582d287e410f6b8def9a27a9abb",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support CuveeCollectiveWine NFTs"
          }
        }
      },
      "cadence": "import Wine from 0xWine\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: CuveeCollectiveWine\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Wine.Collection>(from: /storage/WineCollection) == nil {\n      let collection <- Wine.createEmptyCollection()\n      signer.save(<-collection, to: /storage/WineCollection)\n    }\n    if (signer.getCapability<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/WineCollection).borrow() == nil) {\n      signer.unlink(/public/WineCollection)\n      signer.link<&Wine.Collection{Wine.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/WineCollection, target: /storage/WineCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xWine": {
          "Wine": {
            "mainnet": {
              "address": "0xfb27085fbb495d1d",
              "contract": "Wine",
              "fq_address": "A.0xfb27085fbb495d1d.Wine",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47501248
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501252
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501257
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "5e9898a99e47f267ac05f39585605bf0615477b440cd79e7baa3b7fd6cbcdd7b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5e9898a99e47f267ac05f39585605bf0615477b440cd79e7baa3b7fd6cbcdd7b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a CryptoPiggoNFTCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: CryptoPiggoNFTCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506067
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804739
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "def1d535116f42adfb54b210262cedb01c7f53a81939f7a0e13a601e07410b46": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "def1d535116f42adfb54b210262cedb01c7f53a81939f7a0e13a601e07410b46",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a CryptoPiggoNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CryptoPiggo from 0xCryptoPiggo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: CryptoPiggoNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggo.Collection>(from: /storage/CryptoPiggoCollection) == nil {\n            let collection <- CryptoPiggo.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoCollection)\n        }\n        if (acct.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoCollection)\n            acct.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n        }\n\n        if (acct.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoCollection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoCollection)\n            acct.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CryptoPiggoCollection)!\n        let collectionRef = acct\n            .getCapability(/public/CryptoPiggoCollection)\n            .borrow<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CryptoPiggo.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCryptoPiggo": {
          "CryptoPiggo": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggo",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505987
            },
            "testnet": {
              "address": "0x57e1b27618c5bb69",
              "contract": "CryptoPiggo",
              "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804650
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505998
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804657
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506005
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804667
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506009
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804669
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506011
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804670
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506016
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804680
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "c87fc8b202dd7efcdc1bd64a99ab3ac4a187633be33476af01b810817b98af94": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c87fc8b202dd7efcdc1bd64a99ab3ac4a187633be33476af01b810817b98af94",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed CryptoPiggoNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CryptoPiggo from 0xCryptoPiggo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: CryptoPiggoNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggo.Collection>(from: /storage/CryptoPiggoCollection) == nil {\n            let collection <- CryptoPiggo.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoCollection)\n            }\n        if (acct.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoCollection)\n            acct.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n        }\n\n        if (acct.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoCollection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoCollection)\n            acct.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CryptoPiggoCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCryptoPiggo": {
          "CryptoPiggo": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggo",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506028
            },
            "testnet": {
              "address": "0x57e1b27618c5bb69",
              "contract": "CryptoPiggo",
              "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804699
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506039
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804705
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506046
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804715
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506051
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804718
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506053
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804719
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506057
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804728
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e888652cd84c570f22912beb53fdea08cd06c53dc41824a08978ef845d7848b8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e888652cd84c570f22912beb53fdea08cd06c53dc41824a08978ef845d7848b8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support CryptoPiggoNFTCollection NFTs"
          }
        }
      },
      "cadence": "import CryptoPiggo from 0xCryptoPiggo\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: CryptoPiggoNFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CryptoPiggo.Collection>(from: /storage/CryptoPiggoCollection) == nil {\n      let collection <- CryptoPiggo.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CryptoPiggoCollection)\n    }\n    if (signer.getCapability<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection).borrow() == nil) {\n      signer.unlink(/public/CryptoPiggoCollection)\n      signer.link<&CryptoPiggo.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoCollection, target: /storage/CryptoPiggoCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCryptoPiggo": {
          "CryptoPiggo": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggo",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47505957
            },
            "testnet": {
              "address": "0x57e1b27618c5bb69",
              "contract": "CryptoPiggo",
              "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggo",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804613
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47505967
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804621
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47505973
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804631
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "bb3c2af45037afcdc2c5bf3d352bbb77719687ec1680d9a1102965b8bb4f3d3d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "bb3c2af45037afcdc2c5bf3d352bbb77719687ec1680d9a1102965b8bb4f3d3d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a CryptoPiggoV2NFTCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: CryptoPiggoV2NFTCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47504992
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803439
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "14d11ff5da9d4a6d32e3208c12c0c8eec76dc0b8027617a7bedb55b2e2206d40": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "14d11ff5da9d4a6d32e3208c12c0c8eec76dc0b8027617a7bedb55b2e2206d40",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a CryptoPiggoV2NFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CryptoPiggoV2 from 0xCryptoPiggoV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: CryptoPiggoV2NFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggoV2.Collection>(from: /storage/CryptoPiggoV2Collection) == nil {\n            let collection <- CryptoPiggoV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoV2Collection)\n        }\n        if (acct.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoV2Collection)\n            acct.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n        }\n\n        if (acct.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoV2Collection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoV2Collection)\n            acct.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CryptoPiggoV2Collection)!\n        let collectionRef = acct\n            .getCapability(/public/CryptoPiggoV2Collection)\n            .borrow<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@CryptoPiggoV2.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCryptoPiggoV2": {
          "CryptoPiggoV2": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggoV2",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoV2",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47504912
            },
            "testnet": {
              "address": "0x57e1b27618c5bb69",
              "contract": "CryptoPiggoV2",
              "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggoV2",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95803350
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47504923
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803357
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47504929
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803366
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47504935
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95803368
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47504935
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803369
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47504940
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803379
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "d11f0e32c5cd012a5661a820db4c6db7602d2ff896eea8ab9226fb300782cefa": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d11f0e32c5cd012a5661a820db4c6db7602d2ff896eea8ab9226fb300782cefa",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed CryptoPiggoV2NFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import CryptoPiggoV2 from 0xCryptoPiggoV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: CryptoPiggoV2NFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&CryptoPiggoV2.Collection>(from: /storage/CryptoPiggoV2Collection) == nil {\n            let collection <- CryptoPiggoV2.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CryptoPiggoV2Collection)\n            }\n        if (acct.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection).borrow() == nil) {\n            acct.unlink(/public/CryptoPiggoV2Collection)\n            acct.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n        }\n\n        if (acct.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoV2Collection).borrow() == nil) {\n            acct.unlink(/private/CryptoPiggoV2Collection)\n            acct.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CryptoPiggoV2Collection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCryptoPiggoV2": {
          "CryptoPiggoV2": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggoV2",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoV2",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47504954
            },
            "testnet": {
              "address": "0x57e1b27618c5bb69",
              "contract": "CryptoPiggoV2",
              "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggoV2",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95803398
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47504965
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803406
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47504972
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803415
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47504978
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95803418
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47504979
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803419
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47504983
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803429
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "29676248d93ef6de6d43d2f4c26438e047b928c531b0a07e68026ab484708148": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "29676248d93ef6de6d43d2f4c26438e047b928c531b0a07e68026ab484708148",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support CryptoPiggoV2NFTCollection NFTs"
          }
        }
      },
      "cadence": "import CryptoPiggoV2 from 0xCryptoPiggoV2\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: CryptoPiggoV2NFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&CryptoPiggoV2.Collection>(from: /storage/CryptoPiggoV2Collection) == nil {\n      let collection <- CryptoPiggoV2.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CryptoPiggoV2Collection)\n    }\n    if (signer.getCapability<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection).borrow() == nil) {\n      signer.unlink(/public/CryptoPiggoV2Collection)\n      signer.link<&CryptoPiggoV2.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CryptoPiggoV2Collection, target: /storage/CryptoPiggoV2Collection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCryptoPiggoV2": {
          "CryptoPiggoV2": {
            "mainnet": {
              "address": "0xd3df824bf81910a4",
              "contract": "CryptoPiggoV2",
              "fq_address": "A.0xd3df824bf81910a4.CryptoPiggoV2",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47504878
            },
            "testnet": {
              "address": "0x57e1b27618c5bb69",
              "contract": "CryptoPiggoV2",
              "fq_address": "A.0x57e1b27618c5bb69.CryptoPiggoV2",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95803312
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47504890
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95803319
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47504898
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95803329
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "04c2ecfd9e9ee99af9ff53094e7def67b17b714e7884fe030856473a0185b0d8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "04c2ecfd9e9ee99af9ff53094e7def67b17b714e7884fe030856473a0185b0d8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a CuveeCollectiveCollector NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: CuveeCollectiveCollector\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509275
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808553
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "c6a1914094db3e389250c93eb04e3fbef51b165eb77c8a62c4705d939dd53bb7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c6a1914094db3e389250c93eb04e3fbef51b165eb77c8a62c4705d939dd53bb7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a CuveeCollectiveCollector NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Collector from 0xCollector\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: CuveeCollectiveCollector\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Collector.Collection>(from: /storage/CollectorCollection) == nil {\n            let collection <- Collector.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CollectorCollection)\n        }\n        if (acct.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection).borrow() == nil) {\n            acct.unlink(/public/CollectorCollection)\n            acct.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection, target: /storage/CollectorCollection)\n        }\n\n        if (acct.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CollectorCollection).borrow() == nil) {\n            acct.unlink(/private/CollectorCollection)\n            acct.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CollectorCollection, target: /storage/CollectorCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/CollectorCollection)!\n        let collectionRef = acct\n            .getCapability(/public/CollectorCollection)\n            .borrow<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Collector.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCollector": {
          "Collector": {
            "mainnet": {
              "address": "0x7c8995e83c4b1843",
              "contract": "Collector",
              "fq_address": "A.0x7c8995e83c4b1843.Collector",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509201
            },
            "testnet": {
              "address": "0x3a1ebf12b8e3da71",
              "contract": "Collector",
              "fq_address": "A.0x3a1ebf12b8e3da71.Collector",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95808466
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509210
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808472
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509217
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808482
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509222
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95808484
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509223
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808485
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509227
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808494
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "56a394e9f8f1657a408e762aab4315e32205b3b7b9adeb9f629f15cc2e1454fa": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "56a394e9f8f1657a408e762aab4315e32205b3b7b9adeb9f629f15cc2e1454fa",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed CuveeCollectiveCollector NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Collector from 0xCollector\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: CuveeCollectiveCollector\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Collector.Collection>(from: /storage/CollectorCollection) == nil {\n            let collection <- Collector.createEmptyCollection()\n            acct.save(<-collection, to: /storage/CollectorCollection)\n            }\n        if (acct.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection).borrow() == nil) {\n            acct.unlink(/public/CollectorCollection)\n            acct.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection, target: /storage/CollectorCollection)\n        }\n\n        if (acct.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CollectorCollection).borrow() == nil) {\n            acct.unlink(/private/CollectorCollection)\n            acct.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/CollectorCollection, target: /storage/CollectorCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/CollectorCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCollector": {
          "Collector": {
            "mainnet": {
              "address": "0x7c8995e83c4b1843",
              "contract": "Collector",
              "fq_address": "A.0x7c8995e83c4b1843.Collector",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509240
            },
            "testnet": {
              "address": "0x3a1ebf12b8e3da71",
              "contract": "Collector",
              "fq_address": "A.0x3a1ebf12b8e3da71.Collector",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95808513
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509250
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808521
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509257
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808530
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47509261
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95808532
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509263
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808533
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509267
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808543
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "073b2cc13a713061ed58772a7809d06fb3e36feb8bd632b1245c6e3919eee742": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "073b2cc13a713061ed58772a7809d06fb3e36feb8bd632b1245c6e3919eee742",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support CuveeCollectiveCollector NFTs"
          }
        }
      },
      "cadence": "import Collector from 0xCollector\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: CuveeCollectiveCollector\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Collector.Collection>(from: /storage/CollectorCollection) == nil {\n      let collection <- Collector.createEmptyCollection()\n      signer.save(<-collection, to: /storage/CollectorCollection)\n    }\n    if (signer.getCapability<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection).borrow() == nil) {\n      signer.unlink(/public/CollectorCollection)\n      signer.link<&Collector.Collection{Collector.NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/CollectorCollection, target: /storage/CollectorCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCollector": {
          "Collector": {
            "mainnet": {
              "address": "0x7c8995e83c4b1843",
              "contract": "Collector",
              "fq_address": "A.0x7c8995e83c4b1843.Collector",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47509173
            },
            "testnet": {
              "address": "0x3a1ebf12b8e3da71",
              "contract": "Collector",
              "fq_address": "A.0x3a1ebf12b8e3da71.Collector",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95808430
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47509183
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95808437
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47509190
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95808446
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "8d3479b66201434e7bf498be899ad95633278ea0da58f8a325c1317f15fd748e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "8d3479b66201434e7bf498be899ad95633278ea0da58f8a325c1317f15fd748e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Cimelio NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Cimelio\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497482
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "3448218c5322ea2fba246814f0c27c6ed4dc086db482eceb7fd973fb06e01baf": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3448218c5322ea2fba246814f0c27c6ed4dc086db482eceb7fd973fb06e01baf",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Cimelio NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Cimelio_NFT from 0xCimelio_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Cimelio\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Cimelio_NFT.Collection>(from: /storage/Cimelio_NFTCollection) == nil {\n            let collection <- Cimelio_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/Cimelio_NFTCollection)\n        }\n        if (acct.getCapability<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Cimelio_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/Cimelio_NFTCollection)\n            acct.link<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Cimelio_NFTCollection, target: /storage/Cimelio_NFTCollection)\n        }\n\n        if (acct.getCapability<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Cimelio_NFT).borrow() == nil) {\n            acct.unlink(/private/Cimelio_NFT)\n            acct.link<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Cimelio_NFT, target: /storage/Cimelio_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/Cimelio_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/Cimelio_NFTCollection)\n            .borrow<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Cimelio_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCimelio_NFT": {
          "Cimelio_NFT": {
            "mainnet": {
              "address": "0x2c9de937c319468d",
              "contract": "Cimelio_NFT",
              "fq_address": "A.0x2c9de937c319468d.Cimelio_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497441
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497444
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497449
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497449
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497449
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497455
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "32d9cf401e7ad2dd9214a5108b3024f67ba0473f93e14459b4cad6a08462ce3c": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "32d9cf401e7ad2dd9214a5108b3024f67ba0473f93e14459b4cad6a08462ce3c",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Cimelio NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Cimelio_NFT from 0xCimelio_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Cimelio\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Cimelio_NFT.Collection>(from: /storage/Cimelio_NFTCollection) == nil {\n            let collection <- Cimelio_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/Cimelio_NFTCollection)\n            }\n        if (acct.getCapability<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Cimelio_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/Cimelio_NFTCollection)\n            acct.link<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Cimelio_NFTCollection, target: /storage/Cimelio_NFTCollection)\n        }\n\n        if (acct.getCapability<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Cimelio_NFT).borrow() == nil) {\n            acct.unlink(/private/Cimelio_NFT)\n            acct.link<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Cimelio_NFT, target: /storage/Cimelio_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/Cimelio_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCimelio_NFT": {
          "Cimelio_NFT": {
            "mainnet": {
              "address": "0x2c9de937c319468d",
              "contract": "Cimelio_NFT",
              "fq_address": "A.0x2c9de937c319468d.Cimelio_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497463
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497466
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497470
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497471
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497473
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497476
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "b829d77b90843164920c22c6c10a7bf73398ef2e6974b71a4071dc6e21867e9b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b829d77b90843164920c22c6c10a7bf73398ef2e6974b71a4071dc6e21867e9b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Cimelio NFTs"
          }
        }
      },
      "cadence": "import Cimelio_NFT from 0xCimelio_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Cimelio\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Cimelio_NFT.Collection>(from: /storage/Cimelio_NFTCollection) == nil {\n      let collection <- Cimelio_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/Cimelio_NFTCollection)\n    }\n    if (signer.getCapability<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Cimelio_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/Cimelio_NFTCollection)\n      signer.link<&Cimelio_NFT.Collection{Cimelio_NFT.Cimelio_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Cimelio_NFTCollection, target: /storage/Cimelio_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCimelio_NFT": {
          "Cimelio_NFT": {
            "mainnet": {
              "address": "0x2c9de937c319468d",
              "contract": "Cimelio_NFT",
              "fq_address": "A.0x2c9de937c319468d.Cimelio_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497426
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497428
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497432
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "af3723205ca9a7faa8b2c805f619c9c4d6f7af3dbfce29bc2f35e19fe5cd30b7": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "af3723205ca9a7faa8b2c805f619c9c4d6f7af3dbfce29bc2f35e19fe5cd30b7",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a ChainmonstersRewards NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: ChainmonstersRewards\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497600
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794653
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "5644d68c138ef683710bc7074f396d95c6d6484a6da8de77b803ec6cc1abbabd": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5644d68c138ef683710bc7074f396d95c6d6484a6da8de77b803ec6cc1abbabd",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a ChainmonstersRewards NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import ChainmonstersRewards from 0xChainmonstersRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: ChainmonstersRewards\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ChainmonstersRewards.Collection>(from: /storage/ChainmonstersRewardCollection) == nil {\n            let collection <- ChainmonstersRewards.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ChainmonstersRewardCollection)\n        }\n        if (acct.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection).borrow() == nil) {\n            acct.unlink(/public/ChainmonstersRewardCollection)\n            acct.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection, target: /storage/ChainmonstersRewardCollection)\n        }\n\n        if (acct.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ChainmonstersRewardsCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/ChainmonstersRewardsCollectionProvider)\n            acct.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ChainmonstersRewardsCollectionProvider, target: /storage/ChainmonstersRewardCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/ChainmonstersRewardsCollectionProvider)!\n        let collectionRef = acct\n            .getCapability(/public/ChainmonstersRewardCollection)\n            .borrow<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@ChainmonstersRewards.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xChainmonstersRewards": {
          "ChainmonstersRewards": {
            "mainnet": {
              "address": "0x93615d25d14fa337",
              "contract": "ChainmonstersRewards",
              "fq_address": "A.0x93615d25d14fa337.ChainmonstersRewards",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497517
            },
            "testnet": {
              "address": "0x75783e3c937304a8",
              "contract": "ChainmonstersRewards",
              "fq_address": "A.0x75783e3c937304a8.ChainmonstersRewards",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95794564
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497530
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794571
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497538
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794581
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497543
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95794583
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497544
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794584
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497547
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794594
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "ae3ef7e28d0044969af4c06bfc4c64e997dee8a52ee23823aaebc175128afce6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ae3ef7e28d0044969af4c06bfc4c64e997dee8a52ee23823aaebc175128afce6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed ChainmonstersRewards NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import ChainmonstersRewards from 0xChainmonstersRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: ChainmonstersRewards\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&ChainmonstersRewards.Collection>(from: /storage/ChainmonstersRewardCollection) == nil {\n            let collection <- ChainmonstersRewards.createEmptyCollection()\n            acct.save(<-collection, to: /storage/ChainmonstersRewardCollection)\n            }\n        if (acct.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection).borrow() == nil) {\n            acct.unlink(/public/ChainmonstersRewardCollection)\n            acct.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection, target: /storage/ChainmonstersRewardCollection)\n        }\n\n        if (acct.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ChainmonstersRewardsCollectionProvider).borrow() == nil) {\n            acct.unlink(/private/ChainmonstersRewardsCollectionProvider)\n            acct.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/ChainmonstersRewardsCollectionProvider, target: /storage/ChainmonstersRewardCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/ChainmonstersRewardCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xChainmonstersRewards": {
          "ChainmonstersRewards": {
            "mainnet": {
              "address": "0x93615d25d14fa337",
              "contract": "ChainmonstersRewards",
              "fq_address": "A.0x93615d25d14fa337.ChainmonstersRewards",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497562
            },
            "testnet": {
              "address": "0x75783e3c937304a8",
              "contract": "ChainmonstersRewards",
              "fq_address": "A.0x75783e3c937304a8.ChainmonstersRewards",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95794613
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497573
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794620
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497581
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794630
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47497585
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95794632
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497587
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794633
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497591
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794643
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "55fc46f67fcf45a516233aa351eea0af196279d142ce114e7912a73b7ac27694": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "55fc46f67fcf45a516233aa351eea0af196279d142ce114e7912a73b7ac27694",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support ChainmonstersRewards NFTs"
          }
        }
      },
      "cadence": "import ChainmonstersRewards from 0xChainmonstersRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: ChainmonstersRewards\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&ChainmonstersRewards.Collection>(from: /storage/ChainmonstersRewardCollection) == nil {\n      let collection <- ChainmonstersRewards.createEmptyCollection()\n      signer.save(<-collection, to: /storage/ChainmonstersRewardCollection)\n    }\n    if (signer.getCapability<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection).borrow() == nil) {\n      signer.unlink(/public/ChainmonstersRewardCollection)\n      signer.link<&ChainmonstersRewards.Collection{ChainmonstersRewards.ChainmonstersRewardCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/ChainmonstersRewardCollection, target: /storage/ChainmonstersRewardCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xChainmonstersRewards": {
          "ChainmonstersRewards": {
            "mainnet": {
              "address": "0x93615d25d14fa337",
              "contract": "ChainmonstersRewards",
              "fq_address": "A.0x93615d25d14fa337.ChainmonstersRewards",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47497490
            },
            "testnet": {
              "address": "0x75783e3c937304a8",
              "contract": "ChainmonstersRewards",
              "fq_address": "A.0x75783e3c937304a8.ChainmonstersRewards",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 95794527
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47497500
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95794534
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497507
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95794543
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "f66f501c51f0911b83b49a434955a7319c95b547bc17f8d7d13a264f5f457b3e": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f66f501c51f0911b83b49a434955a7319c95b547bc17f8d7d13a264f5f457b3e",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a CanesVault NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: CanesVault\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496436
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "b8c2f33c53f7464a7bf8f3a7e45c3ea73217c738469820c99d3afd52fb9de228": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b8c2f33c53f7464a7bf8f3a7e45c3ea73217c738469820c99d3afd52fb9de228",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a CanesVault NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Canes_Vault_NFT from 0xCanes_Vault_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: CanesVault\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Canes_Vault_NFT.Collection>(from: /storage/Canes_Vault_NFTCollection) == nil {\n            let collection <- Canes_Vault_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/Canes_Vault_NFTCollection)\n        }\n        if (acct.getCapability<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Canes_Vault_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/Canes_Vault_NFTCollection)\n            acct.link<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Canes_Vault_NFTCollection, target: /storage/Canes_Vault_NFTCollection)\n        }\n\n        if (acct.getCapability<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Canes_Vault_NFT).borrow() == nil) {\n            acct.unlink(/private/Canes_Vault_NFT)\n            acct.link<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Canes_Vault_NFT, target: /storage/Canes_Vault_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/Canes_Vault_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/Canes_Vault_NFTCollection)\n            .borrow<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Canes_Vault_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xCanes_Vault_NFT": {
          "Canes_Vault_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "Canes_Vault_NFT",
              "fq_address": "A.0x329feb3ab062d289.Canes_Vault_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47496392
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496399
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496402
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47496404
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496405
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496409
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "e693c23d1ec09e05029eaa73ee78dc42fc98dc5e0b30343ca1bb33aa53474590": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e693c23d1ec09e05029eaa73ee78dc42fc98dc5e0b30343ca1bb33aa53474590",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed CanesVault NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Canes_Vault_NFT from 0xCanes_Vault_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: CanesVault\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Canes_Vault_NFT.Collection>(from: /storage/Canes_Vault_NFTCollection) == nil {\n            let collection <- Canes_Vault_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/Canes_Vault_NFTCollection)\n            }\n        if (acct.getCapability<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Canes_Vault_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/Canes_Vault_NFTCollection)\n            acct.link<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Canes_Vault_NFTCollection, target: /storage/Canes_Vault_NFTCollection)\n        }\n\n        if (acct.getCapability<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Canes_Vault_NFT).borrow() == nil) {\n            acct.unlink(/private/Canes_Vault_NFT)\n            acct.link<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Canes_Vault_NFT, target: /storage/Canes_Vault_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/Canes_Vault_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xCanes_Vault_NFT": {
          "Canes_Vault_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "Canes_Vault_NFT",
              "fq_address": "A.0x329feb3ab062d289.Canes_Vault_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47496419
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496421
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496426
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47496427
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496429
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496431
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "f3adc7ecaa76a0f51918dbee2c87a0f49183351e703b44456c4a514059e15ac3": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f3adc7ecaa76a0f51918dbee2c87a0f49183351e703b44456c4a514059e15ac3",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support CanesVault NFTs"
          }
        }
      },
      "cadence": "import Canes_Vault_NFT from 0xCanes_Vault_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: CanesVault\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Canes_Vault_NFT.Collection>(from: /storage/Canes_Vault_NFTCollection) == nil {\n      let collection <- Canes_Vault_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/Canes_Vault_NFTCollection)\n    }\n    if (signer.getCapability<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Canes_Vault_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/Canes_Vault_NFTCollection)\n      signer.link<&Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Canes_Vault_NFTCollection, target: /storage/Canes_Vault_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xCanes_Vault_NFT": {
          "Canes_Vault_NFT": {
            "mainnet": {
              "address": "0x329feb3ab062d289",
              "contract": "Canes_Vault_NFT",
              "fq_address": "A.0x329feb3ab062d289.Canes_Vault_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47496371
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47496376
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47496379
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "1eafac06cff7619b8eb4c680475a7607fe91acad24fd8ea35cb9db2573a570ad": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "1eafac06cff7619b8eb4c680475a7607fe91acad24fd8ea35cb9db2573a570ad",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Bobblz NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Bobblz\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492659
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "e8ff15654123426dcde953220392bb00b3af10e00c5b8707fd170470bd27a0b0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e8ff15654123426dcde953220392bb00b3af10e00c5b8707fd170470bd27a0b0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Bobblz NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Bobblz_NFT from 0xBobblz_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Bobblz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Bobblz_NFT.Collection>(from: /storage/Bobblz_NFTCollection) == nil {\n            let collection <- Bobblz_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/Bobblz_NFTCollection)\n        }\n        if (acct.getCapability<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Bobblz_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/Bobblz_NFTCollection)\n            acct.link<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Bobblz_NFTCollection, target: /storage/Bobblz_NFTCollection)\n        }\n\n        if (acct.getCapability<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Bobblz_NFT).borrow() == nil) {\n            acct.unlink(/private/Bobblz_NFT)\n            acct.link<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Bobblz_NFT, target: /storage/Bobblz_NFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/Bobblz_NFT)!\n        let collectionRef = acct\n            .getCapability(/public/Bobblz_NFTCollection)\n            .borrow<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Bobblz_NFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xBobblz_NFT": {
          "Bobblz_NFT": {
            "mainnet": {
              "address": "0xd45e2bd9a3d5003b",
              "contract": "Bobblz_NFT",
              "fq_address": "A.0xd45e2bd9a3d5003b.Bobblz_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492619
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492623
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492628
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492629
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492629
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492634
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "68f3b62ec254f6f2d65c03d4348946b14b45f9f865f71e8fff9d906f7a30f0ef": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "68f3b62ec254f6f2d65c03d4348946b14b45f9f865f71e8fff9d906f7a30f0ef",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Bobblz NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Bobblz_NFT from 0xBobblz_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Bobblz\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Bobblz_NFT.Collection>(from: /storage/Bobblz_NFTCollection) == nil {\n            let collection <- Bobblz_NFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/Bobblz_NFTCollection)\n            }\n        if (acct.getCapability<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Bobblz_NFTCollection).borrow() == nil) {\n            acct.unlink(/public/Bobblz_NFTCollection)\n            acct.link<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Bobblz_NFTCollection, target: /storage/Bobblz_NFTCollection)\n        }\n\n        if (acct.getCapability<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Bobblz_NFT).borrow() == nil) {\n            acct.unlink(/private/Bobblz_NFT)\n            acct.link<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/Bobblz_NFT, target: /storage/Bobblz_NFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/Bobblz_NFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xBobblz_NFT": {
          "Bobblz_NFT": {
            "mainnet": {
              "address": "0xd45e2bd9a3d5003b",
              "contract": "Bobblz_NFT",
              "fq_address": "A.0xd45e2bd9a3d5003b.Bobblz_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492642
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492646
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492649
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47492649
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492651
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492654
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "6ac20472f09d2882ef4873fb5e5ed47d2835072c47463cccf46f7e8709934df1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6ac20472f09d2882ef4873fb5e5ed47d2835072c47463cccf46f7e8709934df1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Bobblz NFTs"
          }
        }
      },
      "cadence": "import Bobblz_NFT from 0xBobblz_NFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Bobblz\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Bobblz_NFT.Collection>(from: /storage/Bobblz_NFTCollection) == nil {\n      let collection <- Bobblz_NFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/Bobblz_NFTCollection)\n    }\n    if (signer.getCapability<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Bobblz_NFTCollection).borrow() == nil) {\n      signer.unlink(/public/Bobblz_NFTCollection)\n      signer.link<&Bobblz_NFT.Collection{Bobblz_NFT.Bobblz_NFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/Bobblz_NFTCollection, target: /storage/Bobblz_NFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xBobblz_NFT": {
          "Bobblz_NFT": {
            "mainnet": {
              "address": "0xd45e2bd9a3d5003b",
              "contract": "Bobblz_NFT",
              "fq_address": "A.0xd45e2bd9a3d5003b.Bobblz_NFT",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47492480
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47492482
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47492487
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "b370e92170b96727fe12dba5624897072c25aebbc28f8038f65f1396372e71c0": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b370e92170b96727fe12dba5624897072c25aebbc28f8038f65f1396372e71c0",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a BlovizeNFTTrophies NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: BlovizeNFTTrophies\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506187
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804877
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "3559ce85a02d837f51c5ecfb7541b47514513e7295d684a978877a6df92df318": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3559ce85a02d837f51c5ecfb7541b47514513e7295d684a978877a6df92df318",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a BlovizeNFTTrophies NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import BlovizeNFT from 0xBlovizeNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: BlovizeNFTTrophies\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BlovizeNFT.Collection>(from: /storage/blovizeNFTCollection) == nil {\n            let collection <- BlovizeNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/blovizeNFTCollection)\n        }\n        if (acct.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection).borrow() == nil) {\n            acct.unlink(/public/blovizeNFTCollection)\n            acct.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n        }\n\n        if (acct.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/blovizeNFTCollection).borrow() == nil) {\n            acct.unlink(/private/blovizeNFTCollection)\n            acct.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/blovizeNFTCollection)!\n        let collectionRef = acct\n            .getCapability(/public/blovizeNFTCollection)\n            .borrow<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@BlovizeNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xBlovizeNFT": {
          "BlovizeNFT": {
            "mainnet": {
              "address": "0xee4567ab7f63abf2",
              "contract": "BlovizeNFT",
              "fq_address": "A.0xee4567ab7f63abf2.BlovizeNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506108
            },
            "testnet": {
              "address": "0xc8f7112fa2f1af97",
              "contract": "BlovizeNFT",
              "fq_address": "A.0xc8f7112fa2f1af97.BlovizeNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804790
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506120
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804797
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506126
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804807
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506131
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804809
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506132
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804810
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506137
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804819
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "9fb6a12224795e886059b8f581e14fca14ab773618f75d6afea419533355621f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "9fb6a12224795e886059b8f581e14fca14ab773618f75d6afea419533355621f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed BlovizeNFTTrophies NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import BlovizeNFT from 0xBlovizeNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: BlovizeNFTTrophies\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BlovizeNFT.Collection>(from: /storage/blovizeNFTCollection) == nil {\n            let collection <- BlovizeNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/blovizeNFTCollection)\n            }\n        if (acct.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection).borrow() == nil) {\n            acct.unlink(/public/blovizeNFTCollection)\n            acct.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n        }\n\n        if (acct.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/blovizeNFTCollection).borrow() == nil) {\n            acct.unlink(/private/blovizeNFTCollection)\n            acct.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/blovizeNFTCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xBlovizeNFT": {
          "BlovizeNFT": {
            "mainnet": {
              "address": "0xee4567ab7f63abf2",
              "contract": "BlovizeNFT",
              "fq_address": "A.0xee4567ab7f63abf2.BlovizeNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506149
            },
            "testnet": {
              "address": "0xc8f7112fa2f1af97",
              "contract": "BlovizeNFT",
              "fq_address": "A.0xc8f7112fa2f1af97.BlovizeNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804838
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506160
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804845
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506167
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804854
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47506174
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95804857
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506175
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804858
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506179
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804867
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "65f83db335d61ac60ac306d5db70624b05ab5ccabc526bad14f8cb1f80d9b0ed": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "65f83db335d61ac60ac306d5db70624b05ab5ccabc526bad14f8cb1f80d9b0ed",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support BlovizeNFTTrophies NFTs"
          }
        }
      },
      "cadence": "import BlovizeNFT from 0xBlovizeNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: BlovizeNFTTrophies\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&BlovizeNFT.Collection>(from: /storage/blovizeNFTCollection) == nil {\n      let collection <- BlovizeNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/blovizeNFTCollection)\n    }\n    if (signer.getCapability<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection).borrow() == nil) {\n      signer.unlink(/public/blovizeNFTCollection)\n      signer.link<&BlovizeNFT.Collection{BlovizeNFT.BlovizeNFTCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/blovizeNFTCollection, target: /storage/blovizeNFTCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xBlovizeNFT": {
          "BlovizeNFT": {
            "mainnet": {
              "address": "0xee4567ab7f63abf2",
              "contract": "BlovizeNFT",
              "fq_address": "A.0xee4567ab7f63abf2.BlovizeNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 47506077
            },
            "testnet": {
              "address": "0xc8f7112fa2f1af97",
              "contract": "BlovizeNFT",
              "fq_address": "A.0xc8f7112fa2f1af97.BlovizeNFT",
              "pin": "7723617b4999f66ce1942ee3847d899b74dca4b43ff6f7ce75f32c7d8b5b43a6",
              "pin_block_height": 95804756
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47506089
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95804763
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47506096
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95804772
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "5350882f7837151e8eccac685a6a20b10ede049aa985d666818685edd6880205": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5350882f7837151e8eccac685a6a20b10ede049aa985d666818685edd6880205",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Bitku NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Bitku\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499489
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796911
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "54df1394a1886a7eedfd8b74e277a0d38fad4849efc06c71677819b61581375a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "54df1394a1886a7eedfd8b74e277a0d38fad4849efc06c71677819b61581375a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Bitku NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import HaikuNFT from 0xHaikuNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Bitku\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&HaikuNFT.Collection>(from: /storage/BitkuCollection) == nil {\n            let collection <- HaikuNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BitkuCollection)\n        }\n        if (acct.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection).borrow() == nil) {\n            acct.unlink(/public/BitkuCollection)\n            acct.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection, target: /storage/BitkuCollection)\n        }\n\n        if (acct.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BitkuCollection).borrow() == nil) {\n            acct.unlink(/private/BitkuCollection)\n            acct.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BitkuCollection, target: /storage/BitkuCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/BitkuCollection)!\n        let collectionRef = acct\n            .getCapability(/public/BitkuCollection)\n            .borrow<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@HaikuNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xHaikuNFT": {
          "HaikuNFT": {
            "mainnet": {
              "address": "0xf61e40c19db2a9e2",
              "contract": "HaikuNFT",
              "fq_address": "A.0xf61e40c19db2a9e2.HaikuNFT",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47499396
            },
            "testnet": {
              "address": "0x824f612f78d34250",
              "contract": "HaikuNFT",
              "fq_address": "A.0x824f612f78d34250.HaikuNFT",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 95796807
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499412
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796814
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499419
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796823
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499423
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95796826
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499425
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796827
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499429
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796836
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "012bf7b368d6c95ba31a9c32a3df50f8dc30bd79a1bdafc759c1fe702cc526f6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "012bf7b368d6c95ba31a9c32a3df50f8dc30bd79a1bdafc759c1fe702cc526f6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Bitku NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import HaikuNFT from 0xHaikuNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Bitku\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&HaikuNFT.Collection>(from: /storage/BitkuCollection) == nil {\n            let collection <- HaikuNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BitkuCollection)\n            }\n        if (acct.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection).borrow() == nil) {\n            acct.unlink(/public/BitkuCollection)\n            acct.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection, target: /storage/BitkuCollection)\n        }\n\n        if (acct.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BitkuCollection).borrow() == nil) {\n            acct.unlink(/private/BitkuCollection)\n            acct.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BitkuCollection, target: /storage/BitkuCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BitkuCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xHaikuNFT": {
          "HaikuNFT": {
            "mainnet": {
              "address": "0xf61e40c19db2a9e2",
              "contract": "HaikuNFT",
              "fq_address": "A.0xf61e40c19db2a9e2.HaikuNFT",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47499447
            },
            "testnet": {
              "address": "0x824f612f78d34250",
              "contract": "HaikuNFT",
              "fq_address": "A.0x824f612f78d34250.HaikuNFT",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 95796870
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499462
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796877
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499471
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796887
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499474
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95796889
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499475
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796890
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499480
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796899
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "d6c7a65f29f29a6df6a78c528e32d03e53036d916c3bb43502d31de7f77e1d50": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "d6c7a65f29f29a6df6a78c528e32d03e53036d916c3bb43502d31de7f77e1d50",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Bitku NFTs"
          }
        }
      },
      "cadence": "import HaikuNFT from 0xHaikuNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Bitku\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&HaikuNFT.Collection>(from: /storage/BitkuCollection) == nil {\n      let collection <- HaikuNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BitkuCollection)\n    }\n    if (signer.getCapability<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection).borrow() == nil) {\n      signer.unlink(/public/BitkuCollection)\n      signer.link<&HaikuNFT.Collection{HaikuNFT.HaikuCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BitkuCollection, target: /storage/BitkuCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xHaikuNFT": {
          "HaikuNFT": {
            "mainnet": {
              "address": "0xf61e40c19db2a9e2",
              "contract": "HaikuNFT",
              "fq_address": "A.0xf61e40c19db2a9e2.HaikuNFT",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 47499355
            },
            "testnet": {
              "address": "0x824f612f78d34250",
              "contract": "HaikuNFT",
              "fq_address": "A.0x824f612f78d34250.HaikuNFT",
              "pin": "455a9a9d9530fe73aeba8c3f857fce0ad33438592943e4b391a6b92418cce5e8",
              "pin_block_height": 95796756
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499371
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95796763
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499378
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95796773
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "320a24b777965f87a773c6547729b1b35945c4d4115bc726dae691a00967abdd": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "320a24b777965f87a773c6547729b1b35945c4d4115bc726dae691a00967abdd",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a BarterYardClub_Werewolves NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: BarterYardClub_Werewolves\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512793
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "6a1c3309aeac3dbd3ffd79ce8bc842ba208554d008fa0841c0672154e6b5a922": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "6a1c3309aeac3dbd3ffd79ce8bc842ba208554d008fa0841c0672154e6b5a922",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a BarterYardClub_Werewolves NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: BarterYardClub_Werewolves\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n            let collection <- BarterYardClubWerewolf.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n        }\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n            acct.unlink(/public/BarterYardClubWerewolfCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/BarterYardClubWerewolfCollection).borrow() == nil) {\n            acct.unlink(/private/BarterYardClubWerewolfCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/BarterYardClubWerewolfCollection)!\n        let collectionRef = acct\n            .getCapability(/public/BarterYardClubWerewolfCollection)\n            .borrow<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@BarterYardClubWerewolf.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xBarterYardClubWerewolf": {
          "BarterYardClubWerewolf": {
            "mainnet": {
              "address": "0x28abb9f291cadaf2",
              "contract": "BarterYardClubWerewolf",
              "fq_address": "A.0x28abb9f291cadaf2.BarterYardClubWerewolf",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47512752
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512755
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512760
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512760
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512762
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512766
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "7af42fc34bb4c0ef5bfa22d3a46a389fdc9baa5d66cf46bf602a063b4299d7e8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "7af42fc34bb4c0ef5bfa22d3a46a389fdc9baa5d66cf46bf602a063b4299d7e8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed BarterYardClub_Werewolves NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: BarterYardClub_Werewolves\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n            let collection <- BarterYardClubWerewolf.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n            }\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n            acct.unlink(/public/BarterYardClubWerewolfCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/BarterYardClubWerewolfCollection).borrow() == nil) {\n            acct.unlink(/private/BarterYardClubWerewolfCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BarterYardClubWerewolfCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xBarterYardClubWerewolf": {
          "BarterYardClubWerewolf": {
            "mainnet": {
              "address": "0x28abb9f291cadaf2",
              "contract": "BarterYardClubWerewolf",
              "fq_address": "A.0x28abb9f291cadaf2.BarterYardClubWerewolf",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47512775
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512778
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512782
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512783
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512785
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512789
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "c4cee8e96e0f0eea4e28fff80614396ec91db5323e99dd13c130191982e8a8ca": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "c4cee8e96e0f0eea4e28fff80614396ec91db5323e99dd13c130191982e8a8ca",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support BarterYardClub_Werewolves NFTs"
          }
        }
      },
      "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: BarterYardClub_Werewolves\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n      let collection <- BarterYardClubWerewolf.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n    }\n    if (signer.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n      signer.unlink(/public/BarterYardClubWerewolfCollection)\n      signer.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xBarterYardClubWerewolf": {
          "BarterYardClubWerewolf": {
            "mainnet": {
              "address": "0x28abb9f291cadaf2",
              "contract": "BarterYardClubWerewolf",
              "fq_address": "A.0x28abb9f291cadaf2.BarterYardClubWerewolf",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 47512733
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512736
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512740
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "28c95b0b3e021daf2e72d429ce75c5247757ba7bbe1d3c1cf7d5b5dd961ac047": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "28c95b0b3e021daf2e72d429ce75c5247757ba7bbe1d3c1cf7d5b5dd961ac047",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a BarterYardClubWerewolves NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: BarterYardClubWerewolves\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813470
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "e8849742ecde3bbc0cd1c78bfb53d8c028dbbe60862f4ae91283ef60d8970092": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e8849742ecde3bbc0cd1c78bfb53d8c028dbbe60862f4ae91283ef60d8970092",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a BarterYardClubWerewolves NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: BarterYardClubWerewolves\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n            let collection <- BarterYardClubWerewolf.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n        }\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n            acct.unlink(/public/BarterYardClubWerewolfCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlovatarCollection).borrow() == nil) {\n            acct.unlink(/private/FlovatarCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlovatarCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/FlovatarCollection)!\n        let collectionRef = acct\n            .getCapability(/public/BarterYardClubWerewolfCollection)\n            .borrow<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@BarterYardClubWerewolf.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xBarterYardClubWerewolf": {
          "BarterYardClubWerewolf": {
            "testnet": {
              "address": "0x195caada038c5806",
              "contract": "BarterYardClubWerewolf",
              "fq_address": "A.0x195caada038c5806.BarterYardClubWerewolf",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95813424
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813427
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813432
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813433
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813434
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813439
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "a1c79169622fcdd99dd150c5a6710e41f404ad27009ff8653c0d6b52ede80c2f": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a1c79169622fcdd99dd150c5a6710e41f404ad27009ff8653c0d6b52ede80c2f",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed BarterYardClubWerewolves NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: BarterYardClubWerewolves\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n            let collection <- BarterYardClubWerewolf.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n            }\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n            acct.unlink(/public/BarterYardClubWerewolfCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n\n        if (acct.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlovatarCollection).borrow() == nil) {\n            acct.unlink(/private/FlovatarCollection)\n            acct.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/FlovatarCollection, target: /storage/BarterYardClubWerewolfCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BarterYardClubWerewolfCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xBarterYardClubWerewolf": {
          "BarterYardClubWerewolf": {
            "testnet": {
              "address": "0x195caada038c5806",
              "contract": "BarterYardClubWerewolf",
              "fq_address": "A.0x195caada038c5806.BarterYardClubWerewolf",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95813451
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813454
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813459
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95813460
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813460
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813464
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "2a8685ede4493ac45b1958bb99e82ff4173d853e6c205531791e1e9105b323c8": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "2a8685ede4493ac45b1958bb99e82ff4173d853e6c205531791e1e9105b323c8",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support BarterYardClubWerewolves NFTs"
          }
        }
      },
      "cadence": "import BarterYardClubWerewolf from 0xBarterYardClubWerewolf\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: BarterYardClubWerewolves\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&BarterYardClubWerewolf.Collection>(from: /storage/BarterYardClubWerewolfCollection) == nil {\n      let collection <- BarterYardClubWerewolf.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BarterYardClubWerewolfCollection)\n    }\n    if (signer.getCapability<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection).borrow() == nil) {\n      signer.unlink(/public/BarterYardClubWerewolfCollection)\n      signer.link<&BarterYardClubWerewolf.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BarterYardClubWerewolfCollection, target: /storage/BarterYardClubWerewolfCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xBarterYardClubWerewolf": {
          "BarterYardClubWerewolf": {
            "testnet": {
              "address": "0x195caada038c5806",
              "contract": "BarterYardClubWerewolf",
              "fq_address": "A.0x195caada038c5806.BarterYardClubWerewolf",
              "pin": "751fcffa1f40d4edff5f6cff49d14e6b67bbd33cad3d2dd61fdc04ce97db4a4a",
              "pin_block_height": 95813404
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95813408
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95813413
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "fa5fcf93b7c2bbdb79abac173078110250bc5f9e0d668ffe57577a113a9e4564": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "fa5fcf93b7c2bbdb79abac173078110250bc5f9e0d668ffe57577a113a9e4564",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Backpack NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Backpack\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501733
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799574
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ba01bc3178d7f4328cb8552dea38bfbe1033954b55eed1910f54cd45d0f36603": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ba01bc3178d7f4328cb8552dea38bfbe1033954b55eed1910f54cd45d0f36603",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Backpack NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Backpack from 0xBackpack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Backpack\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Backpack.Collection>(from: /storage/BackpackCollection) == nil {\n            let collection <- Backpack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BackpackCollection)\n        }\n        if (acct.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection).borrow() == nil) {\n            acct.unlink(/public/BackpackCollection)\n            acct.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection, target: /storage/BackpackCollection)\n        }\n\n        if (acct.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BackpackPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/BackpackPrivateProvider)\n            acct.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BackpackPrivateProvider, target: /storage/BackpackCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/BackpackPrivateProvider)!\n        let collectionRef = acct\n            .getCapability(/public/BackpackCollection)\n            .borrow<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Backpack.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xBackpack": {
          "Backpack": {
            "mainnet": {
              "address": "0x807c3d470888cc48",
              "contract": "Backpack",
              "fq_address": "A.0x807c3d470888cc48.Backpack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47501629
            },
            "testnet": {
              "address": "0xe666c53e1758dec6",
              "contract": "Backpack",
              "fq_address": "A.0xe666c53e1758dec6.Backpack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95799469
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501646
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799476
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501654
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799486
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501658
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95799488
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501661
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799489
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501665
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799498
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "ade4d51f6371708cae541849bdb2f08fdda8d37721e6bc70758969d5ec5b4040": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ade4d51f6371708cae541849bdb2f08fdda8d37721e6bc70758969d5ec5b4040",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Backpack NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Backpack from 0xBackpack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Backpack\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Backpack.Collection>(from: /storage/BackpackCollection) == nil {\n            let collection <- Backpack.createEmptyCollection()\n            acct.save(<-collection, to: /storage/BackpackCollection)\n            }\n        if (acct.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection).borrow() == nil) {\n            acct.unlink(/public/BackpackCollection)\n            acct.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection, target: /storage/BackpackCollection)\n        }\n\n        if (acct.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BackpackPrivateProvider).borrow() == nil) {\n            acct.unlink(/private/BackpackPrivateProvider)\n            acct.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/BackpackPrivateProvider, target: /storage/BackpackCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/BackpackCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xBackpack": {
          "Backpack": {
            "mainnet": {
              "address": "0x807c3d470888cc48",
              "contract": "Backpack",
              "fq_address": "A.0x807c3d470888cc48.Backpack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47501687
            },
            "testnet": {
              "address": "0xe666c53e1758dec6",
              "contract": "Backpack",
              "fq_address": "A.0xe666c53e1758dec6.Backpack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95799535
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501703
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799542
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501712
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799552
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47501716
            },
            "testnet": {
              "address": "0x7e60df042a9c0868",
              "contract": "FlowToken",
              "fq_address": "A.0x7e60df042a9c0868.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 95799554
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501719
            },
            "testnet": {
              "address": "0x9a0766d93b6608b7",
              "contract": "FungibleToken",
              "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799555
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501723
            },
            "testnet": {
              "address": "0x2d55b98eb200daef",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x2d55b98eb200daef.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799565
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "062e2cc6c0127b55222ec1cd496f1a97ca1056c04907e3d3889a95ddbe558e97": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "062e2cc6c0127b55222ec1cd496f1a97ca1056c04907e3d3889a95ddbe558e97",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Backpack NFTs"
          }
        }
      },
      "cadence": "import Backpack from 0xBackpack\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Backpack\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Backpack.Collection>(from: /storage/BackpackCollection) == nil {\n      let collection <- Backpack.createEmptyCollection()\n      signer.save(<-collection, to: /storage/BackpackCollection)\n    }\n    if (signer.getCapability<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection).borrow() == nil) {\n      signer.unlink(/public/BackpackCollection)\n      signer.link<&Backpack.Collection{NonFungibleToken.CollectionPublic,Backpack.BackpackCollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/BackpackCollection, target: /storage/BackpackCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xBackpack": {
          "Backpack": {
            "mainnet": {
              "address": "0x807c3d470888cc48",
              "contract": "Backpack",
              "fq_address": "A.0x807c3d470888cc48.Backpack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 47501583
            },
            "testnet": {
              "address": "0xe666c53e1758dec6",
              "contract": "Backpack",
              "fq_address": "A.0xe666c53e1758dec6.Backpack",
              "pin": "3c7796c792dc130c2e565c8246de8a8d5add43e7f340efe20c52568c43602b36",
              "pin_block_height": 95799415
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47501602
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 95799422
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47501609
            },
            "testnet": {
              "address": "0x631e88ae7f1d7c20",
              "contract": "MetadataViews",
              "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 95799431
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "4e34dfa3f4cec6db12271d365e44138f4ec6de67353bd4904fcccb554e7763f6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "4e34dfa3f4cec6db12271d365e44138f4ec6de67353bd4904fcccb554e7763f6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a AeraRewards NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: AeraRewards\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488150
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "ad3eb74b780641b72b00de24d24031484cf32494df467b7e97a97b3ef2ad8892": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "ad3eb74b780641b72b00de24d24031484cf32494df467b7e97a97b3ef2ad8892",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a AeraRewards NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import AeraRewards from 0xAeraRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: AeraRewards\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AeraRewards.Collection>(from: /storage/aeraRewardsNFT) == nil {\n            let collection <- AeraRewards.createEmptyCollection()\n            acct.save(<-collection, to: /storage/aeraRewardsNFT)\n        }\n        if (acct.getCapability<&AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/aeraRewardsNFT).borrow() == nil) {\n            acct.unlink(/public/aeraRewardsNFT)\n            acct.link<&AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/aeraRewardsNFT, target: /storage/aeraRewardsNFT)\n        }\n\n        if (acct.getCapability<&AeraRewards.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/aeraRewardsNFT).borrow() == nil) {\n            acct.unlink(/private/aeraRewardsNFT)\n            acct.link<&AeraRewards.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/aeraRewardsNFT, target: /storage/aeraRewardsNFT)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/aeraRewardsNFT)!\n        let collectionRef = acct\n            .getCapability(/public/aeraRewardsNFT)\n            .borrow<&AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@AeraRewards.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xAeraRewards": {
          "AeraRewards": {
            "mainnet": {
              "address": "0x30cf5dcf6ea8d379",
              "contract": "AeraRewards",
              "fq_address": "A.0x30cf5dcf6ea8d379.AeraRewards",
              "pin": "9a1423cffe6fec0d54875883a31654dc75a7bee580e9f9a3db8c05198e816344",
              "pin_block_height": 47488053
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488057
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488061
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488062
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488062
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488066
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "0584af3913157a3d062d0090cddc47292cec2d2843f49a29bd13cc53c32dd54a": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "0584af3913157a3d062d0090cddc47292cec2d2843f49a29bd13cc53c32dd54a",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed AeraRewards NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import AeraRewards from 0xAeraRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: AeraRewards\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AeraRewards.Collection>(from: /storage/aeraRewardsNFT) == nil {\n            let collection <- AeraRewards.createEmptyCollection()\n            acct.save(<-collection, to: /storage/aeraRewardsNFT)\n            }\n        if (acct.getCapability<&AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/aeraRewardsNFT).borrow() == nil) {\n            acct.unlink(/public/aeraRewardsNFT)\n            acct.link<&AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/aeraRewardsNFT, target: /storage/aeraRewardsNFT)\n        }\n\n        if (acct.getCapability<&AeraRewards.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/aeraRewardsNFT).borrow() == nil) {\n            acct.unlink(/private/aeraRewardsNFT)\n            acct.link<&AeraRewards.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/private/aeraRewardsNFT, target: /storage/aeraRewardsNFT)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/aeraRewardsNFT\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xAeraRewards": {
          "AeraRewards": {
            "mainnet": {
              "address": "0x30cf5dcf6ea8d379",
              "contract": "AeraRewards",
              "fq_address": "A.0x30cf5dcf6ea8d379.AeraRewards",
              "pin": "9a1423cffe6fec0d54875883a31654dc75a7bee580e9f9a3db8c05198e816344",
              "pin_block_height": 47488131
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488135
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488140
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47488140
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47488140
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47488144
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "94fe98de67e3827789a773960a1ba39ceebb7a31e72ce2fc5a5510b5e9cb2aca": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "94fe98de67e3827789a773960a1ba39ceebb7a31e72ce2fc5a5510b5e9cb2aca",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support AeraRewards NFTs"
          }
        }
      },
      "cadence": "import AeraRewards from 0xAeraRewards\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: AeraRewards\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&AeraRewards.Collection>(from: /storage/aeraRewardsNFT) == nil {\n      let collection <- AeraRewards.createEmptyCollection()\n      signer.save(<-collection, to: /storage/aeraRewardsNFT)\n    }\n    if (signer.getCapability<&AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/aeraRewardsNFT).borrow() == nil) {\n      signer.unlink(/public/aeraRewardsNFT)\n      signer.link<&AeraRewards.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/aeraRewardsNFT, target: /storage/aeraRewardsNFT)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xAeraRewards": {
          "AeraRewards": {
            "mainnet": {
              "address": "0x30cf5dcf6ea8d379",
              "contract": "AeraRewards",
              "fq_address": "A.0x30cf5dcf6ea8d379.AeraRewards",
              "pin": "9a1423cffe6fec0d54875883a31654dc75a7bee580e9f9a3db8c05198e816344",
              "pin_block_height": 47487980
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47487984
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47487988
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "cb86442ab817d4446a7ffd54f34c8bdb6c0d2c15782dff52ec1218e60d75e5c5": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "cb86442ab817d4446a7ffd54f34c8bdb6c0d2c15782dff52ec1218e60d75e5c5",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Analogs NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Analogs\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508333
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "62bf25309afa6eccf8593f78c97503ca52f99c96f9adb4f63821c0128dab26cf": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "62bf25309afa6eccf8593f78c97503ca52f99c96f9adb4f63821c0128dab26cf",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Analogs NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Analogs from 0xAnalogs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Analogs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Analogs.Collection>(from: /storage/AnalogsCollection) == nil {\n            let collection <- Analogs.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AnalogsCollection)\n        }\n        if (acct.getCapability<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AnalogsCollection).borrow() == nil) {\n            acct.unlink(/public/AnalogsCollection)\n            acct.link<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AnalogsCollection, target: /storage/AnalogsCollection)\n        }\n\n        if (acct.getCapability<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AnalogsCollection).borrow() == nil) {\n            acct.unlink(/private/AnalogsCollection)\n            acct.link<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AnalogsCollection, target: /storage/AnalogsCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/AnalogsCollection)!\n        let collectionRef = acct\n            .getCapability(/public/AnalogsCollection)\n            .borrow<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Analogs.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xAnalogs": {
          "Analogs": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "Analogs",
              "fq_address": "A.0x427ceada271aa0b1.Analogs",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508295
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508297
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508301
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508302
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508303
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508307
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "3a6fbdd0a1a320c3b2e3a39f5f336f5ebe3a0c591d71141038ee502ec646eec9": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "3a6fbdd0a1a320c3b2e3a39f5f336f5ebe3a0c591d71141038ee502ec646eec9",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Analogs NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Analogs from 0xAnalogs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Analogs\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Analogs.Collection>(from: /storage/AnalogsCollection) == nil {\n            let collection <- Analogs.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AnalogsCollection)\n            }\n        if (acct.getCapability<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AnalogsCollection).borrow() == nil) {\n            acct.unlink(/public/AnalogsCollection)\n            acct.link<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AnalogsCollection, target: /storage/AnalogsCollection)\n        }\n\n        if (acct.getCapability<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AnalogsCollection).borrow() == nil) {\n            acct.unlink(/private/AnalogsCollection)\n            acct.link<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AnalogsCollection, target: /storage/AnalogsCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/AnalogsCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xAnalogs": {
          "Analogs": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "Analogs",
              "fq_address": "A.0x427ceada271aa0b1.Analogs",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508314
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508318
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508321
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47508321
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508322
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508327
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "dfbd759574c476039058cae6a38980e95a92b76a5d410a846346305ebfcd0065": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "dfbd759574c476039058cae6a38980e95a92b76a5d410a846346305ebfcd0065",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Analogs NFTs"
          }
        }
      },
      "cadence": "import Analogs from 0xAnalogs\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Analogs\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Analogs.Collection>(from: /storage/AnalogsCollection) == nil {\n      let collection <- Analogs.createEmptyCollection()\n      signer.save(<-collection, to: /storage/AnalogsCollection)\n    }\n    if (signer.getCapability<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AnalogsCollection).borrow() == nil) {\n      signer.unlink(/public/AnalogsCollection)\n      signer.link<&Analogs.Collection{Analogs.AnalogsCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AnalogsCollection, target: /storage/AnalogsCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xAnalogs": {
          "Analogs": {
            "mainnet": {
              "address": "0x427ceada271aa0b1",
              "contract": "Analogs",
              "fq_address": "A.0x427ceada271aa0b1.Analogs",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47508278
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47508281
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47508285
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "530da9ab706a0754b966fdec3f488a10d218823e4087f493aae57353b84d0ec1": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "530da9ab706a0754b966fdec3f488a10d218823e4087f493aae57353b84d0ec1",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a AsobaNFTCollection NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: AsobaNFTCollection\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512723
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "92e9130bec091d95ca81154b9870a83c0449276a4db3ea06930b775224780c96": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "92e9130bec091d95ca81154b9870a83c0449276a4db3ea06930b775224780c96",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a AsobaNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Asoba from 0xAsoba\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: AsobaNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Asoba.Collection>(from: /storage/AsobaCollection) == nil {\n            let collection <- Asoba.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AsobaCollection)\n        }\n        if (acct.getCapability<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AsobaCollection).borrow() == nil) {\n            acct.unlink(/public/AsobaCollection)\n            acct.link<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AsobaCollection, target: /storage/AsobaCollection)\n        }\n\n        if (acct.getCapability<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AsobaCollection).borrow() == nil) {\n            acct.unlink(/private/AsobaCollection)\n            acct.link<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AsobaCollection, target: /storage/AsobaCollection)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/AsobaCollection)!\n        let collectionRef = acct\n            .getCapability(/public/AsobaCollection)\n            .borrow<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@Asoba.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xAsoba": {
          "Asoba": {
            "mainnet": {
              "address": "0x9eafd89fa6abb1d3",
              "contract": "Asoba",
              "fq_address": "A.0x9eafd89fa6abb1d3.Asoba",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47512684
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512688
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512691
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512691
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512692
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512698
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "5fd1a530e597f26aa08662c062c7939baca226be405adaddb897d7cdbbe9390d": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "5fd1a530e597f26aa08662c062c7939baca226be405adaddb897d7cdbbe9390d",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed AsobaNFTCollection NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import Asoba from 0xAsoba\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: AsobaNFTCollection\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&Asoba.Collection>(from: /storage/AsobaCollection) == nil {\n            let collection <- Asoba.createEmptyCollection()\n            acct.save(<-collection, to: /storage/AsobaCollection)\n            }\n        if (acct.getCapability<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AsobaCollection).borrow() == nil) {\n            acct.unlink(/public/AsobaCollection)\n            acct.link<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AsobaCollection, target: /storage/AsobaCollection)\n        }\n\n        if (acct.getCapability<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AsobaCollection).borrow() == nil) {\n            acct.unlink(/private/AsobaCollection)\n            acct.link<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,MetadataViews.ResolverCollection}>(/private/AsobaCollection, target: /storage/AsobaCollection)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(\n            from: /storage/AsobaCollection\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xAsoba": {
          "Asoba": {
            "mainnet": {
              "address": "0x9eafd89fa6abb1d3",
              "contract": "Asoba",
              "fq_address": "A.0x9eafd89fa6abb1d3.Asoba",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47512707
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512708
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512713
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47512713
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512714
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512718
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "a105ed02e3b72302fb3413c0e514ee831420003adb60cb7aefcc92c1807d3d87": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "a105ed02e3b72302fb3413c0e514ee831420003adb60cb7aefcc92c1807d3d87",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support AsobaNFTCollection NFTs"
          }
        }
      },
      "cadence": "import Asoba from 0xAsoba\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: AsobaNFTCollection\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&Asoba.Collection>(from: /storage/AsobaCollection) == nil {\n      let collection <- Asoba.createEmptyCollection()\n      signer.save(<-collection, to: /storage/AsobaCollection)\n    }\n    if (signer.getCapability<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AsobaCollection).borrow() == nil) {\n      signer.unlink(/public/AsobaCollection)\n      signer.link<&Asoba.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(/public/AsobaCollection, target: /storage/AsobaCollection)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xAsoba": {
          "Asoba": {
            "mainnet": {
              "address": "0x9eafd89fa6abb1d3",
              "contract": "Asoba",
              "fq_address": "A.0x9eafd89fa6abb1d3.Asoba",
              "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
              "pin_block_height": 47512667
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47512669
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47512673
            }
          }
        }
      },
      "arguments": {}
    }
  },
  "62e9abac00308c552544a082b4dc6e83beae420942f8e98542a2af72d612ac0b": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "62e9abac00308c552544a082b4dc6e83beae420942f8e98542a2af72d612ac0b",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the removal of a Aera NFT listing with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the removal of a listing with the StorefrontV2 contract\n// \n// Collection Identifier: Aera\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    \n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontManager}>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefrontV2.Storefront\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: listingResourceID)\n    }\n}\n\n",
      "dependencies": {
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47497743
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        }
      }
    }
  },
  "10efc4c468cddf651d7c6cba5153e7f37f0b9454273ca47589a94559657c1abe": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "10efc4c468cddf651d7c6cba5153e7f37f0b9454273ca47589a94559657c1abe",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the listing of a Aera NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import AeraNFT from 0xAeraNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the listing of an NFT with the StorefrontV2 contract\n// \n// Collection Identifier: Aera\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(saleItemID: UInt64, saleItemPrice: UFix64, customID: String?, commissionAmount: UFix64, expiry: UInt64, marketplacesAddress: [Address]) {\n    /// `saleItemID` - ID of the NFT that is put on sale by the seller.\n    /// `saleItemPrice` - Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT.\n    /// `customID` - Optional string to represent identifier of the dapp.\n    /// `commissionAmount` - Commission amount that will be taken away by the purchase facilitator.\n    /// `expiry` - Unix timestamp at which created listing become expired.\n    /// `marketplacesAddress` - List of addresses that are allowed to get the commission.\n    let ftReceiver: Capability<&AnyResource{FungibleToken.Receiver}>\n    let nftProvider: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefront: &NFTStorefrontV2.Storefront\n    var saleCuts: [NFTStorefrontV2.SaleCut]\n    var marketplacesCapability: [Capability<&AnyResource{FungibleToken.Receiver}>]\n\n    prepare(acct: AuthAccount) {\n        self.saleCuts = []\n        self.marketplacesCapability = []\n\n        // Set up FT to make sure this account can receive the proper currency\n        if acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault) == nil {\n            let vault <- FlowToken.createEmptyVault()\n            acct.save(<-vault, to: /storage/flowTokenVault)\n        }\n\n        if acct.getCapability<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow).borrow() == nil {\n            acct.unlink(/public/flow)\n            acct.link<&FlowToken.Vault{FungibleToken.Receiver,FungibleToken.Balance}>(/public/flow,target: /storage/flowTokenVault)\n        }\n        \n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AeraNFT.Collection>(from: /storage/aeraNFTs) == nil {\n            let collection <- AeraNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/aeraNFTs)\n        }\n        if (acct.getCapability<&AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/public/aeraNFTs).borrow() == nil) {\n            acct.unlink(/public/aeraNFTs)\n            acct.link<&AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/public/aeraNFTs, target: /storage/aeraNFTs)\n        }\n\n        if (acct.getCapability<&AeraNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/private/aeraNFTs).borrow() == nil) {\n            acct.unlink(/private/aeraNFTs)\n            acct.link<&AeraNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/private/aeraNFTs, target: /storage/aeraNFTs)\n        }\n\n        // Receiver for the sale cut.\n        self.ftReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/flow)!\n        assert(self.ftReceiver.borrow() != nil, message: \"Missing or mis-typed Fungible Token receiver\")\n\n        self.nftProvider = acct.getCapability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(/private/aeraNFTs)!\n        let collectionRef = acct\n            .getCapability(/public/aeraNFTs)\n            .borrow<&AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>()\n            ?? panic(\"Could not borrow a reference to the collection\")\n        var totalRoyaltyCut = 0.0\n        let effectiveSaleItemPrice = saleItemPrice - commissionAmount\n\n        let nft = collectionRef.borrowViewResolver(id: saleItemID)!       \n        if (nft.getViews().contains(Type<MetadataViews.Royalties>())) {\n            let royaltiesRef = nft.resolveView(Type<MetadataViews.Royalties>()) ?? panic(\"Unable to retrieve the royalties\")\n            let royalties = (royaltiesRef as! MetadataViews.Royalties).getRoyalties()\n            for royalty in royalties {\n                // TODO - Verify the type of the vault and it should exists\n                self.saleCuts.append(NFTStorefrontV2.SaleCut(receiver: royalty.receiver, amount: royalty.cut * effectiveSaleItemPrice))\n                totalRoyaltyCut = totalRoyaltyCut + royalty.cut * effectiveSaleItemPrice\n            }\n        }\n\n        // Append the cut for the seller.\n        self.saleCuts.append(NFTStorefrontV2.SaleCut(\n            receiver: self.ftReceiver,\n            amount: effectiveSaleItemPrice - totalRoyaltyCut\n        ))\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nftProvider\")\n\n\n        if acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath) == nil {\n            // Create a new empty Storefront\n            let storefront <- NFTStorefrontV2.createStorefront() as! @NFTStorefrontV2.Storefront\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefrontV2.StorefrontStoragePath)\n            // create a public capability for the Storefront\n            acct.link<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(NFTStorefrontV2.StorefrontPublicPath, target: NFTStorefrontV2.StorefrontStoragePath)\n        }\n        self.storefront = acct.borrow<&NFTStorefrontV2.Storefront>(from: NFTStorefrontV2.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        for marketplace in marketplacesAddress {\n            self.marketplacesCapability.append(getAccount(marketplace).getCapability<&{FungibleToken.Receiver}>(/public/flow))\n        }\n    }\n\n    execute {\n        // Create listing\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@AeraNFT.NFT>(),\n            nftID: saleItemID,\n            salePaymentVaultType: Type<@FlowToken.Vault>(),\n            saleCuts: self.saleCuts,\n            marketplacesCapability: self.marketplacesCapability.length == 0 ? nil : self.marketplacesCapability,\n            customID: customID,\n            commissionAmount: commissionAmount,\n            expiry: expiry\n        )\n    }\n}\n",
      "dependencies": {
        "0xAeraNFT": {
          "AeraNFT": {
            "mainnet": {
              "address": "0x30cf5dcf6ea8d379",
              "contract": "AeraNFT",
              "fq_address": "A.0x30cf5dcf6ea8d379.AeraNFT",
              "pin": "0fc563d05b704d6ba528195ab9c037c03727b9c6dcc8a0e46956b69e0609bad1",
              "pin_block_height": 47499042
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499044
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499048
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499050
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499050
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499055
            }
          }
        }
      },
      "arguments": {
        "saleItemID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the NFT that is put on sale by the seller"
              }
            }
          }
        },
        "saleItemPrice": {
          "index": 1,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Amount of tokens (FT) buyer needs to pay for the purchase of listed NFT"
              }
            }
          }
        },
        "customID": {
          "index": 2,
          "type": "String?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional string to represent identifier of the dapp"
              }
            }
          }
        },
        "commissionAmount": {
          "index": 3,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Commission amount that will be taken away by the purchase facilitator"
              }
            }
          }
        },
        "expiry": {
          "index": 4,
          "type": "UFix64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Unix timestamp at which created listing become expired"
              }
            }
          }
        },
        "marketplacesAddress": {
          "index": 5,
          "type": "[Address]",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "List of addresses that are allowed to get the commission"
              }
            }
          }
        }
      }
    }
  },
  "b20485c6500caa277a72104cb982689c354be847ed2f7d0053665b574b1612a6": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "b20485c6500caa277a72104cb982689c354be847ed2f7d0053665b574b1612a6",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction facilitates the purchase of a listed Aera NFT with the StorefrontV2 contract"
          }
        }
      },
      "cadence": "import AeraNFT from 0xAeraNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\nimport FlowToken from 0xFlowToken\nimport FungibleToken from 0xFungibleToken\nimport NFTStorefrontV2 from 0xNFTStorefrontV2\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction facilitates the purchase of a listed NFT with the StorefrontV2 contract \n// \n// Collection Identifier: Aera\n// Vault Identifier: flow\n//\n// Version: 0.1.1\n\ntransaction(listingResourceID: UInt64, storefrontAddress: Address, commissionRecipient: Address?) {\n    /// `listingResourceID` - ID of the Storefront listing resource\n    /// `storefrontAddress` - The address that owns the storefront listing\n    /// `commissionRecipient` - Optional recipient for transaction commission if comission exists.\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}\n    let storefront: &NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}\n    let listing: &NFTStorefrontV2.Listing{NFTStorefrontV2.ListingPublic}\n    var commissionRecipientCap: Capability<&{FungibleToken.Receiver}>?\n\n    prepare(acct: AuthAccount) {\n        self.commissionRecipientCap = nil\n\n        // Set up NFT to make sure this account has NFT setup correctly\n        if acct.borrow<&AeraNFT.Collection>(from: /storage/aeraNFTs) == nil {\n            let collection <- AeraNFT.createEmptyCollection()\n            acct.save(<-collection, to: /storage/aeraNFTs)\n            }\n        if (acct.getCapability<&AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/public/aeraNFTs).borrow() == nil) {\n            acct.unlink(/public/aeraNFTs)\n            acct.link<&AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/public/aeraNFTs, target: /storage/aeraNFTs)\n        }\n\n        if (acct.getCapability<&AeraNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/private/aeraNFTs).borrow() == nil) {\n            acct.unlink(/private/aeraNFTs)\n            acct.link<&AeraNFT.Collection{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/private/aeraNFTs, target: /storage/aeraNFTs)\n        }\n        \n        // Access the storefront public resource of the seller to purchase the listing.\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability<&NFTStorefrontV2.Storefront{NFTStorefrontV2.StorefrontPublic}>(\n                NFTStorefrontV2.StorefrontPublicPath\n            )!\n            .borrow()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        // Borrow the listing\n        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        let price = self.listing.getDetails().salePrice\n\n        // Access the vault of the buyer to pay the sale price of the listing.\n        let mainFTVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n            ?? panic(\"Cannot borrow Fungible Token vault from acct storage\")\n        self.paymentVault <- mainFTVault.withdraw(amount: price)\n\n        // Access the buyer's NFT collection to store the purchased NFT.\n        self.nftCollection = acct.borrow<&AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(\n            from: /storage/aeraNFTs\n        ) ?? panic(\"Cannot borrow NFT collection receiver from account\")\n\n        // Fetch the commission amt.\n        let commissionAmount = self.listing.getDetails().commissionAmount\n\n        if commissionRecipient != nil && commissionAmount != 0.0 {\n            // Access the capability to receive the commission.\n            let _commissionRecipientCap = getAccount(commissionRecipient!).getCapability<&{FungibleToken.Receiver}>(/public/flow)\n            assert(_commissionRecipientCap.check(), message: \"Commission Recipient doesn't have flowtoken receiving capability\")\n            self.commissionRecipientCap = _commissionRecipientCap\n        } else if commissionAmount == 0.0 {\n            self.commissionRecipientCap = nil\n        } else {\n            panic(\"Commission recipient can not be empty when commission amount is non zero\")\n        }\n    }\n\n    execute {\n        // Purchase the NFT\n        let item <- self.listing.purchase(\n            payment: <-self.paymentVault,\n            commissionRecipient: self.commissionRecipientCap\n        )\n        // Deposit the NFT in the buyer's collection.\n        self.nftCollection.deposit(token: <-item)\n    }\n}\n",
      "dependencies": {
        "0xAeraNFT": {
          "AeraNFT": {
            "mainnet": {
              "address": "0x30cf5dcf6ea8d379",
              "contract": "AeraNFT",
              "fq_address": "A.0x30cf5dcf6ea8d379.AeraNFT",
              "pin": "0fc563d05b704d6ba528195ab9c037c03727b9c6dcc8a0e46956b69e0609bad1",
              "pin_block_height": 47499101
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499105
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499108
            }
          }
        },
        "0xFlowToken": {
          "FlowToken": {
            "mainnet": {
              "address": "0x1654653399040a61",
              "contract": "FlowToken",
              "fq_address": "A.0x1654653399040a61.FlowToken",
              "pin": "0326c320322c4e8dde768ba2975c384184fb7e41765c2c87e79a2040bfc71be8",
              "pin_block_height": 47499109
            }
          }
        },
        "0xFungibleToken": {
          "FungibleToken": {
            "mainnet": {
              "address": "0xf233dcee88fe0abe",
              "contract": "FungibleToken",
              "fq_address": "A.0xf233dcee88fe0abe.FungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47499111
            }
          }
        },
        "0xNFTStorefrontV2": {
          "NFTStorefrontV2": {
            "mainnet": {
              "address": "0x4eb8a10cb9f87357",
              "contract": "NFTStorefrontV2",
              "fq_address": "A.0x4eb8a10cb9f87357.NFTStorefrontV2",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47499114
            }
          }
        }
      },
      "arguments": {
        "listingResourceID": {
          "index": 0,
          "type": "UInt64",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "ID of the Storefront listing resource"
              }
            }
          }
        },
        "storefrontAddress": {
          "index": 1,
          "type": "Address",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "The address that owns the storefront listing"
              }
            }
          }
        },
        "commissionRecipient": {
          "index": 2,
          "type": "Address?",
          "messages": {
            "title": {
              "i18n": {
                "en-US": "Optional recipient for transaction commission if comission exists"
              }
            }
          }
        }
      }
    }
  },
  "e828b417a4b4d21317ca9d8e855bf9a6535052a8afdae2cdab4e35440d692b65": {
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "e828b417a4b4d21317ca9d8e855bf9a6535052a8afdae2cdab4e35440d692b65",
    "data": {
      "type": "transaction",
      "interface": "",
      "messages": {
        "title": {
          "i18n": {
            "en-US": "This transaction initializes a user's account to support Aera NFTs"
          }
        }
      },
      "cadence": "import AeraNFT from 0xAeraNFT\nimport NonFungibleToken from 0xNonFungibleToken\nimport MetadataViews from 0xMetadataViews\n// This transaction was auto-generated with the NFT Catalog (https://github.com/dapperlabs/nft-catalog)\n//\n// This transaction initializes a user's collection to support a specific NFT\n// \n// Collection Identifier: Aera\n//\n// Version: 0.1.1\n\ntransaction {\n\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&AeraNFT.Collection>(from: /storage/aeraNFTs) == nil {\n      let collection <- AeraNFT.createEmptyCollection()\n      signer.save(<-collection, to: /storage/aeraNFTs)\n    }\n    if (signer.getCapability<&AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/public/aeraNFTs).borrow() == nil) {\n      signer.unlink(/public/aeraNFTs)\n      signer.link<&AeraNFT.Collection{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection,AeraNFT.CollectionPublic}>(/public/aeraNFTs, target: /storage/aeraNFTs)\n    }\n  }\n\n}\n",
      "dependencies": {
        "0xAeraNFT": {
          "AeraNFT": {
            "mainnet": {
              "address": "0x30cf5dcf6ea8d379",
              "contract": "AeraNFT",
              "fq_address": "A.0x30cf5dcf6ea8d379.AeraNFT",
              "pin": "0fc563d05b704d6ba528195ab9c037c03727b9c6dcc8a0e46956b69e0609bad1",
              "pin_block_height": 47498987
            }
          }
        },
        "0xNonFungibleToken": {
          "NonFungibleToken": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "NonFungibleToken",
              "fq_address": "A.0x1d7e57aa55817448.NonFungibleToken",
              "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
              "pin_block_height": 47498991
            }
          }
        },
        "0xMetadataViews": {
          "MetadataViews": {
            "mainnet": {
              "address": "0x1d7e57aa55817448",
              "contract": "MetadataViews",
              "fq_address": "A.0x1d7e57aa55817448.MetadataViews",
              "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
              "pin_block_height": 47498995
            }
          }
        }
      },
      "arguments": {}
    }
  }
}